<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <title>Żółwik Pro</title>
    <link
      rel="stylesheet"
      href="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.25.0/maps/maps.css"
    />
    <script src="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.25.0/maps/maps-web.min.js"></script>
    <script src="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.25.0/services/services-web.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    />
    <style>
      html,
      body,
      #map {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
      }

      .settings-btn {
        position: absolute;
        top: 10px;
        left: 10px;
        background: white;
        border: none;
        padding: 12px;
        font-size: 20px;
        cursor: pointer;
        border-radius: 50%;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .settings-panel {
        display: none;
        position: absolute;
        top: 70px;
        left: 10px;
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 200px;
      }

      .settings-panel label {
        display: flex;
        align-items: center;
        margin-bottom: 12px;
        cursor: pointer;
        font-size: 16px;
      }

      .settings-panel input[type="checkbox"] {
        margin-right: 10px;
        width: 18px;
        height: 18px;
      }

      .center-btn {
        position: fixed;
        bottom: 30px;
        right: 30px;
        background: #0066ff;
        color: white;
        border: none;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        font-size: 24px;
        cursor: pointer;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .center-btn:hover {
        background: #0055dd;
        transform: scale(1.05);
      }

      .message-box {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        padding: 12px 15px;
        border-radius: 8px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 3;
        display: flex;
        align-items: center;
        max-width: 90%;
        width: auto;
      }

      .message-box-content {
        flex-grow: 1;
        font-size: 16px;
      }

      .message-box-close {
        margin-left: 10px;
        cursor: pointer;
        font-size: 20px;
        padding: 0 5px;
      }

      /* Style dla mobilnego UI */
      @media (max-width: 768px) {
        .settings-btn,
        .search-btn,
        .center-btn,
        .favorites-btn,
        .layers-btn {
          width: 55px;
          height: 55px;
          font-size: 24px;
        }

        .settings-panel,
        .search-panel,
        .favorites-panel,
        .layers-panel {
          width: 80%;
          max-width: 300px;
          left: 50%;
          transform: translateX(-50%);
        }

        .navigation-panel {
          bottom: 30px;
          width: 90%;
        }

        .navigation-icon {
          width: 50px;
          height: 50px;
          font-size: 24px;
        }

        .navigation-info {
          font-size: 18px;
        }

        .navigation-distance,
        .navigation-eta {
          font-size: 16px;
        }

        .search-input {
          height: 50px;
          font-size: 18px;
        }

        .search-result-item {
          padding: 15px;
          font-size: 16px;
        }

        .message-box {
          padding: 15px;
          font-size: 18px;
        }
        
        .user-direction-marker {
          width: 40px;
          height: 40px;
        }
        
        .favorite-item, 
        .add-favorite {
          padding: 15px;
          font-size: 18px;
        }
      }

      /* Styl dla strzałki */
      .user-direction-marker {
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        transform-origin: center center;
      }

      /* Efekty dla SVG strzałki */
      .user-direction-marker svg {
        filter: drop-shadow(0px 2px 3px rgba(0, 0, 0, 0.4));
      }

      /* Animacja pulsowania dla strzałki */
      @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
      }

      /* Dodaj animację pulsowania gdy GPS jest niedokładny */
      .low-accuracy .user-direction-marker svg {
        animation: pulse 2s infinite ease-in-out;
      }

      /* Zwiększ rozmiar strzałki na telefonach dla lepszej widoczności */
      @media (max-width: 768px) {
        .user-direction-marker {
          width: 40px;
          height: 40px;
        }
      }

      .user-accuracy-circle {
        background-color: rgba(0, 122, 255, 0.1);
        border: 1px solid rgba(0, 122, 255, 0.3);
        border-radius: 50%;
      }

      /* Dodatkowe style dla małych ekranów */
      @media (max-width: 480px) {
        .settings-panel {
          width: 200px;
        }

        .message-box {
          width: 85%;
        }
      }

      /* Style dla wyszukiwarki */
      .search-btn {
        position: absolute;
        top: 10px;
        left: 60px;
        background: white;
        border: none;
        padding: 12px;
        font-size: 20px;
        cursor: pointer;
        border-radius: 50%;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .search-panel {
        display: none;
        position: absolute;
        top: 70px;
        left: 60px;
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 300px;
      }

      .search-input {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 16px;
        margin-bottom: 10px;
      }

      .search-results {
        max-height: 300px;
        overflow-y: auto;
      }

      .search-result-item {
        padding: 10px;
        cursor: pointer;
        border-bottom: 1px solid #eee;
      }

      .search-result-item:hover {
        background-color: #f5f5f5;
      }

      /* Style dla nawigacji */
      .navigation-panel {
        display: none;
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 90%;
        max-width: 400px;
      }

      .navigation-step {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }

      .navigation-icon {
        width: 40px;
        height: 40px;
        background: #4CAF50;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 10px;
        color: white;
        font-size: 20px;
      }

      .navigation-info {
        flex-grow: 1;
      }

      .navigation-distance {
        font-size: 14px;
        color: #666;
      }

      .navigation-eta {
        font-size: 14px;
        color: #666;
        margin-top: 5px;
      }

      .navigation-close {
        position: absolute;
        top: 10px;
        right: 10px;
        cursor: pointer;
        font-size: 20px;
      }

      @media (max-width: 768px) {
        .search-panel {
          width: calc(100% - 40px);
          right: 20px;
        }

        .navigation-panel {
          width: calc(100% - 40px);
        }
      }

      /* Style dla ulubionych miejsc */
      .favorites-btn {
        position: absolute;
        top: 10px;
        left: 110px;
        background: white;
        border: none;
        padding: 12px;
        font-size: 20px;
        cursor: pointer;
        border-radius: 50%;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .favorites-panel {
        display: none;
        position: absolute;
        top: 70px;
        left: 110px;
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 250px;
      }

      .favorites-list {
        max-height: 300px;
        overflow-y: auto;
      }

      .favorite-item {
        padding: 10px;
        margin-bottom: 5px;
        border-radius: 5px;
        background-color: #f5f5f5;
        cursor: pointer;
        position: relative;
      }

      .favorite-item:hover {
        background-color: #e5e5e5;
      }

      .favorite-item .delete-btn {
        position: absolute;
        right: 5px;
        top: 50%;
        transform: translateY(-50%);
        color: #ff0000;
        background: none;
        border: none;
        cursor: pointer;
        font-size: 16px;
      }

      .add-favorite {
        margin-top: 10px;
        padding: 8px 12px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        width: 100%;
      }

      /* Style dla legendy */
      .map-features-legend {
        position: absolute;
        bottom: 30px;
        right: 10px;
        background: white;
        padding: 10px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        max-width: 250px;
        display: none;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
      }

      .legend-color {
        width: 15px;
        height: 15px;
        border-radius: 50%;
        margin-right: 10px;
      }

      .legend-title {
        margin: 0 0 10px 0;
        font-weight: bold;
      }

      /* Style dla warstw */
      .layers-btn {
        position: absolute;
        top: 10px;
        left: 160px;
        background: white;
        border: none;
        padding: 12px;
        font-size: 20px;
        cursor: pointer;
        border-radius: 50%;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .layers-panel {
        display: none;
        position: absolute;
        top: 70px;
        left: 160px;
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 250px;
      }

      .layers-panel label {
        display: flex;
        align-items: center;
        margin-bottom: 12px;
        cursor: pointer;
        font-size: 16px;
      }

      .layers-panel input[type="checkbox"] {
        margin-right: 10px;
        width: 18px;
        height: 18px;
      }

      /* Style dla wskaźnika prędkości */
      .speed-container {
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        z-index: 1000;
      }

      .speed-indicator {
        background-color: #0066ff;
        color: white;
        border-radius: 25px;
        padding: 8px 15px;
        margin-right: 10px;
        font-family: Arial, sans-serif;
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        min-width: 80px;
      }

      .speed-limit {
        background-color: white;
        color: #333;
        border: 2px solid #ff0000;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: Arial, sans-serif;
        font-size: 18px;
        font-weight: bold;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      /* Styl dla wskaźnika na telefonie */
      @media (max-width: 768px) {
        .speed-container {
          bottom: 120px;
        }

        .speed-indicator {
          font-size: 28px;
          padding: 10px 20px;
        }

        .speed-limit {
          width: 60px;
          height: 60px;
          font-size: 22px;
        }
      }
    </style>
  </head>

  <body>
    <div id="map" class="map"></div>

    <!-- Przycisk wyszukiwania -->
    <button class="search-btn" id="searchBtn"><i class="fas fa-search"></i></button>

    <!-- Panel wyszukiwania -->
    <div class="search-panel" id="searchPanel">
      <input type="text" class="search-input" id="searchInput" placeholder="Wyszukaj miejsce...">
      <div class="search-results" id="searchResults"></div>
    </div>

    <!-- Panel nawigacji -->
    <div class="navigation-panel" id="navigationPanel">
      <span class="navigation-close" id="navigationClose">&times;</span>
      <div id="navigationContent"></div>
    </div>

    <!-- Przycisk ustawień -->
    <button class="settings-btn"><i class="fas fa-cog"></i></button>

    <!-- Panel ustawień -->
    <div class="settings-panel" id="settingsPanel">
      <label>
        <input type="checkbox" id="flow-toggle" />
        Pokaż ruch drogowy
      </label>
      <label>
        <input id="incidents-toggle" type="checkbox" />
        Pokaż incydenty drogowe
      </label>
      <label>
        <input id="rotation-toggle" type="checkbox" checked />
        Obracaj mapę zgodnie z kierunkiem
      </label>
      <label>
        <input id="buildings-toggle" type="checkbox" />
        Pokaż budynki 3D
      </label>
    </div>

    <!-- Przycisk centrowania -->
    <button class="center-btn" id="centerButton"><i class="fas fa-location-crosshairs"></i></button>

    <!-- Komunikat o błędzie -->
    <div class="message-box" id="messageBox" hidden>
      <div class="message-box-content" id="messageBoxContent"></div>
      <span class="message-box-close" id="messageBoxClose">&times;</span>
    </div>

    <!-- Wskaźnik prędkości -->
    <div class="speed-container" id="speedContainer">
      <div class="speed-indicator" id="speedIndicator">0 km/h</div>
      <div class="speed-limit" id="speedLimit">50</div>
    </div>
    
    <!-- Przycisk ulubionych miejsc -->
    <button class="favorites-btn" id="favoritesBtn"><i class="fas fa-heart"></i></button>

    <!-- Panel ulubionych miejsc -->
    <div class="favorites-panel" id="favoritesPanel">
      <div class="favorites-list" id="favoritesList"></div>
      <button class="add-favorite" id="addFavorite">Dodaj ulubione miejsce</button>
    </div>

    <!-- Przycisk warstw -->
    <button class="layers-btn" id="layersBtn"><i class="fas fa-layer-group"></i></button>

    <!-- Panel warstw -->
    <div class="layers-panel" id="layersPanel">
      <label>
        <input type="checkbox" id="speedcams-toggle" />
        Fotoradary i kontrole prędkości
      </label>
      <label>
        <input type="checkbox" id="roadworks-toggle" />
        Prace drogowe
      </label>
      <label>
        <input type="checkbox" id="poi-toggle" />
        Punkty zainteresowania (POI)
      </label>
      <label>
        <input type="checkbox" id="reports-toggle" />
        Zgłoszenia użytkowników
      </label>
    </div>

    <!-- Legenda -->
    <div class="map-features-legend" id="mapFeaturesLegend">
      <h4 class="legend-title">Legenda</h4>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ff0000;"></div>
        <span>Fotoradar</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ffa500;"></div>
        <span>Kontrola prędkości</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ffff00;"></div>
        <span>Prace drogowe</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ff9900;"></div>
        <span>Kamera drogowa</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #cc0000;"></div>
        <span>Miejsce wypadku</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #0000ff;"></div>
        <span>Ulubione miejsca</span>
      </div>
    </div>

    <script>
      const apiKey = "5sWFmhOgtZG9Aaj19W6LgDwQrwiCFTOG";

      const map = tt.map({
        key: apiKey,
        container: "map",
        center: [21.0122, 52.2297], // Warszawa - tymczasowy punkt startowy
        zoom: 14,
        // style: "tomtom://vector/1/basic-main",
        pitch: 0
      });

      map.addControl(new tt.NavigationControl());
      map.addControl(new tt.FullscreenControl());

      // Inicjalizacja - spróbuj natychmiast pobrać lokalizację
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          function(position) {
            // Otrzymano lokalizację - wycentruj mapę
            const { latitude, longitude } = position.coords;
            map.flyTo({
              center: [longitude, latitude],
              zoom: 16,
              duration: 1000
            });
            // Komunikat
            displayErrorMessage("Lokalizacja znaleziona! Inicjalizacja śledzenia...");
          },
          function(error) {
            // Błąd lokalizacji - pozostawiamy Warszawę
            console.warn("Nie można pobrać początkowej lokalizacji:", error);
            displayErrorMessage("Nie można pobrać Twojej lokalizacji. Wyświetlam domyślny widok.");
          },
          {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 0
          }
        );
      }
      
      // Wymuszenie widoczności przycisku centrowania od początku
      // centerButton.classList.add('visible');
      
      // Obsługa zdarzeń mapy
      map.on('movestart', function(e) {
        if (e.originalEvent) {
          console.log("Użytkownik rozpoczął przesuwanie mapy");
          userMovedMap = true;
          isMapCentered = false;
        }
      });


      // Funkcja wyboru miejsca docelowego i uruchomienia nawigacji
      function selectDestination(destination) {
        if (!userLocationMarker) {
          displayErrorMessage("Najpierw włącz lokalizację GPS");
          return;
        }
        
        // Wyświetl komunikat o uruchamianiu nawigacji
        displayErrorMessage("Uruchamianie nawigacji...");
        
        // Pobierz aktualne współrzędne użytkownika
        const userLocation = userLocationMarker.getLngLat();
        
        // Usuń poprzednią trasę, jeśli istnieje
        if (currentRoute && map.getLayer('route')) {
          map.removeLayer('route');
        }
        
        if (map.getSource('route')) {
          map.removeSource('route');
        }
        
        // Ukryj popup jeśli są otwarte
        const popups = document.getElementsByClassName('mapboxgl-popup');
        while(popups[0]) {
          popups[0].remove();
        }
        
        // Dodaj marker docelowy
        let destinationMarker = new tt.Marker()
          .setLngLat([destination.lng, destination.lat])
          .addTo(map);
        
        // Wycentruj mapę tak aby pokazać obie lokalizacje
        const bounds = new tt.LngLatBounds();
        bounds.extend([userLocation.lng, userLocation.lat]);
        bounds.extend([destination.lng, destination.lat]);
        
        map.fitBounds(bounds, {
          padding: 100,
          duration: 1000
        });
        
        // Wywołanie API routingu TomTom
        const routingApi = 'https://api.tomtom.com/routing/1/calculateRoute/' + 
              userLocation.lat + ',' + userLocation.lng + ':' + 
              destination.lat + ',' + destination.lng + 
              '/json?key=' + apiKey + 
              '&instructionsType=text' +
              '&language=pl-PL' +
              '&traffic=true' +
              '&travelMode=car' +
              '&vehicleHeading=' + (userHeading || 0);
              
        // Pobierz trasę
        fetch(routingApi)
          .then(response => {
            if (!response.ok) {
              throw new Error('Nie można obliczyć trasy');
            }
            return response.json();
          })
          .then(data => {
            // Obsłuż odpowiedź
            if (data && data.routes && data.routes.length > 0) {
              // Zapisz trasę
              currentRoute = data.routes[0];
              
              // Dodaj trasę do mapy
              addRouteToMap(currentRoute);
              
              // Pokaż panel nawigacji
              showNavigationPanel(currentRoute);
              
              // Podaj pierwszą instrukcję głosową
              if (currentRoute.guidance && currentRoute.guidance.instructions && currentRoute.guidance.instructions.length > 0) {
                currentStep = 0;
                const firstInstruction = currentRoute.guidance.instructions[0];
                speakInstruction("Rozpoczęto nawigację. " + firstInstruction.message);
              }
              
              // Ustaw timer aktualizacji trasy
              if (routeUpdateInterval) {
                clearInterval(routeUpdateInterval);
              }
              
              routeUpdateInterval = setInterval(() => {
                updateRouteProgress();
              }, 5000);
              
              // Ukryj komunikat o uruchamianiu
              if (messageBox && !messageBox.getAttribute('hidden')) {
                messageBox.setAttribute('hidden', true);
              }
            } else {
              throw new Error('Brak dostępnych tras');
            }
          })
          .catch(error => {
            console.error('Błąd podczas obliczania trasy:', error);
            displayErrorMessage('Nie można obliczyć trasy: ' + error.message);
            
            // Usuń marker docelowy w przypadku błędu
            destinationMarker.remove();
          });
      }
      // Elementy UI
      const settingsBtn = document.querySelector(".settings-btn");
      const settingsPanel = document.getElementById("settingsPanel");
      const trafficToggle = document.getElementById("flow-toggle");
      const incidentsCheckbox = document.getElementById("incidents-toggle");
      const rotationToggle = document.getElementById("rotation-toggle");
      const centerButton = document.getElementById("centerButton");
      const messageBox = document.getElementById("messageBox");
      const messageBoxContent = document.getElementById("messageBoxContent");
      const messageBoxClose = document.getElementById("messageBoxClose");
      const buildingsToggle = document.getElementById("buildings-toggle");
      const searchBtn = document.getElementById('searchBtn');
      const searchPanel = document.getElementById('searchPanel');
      const searchInput = document.getElementById('searchInput');
      const searchResults = document.getElementById('searchResults');
      const navigationPanel = document.getElementById('navigationPanel');
      const navigationContent = document.getElementById('navigationContent');
      const navigationClose = document.getElementById('navigationClose');
      const favoritesBtn = document.getElementById('favoritesBtn');
      const favoritesPanel = document.getElementById('favoritesPanel');
      const favoritesList = document.getElementById('favoritesList');
      const addFavorite = document.getElementById('addFavorite');
      const layersBtn = document.getElementById('layersBtn');
      const layersPanel = document.getElementById('layersPanel');
      const speedIndicator = document.getElementById('speedIndicator');
      const speedLimit = document.getElementById('speedLimit');
      const speedContainer = document.getElementById('speedContainer');

      // Komunikaty błędów
      const messages = {
        permissionDenied: "Dostęp do lokalizacji został zablokowany. Zmień ustawienia przeglądarki, aby umożliwić geolokalizację.",
        notAvailable: "Nie można określić Twojej lokalizacji. Upewnij się, że usługi lokalizacji są włączone.",
        timeout: "Przekroczono czas oczekiwania na lokalizację. Spróbuj ponownie.",
        default: "Wystąpił błąd podczas określania lokalizacji. Spróbuj odświeżyć stronę."
      };

      // Zmienne stanu
      let trafficIncidentsLayer = null;
      let userLocationMarker = null;
      let userAccuracyCircle = null;
      let userWatchId = null;
      let userHeading = 0;
      let lastPosition = null;
      let lastPositionTimestamp = 0;
      let headingTimeout = null;
      let mapRotationEnabled = true;
      let autoCenteringEnabled = true;
      let isMapCentered = true;
      let lastMapMoveTime = 0;
      let userMovedMap = false;
      let buildings3DEnabled = false;
      
      // Zmienne dla płynnego ruchu
      let animationFrameId = null;
      let targetPosition = null;
      let currentAnimatedPosition = null;
      let lastHeadingUpdateTime = 0;
      let headingChangeRate = 0;
      let lastUpdateTime = 0;

      // Zmienne dla nawigacji
      let currentRoute = null;
      let currentStep = 0;
      let routeUpdateInterval = null;

      // Zmienne dla nawigacji głosowej
      let speechSynthesis = window.speechSynthesis;
      let lastVoiceInstruction = "";
      let lastVoiceTime = 0;
      let voiceEnabled = true;
      let nextManeuverDistance = 0;
      let upcomingManeuver = "";
      
      // Zmienne dla warstw mapy
      let speedcamsLayer = null;
      let roadworksLayer = null;
      let poiLayer = null;
      let favoritesLayer = null;
      let reportsLayer = null;
      
      // Zmienne dla audio
      let originalVolumeOfBackgroundAudio = [];
      let backgroundAudioElements = [];
      let isAudioLowered = false;
      
      // Zmienne dla prędkości
      let currentSpeed = 0;
      let currentSpeedLimit = 50;  // Domyślne ograniczenie prędkości
      let lastSpeedUpdate = 0;
      
      // Ulubione miejsca
      let favoriteLocations = JSON.parse(localStorage.getItem('favoriteLocations') || '[]');

      // Obsługa ruchu drogowego
      trafficToggle.addEventListener("change", () => {
        if (trafficToggle.checked) {
          map.showTrafficFlow();
        } else {
          map.hideTrafficFlow();
        }
      });

      // Obsługa budynków 3D
      buildingsToggle.addEventListener("change", () => {
        if (buildingsToggle.checked) {
          if (!buildings3DEnabled) {
            map.set3DBuildings(true);
            buildings3DEnabled = true;
            
            // Ustaw odpowiedni pitch dla lepszego widoku 3D
            map.easeTo({
              pitch: 45,
              duration: 1000
            });
          }
        } else if (buildings3DEnabled) {
          map.set3DBuildings(false);
          buildings3DEnabled = false;
          
          // Przywróć płaski widok
          map.easeTo({
            pitch: 0,
            duration: 1000
          });
        }
      });

      // Obsługa panelu ustawień
      settingsBtn.addEventListener("click", () => {
        settingsPanel.style.display =
          settingsPanel.style.display === "block" ? "none" : "block";
      });

      // Obsługa przełącznika rotacji
      rotationToggle.addEventListener("change", () => {
        mapRotationEnabled = rotationToggle.checked;
        
        // Jeśli wyłączono rotację, zresetuj orientację mapy
        if (!mapRotationEnabled && isMapCentered) {
          map.easeTo({
            bearing: 0,
            pitch: 0,
            duration: 500
          });
        } else if (mapRotationEnabled && isMapCentered && userHeading !== null) {
          // Włączono rotację i znamy kierunek - obróć mapę
          map.easeTo({
            bearing: userHeading,
            duration: 500
          });
        }
      });

      // Obsługa incydentów drogowych
      incidentsCheckbox.addEventListener("change", () => {
        if (incidentsCheckbox.checked) {
          if (!trafficIncidentsLayer) {
            // Tworzenie warstwy incydentów drogowych
            trafficIncidentsLayer = new tt.VectorTileLayer({
              key: apiKey,
              style: "tomtom://vector/incident",
              refresh: 30000, // Odświeżanie co 30 sekund
              minZoom: 5,
              maxZoom: 19,
              language: 'pl-PL'
            });

            // Dodaj warstwę do mapy
            map.addLayer(trafficIncidentsLayer);

            // Dodaj obsługę kliknięcia w incydent
            map.on('click', 'incidents', (e) => {
              if (e.features.length > 0) {
                const incident = e.features[0].properties;
                const coordinates = e.features[0].geometry.coordinates.slice();
                const description = incident.description || 'Brak opisu';
                const type = incident.type || 'Nieznany typ';
                const severity = incident.severity || 'Nieznana ważność';

                // Utwórz popup z informacjami o incydencie
                new tt.Popup()
                  .setLngLat(coordinates)
                  .setHTML(`
                    <div style="padding: 10px;">
                      <h3 style="margin: 0 0 5px 0;">${type}</h3>
                      <p style="margin: 0 0 5px 0;"><strong>Opis:</strong> ${description}</p>
                      <p style="margin: 0;"><strong>Ważność:</strong> ${severity}</p>
                    </div>
                  `)
                  .addTo(map);
              }
            });

            // Zmień kursor przy najechaniu na incydent
            map.on('mouseenter', 'incidents', () => {
              map.getCanvas().style.cursor = 'pointer';
            });

            map.on('mouseleave', 'incidents', () => {
              map.getCanvas().style.cursor = '';
            });

            // Dodaj legendę incydentów
            const legend = document.createElement('div');
            legend.id = 'incidents-legend';
            legend.style.display = 'none';
            legend.style.position = 'absolute';
            legend.style.bottom = '30px';
            legend.style.left = '10px';
            legend.style.backgroundColor = 'white';
            legend.style.padding = '10px';
            legend.style.borderRadius = '4px';
            legend.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
            legend.style.zIndex = '1';
            legend.innerHTML = `
              <h4 style="margin: 0 0 10px 0;">Legenda incydentów</h4>
              <div style="display: grid; grid-template-columns: auto 1fr; gap: 5px; align-items: center;">
                <span style="display: inline-block; width: 10px; height: 10px; background: #ff0000; border-radius: 50%;"></span>
                <span>Wypadek</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ffa500; border-radius: 50%;"></span>
                <span>Zatłoczenie</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ffff00; border-radius: 50%;"></span>
                <span>Roboty drogowe</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ff00ff; border-radius: 50%;"></span>
                <span>Uszkodzony pojazd</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #00ffff; border-radius: 50%;"></span>
                <span>Zamknięty pas</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #000000; border-radius: 50%;"></span>
                <span>Zamknięta droga</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ff4500; border-radius: 50%;"></span>
                <span>Zagrożenie na drodze</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #800080; border-radius: 50%;"></span>
                <span>Wydarzenie planowane</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #4169e1; border-radius: 50%;"></span>
                <span>Zła pogoda</span>
              </div>
            `;
            document.body.appendChild(legend);

            // Pokaż/ukryj legendę przy zmianie stanu checkboxa
            incidentsCheckbox.addEventListener('change', () => {
              legend.style.display = incidentsCheckbox.checked ? 'block' : 'none';
            });
          }
        } else if (trafficIncidentsLayer) {
          map.removeLayer(trafficIncidentsLayer);
          trafficIncidentsLayer = null;
          
          // Ukryj legendę
          const legend = document.getElementById('incidents-legend');
          if (legend) {
            legend.style.display = 'none';
          }
        }
      });

      // Obsługa wyszukiwania
      searchBtn.addEventListener('click', () => {
        searchPanel.style.display = searchPanel.style.display === 'block' ? 'none' : 'block';
        if (searchPanel.style.display === 'block') {
          searchInput.focus();
        }
      });

      // Autocomplete dla wyszukiwania
      let searchTimeout;
      searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value;
        
        if (query.length < 3) {
          searchResults.innerHTML = '';
          return;
        }

        searchTimeout = setTimeout(() => {
          tt.services.fuzzySearch({
            key: apiKey,
            query: query,
            language: 'pl-PL',
            limit: 5
          })
          .then(response => {
            searchResults.innerHTML = '';
            response.results.forEach(result => {
              const div = document.createElement('div');
              div.className = 'search-result-item';
              div.textContent = result.address.freeformAddress;
              div.addEventListener('click', () => {
                selectDestination(result.position);
                searchPanel.style.display = 'none';
              });
              searchResults.appendChild(div);
            });
          })
          .catch(error => {
            console.error('Błąd wyszukiwania:', error);
          });
        }, 300);
      });

      // Obsługa warstw
      layersBtn.addEventListener('click', () => {
        layersPanel.style.display = layersPanel.style.display === 'block' ? 'none' : 'block';
      });

      // Obsługa fotoradarów i kontroli prędkości
      document.getElementById('speedcams-toggle').addEventListener('change', (e) => {
        if (e.target.checked) {
          loadSpeedCameras();
          document.getElementById('mapFeaturesLegend').style.display = 'block';
        } else {
          if (speedcamsLayer) {
            map.removeLayer('speedcams');
            map.removeSource('speedcams');
            speedcamsLayer = null;
          }
          updateLegendVisibility();
        }
      });

      // Obsługa prac drogowych
      document.getElementById('roadworks-toggle').addEventListener('change', (e) => {
        if (e.target.checked) {
          loadRoadworks();
          document.getElementById('mapFeaturesLegend').style.display = 'block';
        } else {
          if (roadworksLayer) {
            map.removeLayer('roadworks');
            map.removeSource('roadworks');
            roadworksLayer = null;
          }
          updateLegendVisibility();
        }
      });

      // Obsługa POI
      document.getElementById('poi-toggle').addEventListener('change', (e) => {
        if (e.target.checked) {
          loadPointsOfInterest();
        } else {
          if (poiLayer) {
            map.removeLayer('pois');
            map.removeSource('pois');
            poiLayer = null;
          }
        }
      });

      // Obsługa zgłoszeń użytkowników
      document.getElementById('reports-toggle').addEventListener('change', (e) => {
        if (e.target.checked) {
          if (lastPosition) {
            loadReportsFromOverpass(lastPosition[1], lastPosition[0]);
          } else {
          displayErrorMessage('Najpierw włącz lokalizację GPS');
            e.target.checked = false;
          }
        } else {
          if (reportsLayer) {
            map.removeLayer('reports');
            map.removeSource('reports');
            reportsLayer = null;
          }
        }
      });

      // Ładowanie zgłoszeń z Overpass API
      function loadReportsFromOverpass(lat, lng) {
        // Pokaż informację o ładowaniu
        displayErrorMessage('Ładowanie zgłoszeń z Overpass API...');
        
        // Promień wyszukiwania w metrach
        const radius = 10000; // 10km
        
        // Budowanie zapytania Overpass
        const query = `
          [out:json][timeout:25];
          (
            // Fotoradary
            node["highway"="speed_camera"](around:${radius},${lat},${lng});
            // Kamery drogowe
            node["highway"="traffic_signals"]["camera"](around:${radius},${lat},${lng});
            // Prace drogowe
            way["highway"]["construction"](around:${radius},${lat},${lng});
            // Miejsca częstej kontroli prędkości
            node["highway"]["traffic_calming"](around:${radius},${lat},${lng});
            // Miejsca wypadków
            node["hazard"="accident"](around:${radius},${lat},${lng});
          );
          out body;
          >;
          out skel qt;
        `;
        
        // Teraz faktycznie używamy API Overpass zamiast symulowanych danych
        const overpassUrl = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;
        
        fetch(overpassUrl)
          .then(response => {
            if (!response.ok) {
              throw new Error('Błąd pobierania danych z API Overpass');
            }
            return response.json();
          })
          .then(data => {
            processOverpassResults(data);
          })
          .catch(error => {
            console.error('Błąd zapytania Overpass:', error);
            displayErrorMessage('Nie udało się pobrać zgłoszeń. Używam danych lokalnych.');
            
            // Fallback na dane offline jeśli API nie odpowiada
            const simulatedResults = {
              elements: [
                { 
                  id: 1, 
                  type: "node", 
                  lat: lat + 0.002, 
                  lon: lng + 0.003, 
                  tags: { 
                    highway: "speed_camera", 
                    name: "Fotoradar stacjonarny", 
                    description: "Kontrola prędkości na prostym odcinku" 
                  } 
                },
                { 
                  id: 2, 
                  type: "node", 
                  lat: lat - 0.001, 
                  lon: lng + 0.002, 
                  tags: { 
                    highway: "traffic_signals", 
                    camera: "yes", 
                    name: "Kamera na skrzyżowaniu", 
                    description: "Monitoring przejazdu na czerwonym świetle" 
                  } 
                },
                { 
                  id: 3, 
                  type: "node", 
                  lat: lat + 0.003, 
                  lon: lng - 0.002, 
                  tags: { 
                    highway: "traffic_calming", 
                    name: "Częste kontrole prędkości", 
                    description: "Miejsce regularnych kontroli policyjnych" 
                  } 
                },
                { 
                  id: 4, 
                  type: "node", 
                  lat: lat - 0.002, 
                  lon: lng - 0.001, 
                  tags: { 
                    hazard: "accident", 
                    name: "Miejsce wypadku", 
                    description: "Niebezpieczne skrzyżowanie, częste kolizje" 
                  } 
                }
              ]
            };
            processOverpassResults(simulatedResults);
          });
      }
      
      // Przetwarzanie wyników z Overpass API
      function processOverpassResults(data) {
        if (!data || !data.elements || data.elements.length === 0) {
          displayErrorMessage('Brak zgłoszeń w okolicy');
          return;
        }
        
        // Ukryj komunikat o ładowaniu
        if (messageBox && !messageBox.getAttribute('hidden')) {
          messageBox.setAttribute('hidden', true);
        }
        
        // Przygotuj features dla GeoJSON
        const features = data.elements.map(element => {
          // Sprawdź czy element ma współrzędne
          if (!element.lat || !element.lon) return null;
          
          // Określ typ zgłoszenia i ikonę
          let type = 'unknown';
          let icon = 'marker-15';
          let color = '#ff0000';
          let description = 'Brak opisu';
          
          if (element.tags) {
            if (element.tags.highway === 'speed_camera') {
              type = 'speed_camera';
              icon = 'camera-15';
              color = '#ff0000';
              description = element.tags.description || 'Fotoradar';
            } else if (element.tags.camera === 'yes') {
              type = 'traffic_camera';
              icon = 'camera-15';
              color = '#ff9900';
              description = element.tags.description || 'Kamera drogowa';
            } else if (element.tags.construction) {
              type = 'roadworks';
              icon = 'roadblock-15';
              color = '#ffcc00';
              description = element.tags.description || 'Prace drogowe';
            } else if (element.tags.traffic_calming) {
              type = 'speed_control';
              icon = 'police-15';
              color = '#ffa500';
              description = element.tags.description || 'Kontrola prędkości';
            } else if (element.tags.hazard === 'accident') {
              type = 'accident';
              icon = 'danger-15';
              color = '#cc0000';
              description = element.tags.description || 'Miejsce wypadku';
            }
          }
          
          // Utwórz feature GeoJSON
          return {
              type: 'Feature',
            properties: {
              id: element.id,
              type: type,
              name: element.tags?.name || 'Zgłoszenie',
              description: description,
              color: color
            },
              geometry: {
              type: 'Point',
              coordinates: [element.lon, element.lat]
            }
          };
        }).filter(feature => feature !== null);
        
        // Usuń istniejącą warstwę jeśli istnieje
        if (map.getLayer('reports')) {
          map.removeLayer('reports');
        }
        
        if (map.getSource('reports')) {
          map.removeSource('reports');
        }
        
        // Dodaj źródło danych
        map.addSource('reports', {
                type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features: features
          }
              });

        // Dodaj warstwę
              map.addLayer({
          id: 'reports',
          type: 'symbol',
          source: 'reports',
                layout: {
            'icon-image': [
              'match',
              ['get', 'type'],
              'speed_camera', 'camera-15',
              'traffic_camera', 'camera-15',
              'roadworks', 'roadblock-15',
              'speed_control', 'police-15',
              'accident', 'danger-15',
              'marker-15'
            ],
            'icon-size': 1.2,
            'icon-allow-overlap': true,
            'text-field': ['get', 'name'],
            'text-font': ['Arial Unicode MS Bold'],
            'text-offset': [0, 1],
            'text-anchor': 'top'
                },
                paint: {
            'text-color': ['get', 'color'],
            'text-halo-color': '#ffffff',
            'text-halo-width': 1
          }
        });
        
        // Dodaj obsługę kliknięcia
        map.on('click', 'reports', (e) => {
          const properties = e.features[0].properties;
          const coordinates = e.features[0].geometry.coordinates.slice();
          
          // Utwórz popup
          new tt.Popup()
            .setLngLat(coordinates)
            .setHTML(`
              <div style="padding: 10px;">
                <h3 style="margin: 0 0 5px 0;">${properties.name}</h3>
                <p style="margin: 0;">${properties.description}</p>
              </div>
            `)
            .addTo(map);
        });
        
        // Zmień kursor przy najeździe
        map.on('mouseenter', 'reports', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        
        map.on('mouseleave', 'reports', () => {
          map.getCanvas().style.cursor = '';
        });
        
        reportsLayer = true;
        
        // Aktualizuj legendę
        document.getElementById('mapFeaturesLegend').style.display = 'block';
      }

      // Funkcja aktualizująca widoczność legendy
      function updateLegendVisibility() {
        const shouldShowLegend = document.getElementById('speedcams-toggle').checked || 
                                document.getElementById('roadworks-toggle').checked ||
                                document.getElementById('reports-toggle').checked;
        document.getElementById('mapFeaturesLegend').style.display = shouldShowLegend ? 'block' : 'none';
      }

      // Obsługa ulubionych miejsc
      favoritesBtn.addEventListener('click', () => {
        favoritesPanel.style.display = favoritesPanel.style.display === 'block' ? 'none' : 'block';
        if (favoritesPanel.style.display === 'block') {
          renderFavorites();
        }
      });

      // Dodanie ulubionego miejsca
      addFavorite.addEventListener('click', () => {
        if (!userLocationMarker) {
          displayErrorMessage('Najpierw włącz lokalizację GPS');
          return;
        }

        const position = userLocationMarker.getLngLat();
        const name = prompt('Nazwa ulubionego miejsca:');
        
        if (!name) return;
        
        const favorite = {
          id: Date.now().toString(),
          name,
          position: {
            lat: position.lat,
            lng: position.lng
          }
        };
        
        favoriteLocations.push(favorite);
        localStorage.setItem('favoriteLocations', JSON.stringify(favoriteLocations));
        
        renderFavorites();
        updateFavoritesOnMap();
      });

      // Renderowanie listy ulubionych miejsc
      function renderFavorites() {
        favoritesList.innerHTML = '';
        
        if (favoriteLocations.length === 0) {
          favoritesList.innerHTML = '<div style="padding: 10px;">Brak ulubionych miejsc</div>';
          return;
        }
        
        favoriteLocations.forEach(favorite => {
          const item = document.createElement('div');
          item.className = 'favorite-item';
          item.textContent = favorite.name;
          
          // Przycisk usuwania
          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'delete-btn';
          deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
          deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removeFavorite(favorite.id);
          });
          
          item.appendChild(deleteBtn);
          
          // Wybór ulubionego miejsca
          item.addEventListener('click', () => {
            selectDestination(favorite.position);
            favoritesPanel.style.display = 'none';
          });
          
          favoritesList.appendChild(item);
        });
      }

      // Usuwanie ulubionego miejsca
      function removeFavorite(id) {
        favoriteLocations = favoriteLocations.filter(fav => fav.id !== id);
        localStorage.setItem('favoriteLocations', JSON.stringify(favoriteLocations));
        renderFavorites();
        updateFavoritesOnMap();
      }

      // Aktualizacja ulubionych miejsc na mapie
      function updateFavoritesOnMap() {
        // Usuń istniejącą warstwę
        if (map.getLayer('favorites')) {
          map.removeLayer('favorites');
        }
        
        if (map.getSource('favorites')) {
          map.removeSource('favorites');
        }
        
        // Stwórz źródło danych GeoJSON
        const features = favoriteLocations.map(favorite => ({
          type: 'Feature',
          properties: {
            name: favorite.name,
            id: favorite.id
          },
          geometry: {
            type: 'Point',
            coordinates: [favorite.position.lng, favorite.position.lat]
          }
        }));
        
        // Dodaj źródło danych
        map.addSource('favorites', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features
          }
        });
        
        // Dodaj warstwę
        map.addLayer({
          id: 'favorites',
          type: 'symbol',
          source: 'favorites',
          layout: {
            'icon-image': 'marker-15',
            'icon-size': 1.5,
            'text-field': ['get', 'name'],
            'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
            'text-offset': [0, 1.5],
            'text-anchor': 'top'
          },
          paint: {
            'text-color': '#0000ff',
            'text-halo-color': '#ffffff',
            'text-halo-width': 1
          }
        });
        
        // Dodaj obsługę kliknięcia
        map.on('click', 'favorites', (e) => {
          const properties = e.features[0].properties;
          const coordinates = e.features[0].geometry.coordinates.slice();
          
          // Utwórz popup
          new tt.Popup()
            .setLngLat(coordinates)
            .setHTML(`
              <div style="padding: 10px;">
                <h3 style="margin: 0 0 10px 0;">${properties.name}</h3>
                <button id="navigate-favorite" style="padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Nawiguj</button>
              </div>
            `)
            .addTo(map);
            
          // Obsługa przycisku w popup
                  setTimeout(() => {
            document.getElementById('navigate-favorite').addEventListener('click', () => {
              const favorite = favoriteLocations.find(f => f.id === properties.id);
              if (favorite) {
                selectDestination(favorite.position);
              }
            });
          }, 100);
        });
        
        // Zmień kursor przy najeździe na ulubione miejsce
        map.on('mouseenter', 'favorites', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        
        map.on('mouseleave', 'favorites', () => {
          map.getCanvas().style.cursor = '';
        });
      }

      // Ładowanie fotoradarów i kontroli prędkości
      function loadSpeedCameras() {
        // Symulacja danych - w rzeczywistej aplikacji użylibyśmy API
        const speedCameras = [
          // Przykładowe dane - w rzeczywistej aplikacji pobralibyśmy te informacje z API
          { type: "speed_camera", lat: 52.2297, lng: 21.0122, description: "Fotoradar stacjonarny" },
          { type: "speed_control", lat: 52.2350, lng: 21.0091, description: "Częsta kontrola prędkości" }
        ];
        
        // Przygotowanie źródła danych GeoJSON
        const features = speedCameras.map(camera => ({
          type: 'Feature',
          properties: {
            type: camera.type,
            description: camera.description
          },
          geometry: {
            type: 'Point',
            coordinates: [camera.lng, camera.lat]
          }
        }));
        
        // Dodaj źródło danych
        map.addSource('speedcams', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features
          }
        });
        
        // Dodaj warstwę
        map.addLayer({
          id: 'speedcams',
          type: 'symbol',
          source: 'speedcams',
          layout: {
            'icon-image': 'marker-15',
            'icon-size': 1.2,
            'icon-allow-overlap': true
          },
          paint: {
            'icon-color': [
              'match',
              ['get', 'type'],
              'speed_camera', '#ff0000',
              'speed_control', '#ffa500',
              '#ff0000'
            ]
          }
        });
        
        // Dodaj obsługę kliknięcia
        map.on('click', 'speedcams', (e) => {
          const properties = e.features[0].properties;
          const coordinates = e.features[0].geometry.coordinates.slice();
          
          // Utwórz popup
          new tt.Popup()
            .setLngLat(coordinates)
            .setHTML(`
              <div style="padding: 10px;">
                <h3 style="margin: 0 0 5px 0;">${properties.type === 'speed_camera' ? 'Fotoradar' : 'Kontrola prędkości'}</h3>
                <p style="margin: 0;">${properties.description}</p>
              </div>
            `)
            .addTo(map);
        });
        
        // Zmień kursor przy najeździe
        map.on('mouseenter', 'speedcams', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        
        map.on('mouseleave', 'speedcams', () => {
          map.getCanvas().style.cursor = '';
        });
        
        speedcamsLayer = true;
      }

      // Ładowanie prac drogowych
      function loadRoadworks() {
        // W rzeczywistej aplikacji użylibyśmy API Overpass
        // Symulacja danych
        const roadworks = [
          // Przykładowe dane
          { lat: 52.2340, lng: 21.0180, description: "Przebudowa drogi, zwężenie do jednego pasa", endDate: "2023-12-31" },
          { lat: 52.2280, lng: 21.0050, description: "Remont chodnika", endDate: "2023-11-15" }
        ];
        
        // Przygotowanie źródła danych GeoJSON
        const features = roadworks.map(work => ({
          type: 'Feature',
          properties: {
            description: work.description,
            endDate: work.endDate
          },
          geometry: {
            type: 'Point',
            coordinates: [work.lng, work.lat]
          }
        }));
        
        // Dodaj źródło danych
        map.addSource('roadworks', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features
          }
        });
        
        // Dodaj warstwę
        map.addLayer({
          id: 'roadworks',
          type: 'symbol',
          source: 'roadworks',
          layout: {
            'icon-image': 'marker-15',
            'icon-size': 1.2,
            'icon-allow-overlap': true
          },
          paint: {
            'icon-color': '#ffff00'
          }
        });
        
        // Dodaj obsługę kliknięcia
        map.on('click', 'roadworks', (e) => {
          const properties = e.features[0].properties;
          const coordinates = e.features[0].geometry.coordinates.slice();
          
          // Utwórz popup
          new tt.Popup()
            .setLngLat(coordinates)
            .setHTML(`
              <div style="padding: 10px;">
                <h3 style="margin: 0 0 5px 0;">Prace drogowe</h3>
                <p style="margin: 0 0 5px 0;">${properties.description}</p>
                <p style="margin: 0;"><strong>Planowany koniec:</strong> ${properties.endDate}</p>
              </div>
            `)
            .addTo(map);
        });
        
        // Zmień kursor przy najeździe
        map.on('mouseenter', 'roadworks', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        
        map.on('mouseleave', 'roadworks', () => {
          map.getCanvas().style.cursor = '';
        });
        
        roadworksLayer = true;
      }

      // Ładowanie punktów zainteresowania (POI)
      function loadPointsOfInterest() {
        // W rzeczywistej aplikacji użylibyśmy Overpass API
        // Przykładowy kod zapytania Overpass:
        // const query = `
        //   [out:json];
        //   (
        //     node["amenity"](around:1000,${lat},${lng});
        //     node["shop"](around:1000,${lat},${lng});
        //   );
        //   out;
        // `;
        
        // Symulacja danych
        const pois = [
          { lat: 52.2320, lng: 21.0100, name: "Restauracja Pod Jabłonią", type: "restaurant" },
          { lat: 52.2300, lng: 21.0150, name: "Stacja paliw BP", type: "fuel" },
          { lat: 52.2270, lng: 21.0080, name: "Sklep spożywczy", type: "shop" }
        ];
        
        // Przygotowanie źródła danych GeoJSON
        const features = pois.map(poi => ({
          type: 'Feature',
          properties: {
            name: poi.name,
            type: poi.type
          },
          geometry: {
            type: 'Point',
            coordinates: [poi.lng, poi.lat]
          }
        }));
        
        // Dodaj źródło danych
        map.addSource('pois', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features
          }
        });
        
        // Dodaj warstwę
        map.addLayer({
          id: 'pois',
          type: 'symbol',
          source: 'pois',
          layout: {
            'icon-image': 'marker-15',
            'icon-size': 1,
            'text-field': ['get', 'name'],
            'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
            'text-offset': [0, 1.5],
            'text-anchor': 'top'
          },
          paint: {
            'text-color': '#333333',
            'text-halo-color': '#ffffff',
            'text-halo-width': 1
          }
        });
        
        // Dodaj obsługę kliknięcia
        map.on('click', 'pois', (e) => {
          const properties = e.features[0].properties;
          const coordinates = e.features[0].geometry.coordinates.slice();
          
          // Utwórz popup
          new tt.Popup()
            .setLngLat(coordinates)
            .setHTML(`
              <div style="padding: 10px;">
                <h3 style="margin: 0 0 5px 0;">${properties.name}</h3>
                <p style="margin: 0 0 5px 0;">Typ: ${properties.type}</p>
                <button id="navigate-poi" style="padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Nawiguj</button>
              </div>
            `)
            .addTo(map);
            
          // Obsługa przycisku w popup
          setTimeout(() => {
            document.getElementById('navigate-poi').addEventListener('click', () => {
              selectDestination({lat: coordinates[1], lng: coordinates[0]});
            });
          }, 100);
        });
        
        // Zmień kursor przy najeździe
        map.on('mouseenter', 'pois', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        
        map.on('mouseleave', 'pois', () => {
          map.getCanvas().style.cursor = '';
        });
        
        poiLayer = true;
      }

      // Wyciszanie dźwięków w tle podczas nawigacji głosowej
      function lowerBackgroundAudio() {
        // Jeśli już wyciszone, nie rób nic
        if (isAudioLowered) return;
        
        console.log("Wyciszanie dźwięków w tle...");
        
        // Zbierz wszystkie elementy audio i video na stronie
        const mediaElements = [
          ...document.querySelectorAll('audio:not([data-navigation-voice])'),
          ...document.querySelectorAll('video')
        ];
        
        if (mediaElements.length === 0) {
          console.log("Nie znaleziono elementów audio/video do wyciszenia");
          return;
        }
        
        // Zapisz obecną głośność i elementy
        backgroundAudioElements = mediaElements;
        originalVolumeOfBackgroundAudio = mediaElements.map(el => el.volume);
        
        // Wycisz każdy element
        mediaElements.forEach(el => {
          // Zapisz aktualną głośność i zmniejsz do 20%
          try {
            if (el.volume > 0.2) {
              const originalVolume = el.volume;
              el.volume = 0.2; // Zmniejsz głośność do 20%
              console.log(`Zmniejszono głośność z ${originalVolume} do ${el.volume}`);
            }
          } catch (error) {
            console.error("Błąd podczas zmiany głośności:", error);
          }
        });
        
        isAudioLowered = true;
      }

      // Przywracanie głośności
      function restoreBackgroundAudio() {
        // Jeśli nie są wyciszone, nie rób nic
        if (!isAudioLowered) return;
        
        console.log("Przywracanie oryginalnej głośności...");
        
        // Przywróć głośność każdego elementu
        backgroundAudioElements.forEach((el, index) => {
          if (index < originalVolumeOfBackgroundAudio.length) {
            try {
              const targetVolume = originalVolumeOfBackgroundAudio[index];
              el.volume = targetVolume;
              console.log(`Przywrócono głośność do ${targetVolume}`);
            } catch (error) {
              console.error("Błąd podczas przywracania głośności:", error);
            }
          }
        });
        
        isAudioLowered = false;
      }

      // Funkcja do odtwarzania instrukcji głosowych
      function speakInstruction(text) {
        if (!voiceEnabled || !speechSynthesis) return;
        
        // Nie powtarzaj tej samej instrukcji zbyt często
        const now = Date.now();
        if (text === lastVoiceInstruction && now - lastVoiceTime < 10000) return;
        
        // Wycisz dźwięki w tle
        lowerBackgroundAudio();
        
        // Zatrzymaj wszystkie aktualnie odtwarzane głosy
        speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'pl-PL';
        utterance.volume = 1;
        utterance.rate = 1;
        utterance.pitch = 1;
        
        // Znajdź polski głos, jeśli jest dostępny
        const voices = speechSynthesis.getVoices();
        const polishVoice = voices.find(voice => voice.lang.includes('pl'));
        if (polishVoice) {
          utterance.voice = polishVoice;
        }
        
        // Przywróć głośność po zakończeniu wypowiedzi
        utterance.onend = function() {
          console.log("Wypowiedź zakończona, przywracanie głośności");
          setTimeout(restoreBackgroundAudio, 500);
        };
        
        // Na wypadek błędu w odtwarzaniu
        utterance.onerror = function(event) {
          console.error("Błąd podczas odtwarzania głosu:", event);
          restoreBackgroundAudio();
        };
        
        speechSynthesis.speak(utterance);
        
        lastVoiceInstruction = text;
        lastVoiceTime = now;
      }

      // Aktualizacja instrukcji głosowych na podstawie aktualnej pozycji
      function updateVoiceGuidance(userLocation) {
        if (!currentRoute || !currentRoute.guidance || !currentRoute.guidance.instructions) return;
        
        if (currentStep >= currentRoute.guidance.instructions.length) return;
        
        const currentInstruction = currentRoute.guidance.instructions[currentStep];
        
        if (!currentInstruction || !currentInstruction.point) return;
        
        // Oblicz odległość do kolejnego manewru
        const distanceToManeuver = calculateDistance(
          userLocation[1], userLocation[0],
          currentInstruction.point.latitude, currentInstruction.point.longitude
        );
        
        // Aktualizuj wartości dla wyświetlania i komunikatów
        nextManeuverDistance = distanceToManeuver;
        upcomingManeuver = currentInstruction.message;
        
        // Odtwórz instrukcje głosowe na podstawie odległości
        if (distanceToManeuver <= 35 && Math.abs(distanceToManeuver - nextManeuverDistance) > 10) {
          // Tuż przed manewrem (35m lub mniej)
          speakInstruction(formatVoiceInstruction(currentInstruction, distanceToManeuver));
        } else if (distanceToManeuver <= 150 && Math.abs(distanceToManeuver - nextManeuverDistance) > 20) {
          // Zbliżamy się do manewru (150-35m)
          speakInstruction(formatVoiceInstruction(currentInstruction, distanceToManeuver));
        } else if (distanceToManeuver <= 500 && Math.abs(distanceToManeuver - nextManeuverDistance) > 50) {
          // Manewr jest w zasięgu (500-150m)
          speakInstruction(formatVoiceInstruction(currentInstruction, distanceToManeuver));
        }
        
        // Aktualizacja panelu nawigacji
        updateNavigationPanel(distanceToManeuver);
      }

      // Aktualizacja panelu nawigacji
      function updateNavigationPanel(distanceToManeuver) {
        const distanceElement = document.getElementById('next-maneuver-distance');
        if (distanceElement) {
          distanceElement.textContent = `${Math.round(distanceToManeuver)}`;
        }
      }

      // Funkcja do formatowania instrukcji głosowej
      function formatVoiceInstruction(step, distance) {
        if (!step) return "";
        
        let message = step.message || "";
        if (typeof message !== 'string') {
          return "";
        }
        
        message = message.toLowerCase();
        const distanceInMeters = Math.round(distance);
        
        if (distanceInMeters <= 35) {
          // Jeśli jesteśmy blisko manewru (35 metrów lub mniej)
          if (message.includes("skręć w lewo")) {
            return "Skręć w lewo";
          } else if (message.includes("skręć w prawo")) {
            return "Skręć w prawo";
          } else if (message.includes("zawróć")) {
            return "Zawróć";
          } else if (message.includes("prosto")) {
            return "Jedź prosto";
          } else if (message.includes("rondo")) {
            if (message.includes("pierwszy")) {
              return "Na rondzie pierwszy zjazd";
            } else if (message.includes("drugi")) {
              return "Na rondzie drugi zjazd";
            } else if (message.includes("trzeci")) {
              return "Na rondzie trzeci zjazd";
            } else {
              return message;
            }
          } else {
            return message;
          }
        } else {
          // Jeśli jesteśmy dalej od manewru
          let instruction = `Za ${distanceInMeters} metrów `;
          
          if (message.includes("skręć w lewo")) {
            instruction += "skręć w lewo";
          } else if (message.includes("skręć w prawo")) {
            instruction += "skręć w prawo";
          } else if (message.includes("zawróć")) {
            instruction += "zawróć";
          } else if (message.includes("prosto")) {
            instruction += "jedź prosto";
          } else if (message.includes("rondo")) {
            if (message.includes("pierwszy")) {
              instruction += "na rondzie pierwszy zjazd";
            } else if (message.includes("drugi")) {
              instruction += "na rondzie drugi zjazd";
            } else if (message.includes("trzeci")) {
              instruction += "na rondzie trzeci zjazd";
            } else {
              instruction += message;
            }
          } else {
            instruction += message;
          }
          
          return instruction;
        }
      }

      // Aktualizacja lokalizacji użytkownika
      function updateUserLocation(position) {
        const { latitude, longitude, accuracy, heading, speed } = position.coords;
        
        // Zapisz dokładność do późniejszego użycia
        window.lastAccuracy = accuracy;
        
        // Dla debugowania
        console.log("GPS update - heading:", heading, "accuracy:", accuracy, "coords:", latitude, longitude, "speed:", speed);
        
        // Aktualizacja prędkości
        updateSpeedIndicator(speed, latitude, longitude);
        
        // Filtrujemy odczyty z niską dokładnością
        // Na telefonach często początkowe odczyty mają bardzo niską dokładność
        if (accuracy > 500) {
          console.warn("Niska dokładność GPS:", accuracy, "m - czekam na lepszy sygnał");
          
          // Jeśli jeszcze nie mamy markera, to wyświetlamy pozycję z niską dokładnością
          // ale komunikujemy użytkownikowi, że dokładność jest niska
          if (!userLocationMarker) {
            displayErrorMessage("Niska dokładność GPS (" + Math.round(accuracy) + "m). Poczekaj na lepszy sygnał.");
            
            // Tworzymy marker mimo wszystko, aby użytkownik widział przybliżoną lokalizację
            createUserMarker(latitude, longitude);
            
            // Dodajemy klasę niskiej dokładności dla efektu pulsowania
            if (userLocationMarker && userLocationMarker.getElement()) {
              userLocationMarker.getElement().classList.add('low-accuracy');
            }
            
            // Większy okrąg dokładności
            updateAccuracyCircle([longitude, latitude], accuracy);
            
            // Zapisz pozycję (ale jej nie używaj do nawigacji)
            lastPosition = [longitude, latitude];
            lastPositionTimestamp = Date.now();
          } else if (userLocationMarker && userLocationMarker.getElement()) {
            // Jeśli już mamy marker, to tylko zaktualizujmy klasę
            userLocationMarker.getElement().classList.add('low-accuracy');
          }
          return;
        } else if (userLocationMarker && userLocationMarker.getElement()) {
          // Jeśli dokładność jest wystarczająca, usuń klasę low-accuracy
          userLocationMarker.getElement().classList.remove('low-accuracy');
        }

        const userLocation = [longitude, latitude];
        const currentTime = Date.now();

        // Utwórz lub aktualizuj marker lokalizacji
        if (!userLocationMarker) {
          createUserMarker(latitude, longitude);
        } else {
          // Ustaw lokalizację dla markera
          userLocationMarker.setLngLat(userLocation);
        }

        // Aktualizacja kierunku - rotate marker
        if (heading !== null && heading !== undefined) {
          // Obracamy strzałkę zgodnie z kierunkiem
          userHeading = heading;
          if (userLocationMarker && userLocationMarker.getElement()) {
            userLocationMarker.getElement().style.transform = `rotate(${heading}deg)`;
          }
        } else if (lastPosition && (currentTime - lastPositionTimestamp) > 200) {
          // Oblicz kierunek na podstawie przemieszczenia jeśli brak odczytu z kompasu
          if (calculateDistance(lastPosition[1], lastPosition[0], latitude, longitude) > 2) {
            const calculatedHeading = calculateHeading(
              lastPosition[1], lastPosition[0], 
              latitude, longitude
            );
            userHeading = calculatedHeading;
            
            // Obracamy strzałkę zgodnie z kierunkiem
            if (userLocationMarker && userLocationMarker.getElement()) {
              userLocationMarker.getElement().style.transform = `rotate(${calculatedHeading}deg)`;
            }
          }
        }

        // Zapisz aktualną pozycję
        lastPosition = [longitude, latitude];
        lastPositionTimestamp = currentTime;

        // Aktualizuj okrąg dokładności
        updateAccuracyCircle(userLocation, accuracy);

        // Aktualizuj obrót mapy aby strzałka pokazywała w górę - płynniejsze na telefonach
        if (isMapCentered && mapRotationEnabled && userHeading !== null) {
          // Używamy większej wartości duration dla płynniejszego obrotu
          const duration = userMovedMap ? 1000 : 500;
          map.easeTo({
            center: userLocation,
            bearing: userHeading,
            duration: duration,
            easing: (t) => t * (2 - t) // Funkcja easing dla płynniejszej rotacji
          });
          
          // Reset flagi ruchu użytkownika po wykonaniu animacji
          if (userMovedMap) {
            setTimeout(() => {
              userMovedMap = false;
            }, duration + 100);
          }
        }
        
        // Aktualizacja nawigacji głosowej, jeśli trasa jest aktywna
        if (currentRoute && currentRoute.guidance && currentRoute.guidance.instructions) {
          updateVoiceGuidance(userLocation);
          
          // Aktualizujemy również postęp trasy
          updateRouteProgress();
        }
        
        // Aktualizuj faktyczne ograniczenie prędkości na podstawie pozycji
        updateRealSpeedLimit(latitude, longitude);
      }
      
      // Funkcja tworząca marker użytkownika
      function createUserMarker(latitude, longitude) {
        // Tworzenie strzałki jako element DOM z SVG
          const el = document.createElement('div');
        el.className = 'user-direction-marker';
        
        // Zamiast używać obrazka, używamy SVG wbudowanego w kod z szerszą strzałką i zaokrąglonymi rogami
        el.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="100%" height="100%">
            <path d="M12 2C11.5 2 11 2.2 10.6 2.6L3 18C2.6 18.8 2.8 19.6 3.2 20.2C3.6 20.8 4.4 21 5 21H19C19.6 21 20.4 20.8 20.8 20.2C21.2 19.6 21.4 18.8 21 18L13.4 2.6C13 2.2 12.5 2 12 2Z" 
                  fill="#0066ff" stroke="#ffffff" stroke-width="1.5" stroke-linejoin="round"/>
          </svg>
        `;
        
        // Utwórz marker TomTom
        userLocationMarker = new tt.Marker({
            element: el,
          anchor: 'center',
          rotationAlignment: 'map'  // Zmiana z 'viewport' na 'map'
          })
          .setLngLat([longitude, latitude])
            .addTo(map);
          
        // Po pierwszym pobraniu lokalizacji, wycentruj mapę i obróć ją zgodnie z kierunkiem ruchu
        map.flyTo({
          center: [longitude, latitude],
          zoom: 18,
          duration: 1000,
          bearing: userHeading || 0
        });
        
        console.log("Utworzono marker użytkownika");
        isMapCentered = true;
        userMovedMap = false;
        
        // Ukryj komunikat o uruchamianiu lokalizacji
        messageBox.setAttribute('hidden', true);
        
        // Załaduj ulubione miejsca i rzeczywiste ograniczenia prędkości
        setTimeout(() => {
          if (favoriteLocations.length > 0) {
            updateFavoritesOnMap();
          }
          
          // Pobierz rzeczywiste ograniczenia prędkości
          updateRealSpeedLimit(latitude, longitude);
        }, 1000);
      }

      // Mapa jest w pełni załadowana
      map.on('load', function() {
        console.log("Mapa załadowana");
        
        // Dodanie niestandardowego markera do mapy
        map.loadImage('https://api.tomtom.com/maps-sdk-for-web/cdn/static/pictures/poi.png', function(error, image) {
          if (error) throw error;
          map.addImage('marker-custom', image);
        });
        
        // Włącz śledzenie lokalizacji
        startUserLocationTracking();
        
        // Po załadowaniu mapy, pobierz ulubione miejsca z localStorage
        if (favoriteLocations.length > 0) {
          // Odrocz, aby mapa się w pełni załadowała
          setTimeout(updateFavoritesOnMap, 1000);
        }
      });

      // Obsługa geolokalizacji
      function startUserLocationTracking() {
        if (!navigator.geolocation) {
          displayErrorMessage("Twoja przeglądarka nie obsługuje geolokalizacji.");
          return;
        }

        console.log("Uruchamiam śledzenie lokalizacji");

        // Obsługa zdarzenia zoom - ważna dla stabilności markerów
        map.on('zoom', handleZoom);
        map.on('move', handleMapMove);
        map.on('moveend', handleMapMoveEnd);

        // Opcje geolokalizacji z maksymalną dokładnością
        const options = {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 30000  // Zwiększamy timeout do 30 sekund
        };

        // Pokaż informację o uruchamianiu lokalizacji
        displayErrorMessage("Uruchamianie lokalizacji...");
        
        // Najpierw spróbujmy uzyskać jednorazową pozycję, aby szybciej ustawić mapę
        navigator.geolocation.getCurrentPosition(
          (position) => {
            console.log("Otrzymano początkową pozycję");
            // Aktualizuj mapę na podstawie początkowej pozycji
            updateUserLocation(position);
            
            // Rozpocznij ciągłe śledzenie
            startContinuousTracking(options);
          },
          (error) => {
            console.error("Błąd podczas uzyskiwania początkowej pozycji:", error);
            displayErrorMessage("Błąd podczas uzyskiwania pozycji: " + messages[error.code] || messages.default);
            // Mimo błędu, rozpocznij ciągłe śledzenie
            startContinuousTracking(options);
          },
          { ...options, timeout: 10000 } // Krótszy timeout dla pierwszej próby
        );
      }
      
      // Funkcja do ciągłego śledzenia lokalizacji
      function startContinuousTracking(options) {
        // Rozpocznij śledzenie lokalizacji
        try {
          if (userWatchId) {
            navigator.geolocation.clearWatch(userWatchId);
          }
          
          // Dodanie dodatkowych opcji dla urządzeń mobilnych
          const mobileOptions = {
            ...options,
            // Na urządzeniach mobilnych częściej aktualizujemy pozycję
            maximumAge: 0
          };
          
          userWatchId = navigator.geolocation.watchPosition(
            updateUserLocation,
            handleLocationError,
            mobileOptions
          );
          
          // Domyślnie włączamy obrót mapy - bardzo ważne na telefonie
          mapRotationEnabled = true;
          rotationToggle.checked = true;
          
          console.log("Rozpoczęto ciągłe śledzenie lokalizacji, ID:", userWatchId);
        } catch (e) {
          console.error("Błąd podczas uruchamiania geolokalizacji:", e);
          displayErrorMessage("Błąd podczas uruchamiania lokalizacji: " + e.message);
        }
      }

      // Aktualizacja widoczności przycisku centrowania
      function updateCenterButtonVisibility() {
        if (isMapCentered && !userMovedMap) {
          centerButton.classList.remove('visible');
        } else {
          centerButton.classList.add('visible');
        }
      }

      // Obsługa przycisku centrowania
      centerButton.addEventListener('click', function() {
        if (!userLocationMarker) {
          displayErrorMessage("Uruchamiam śledzenie lokalizacji...");
          startUserLocationTracking();
          return;
        }
        
        const userLocation = userLocationMarker.getLngLat();
        const bearing = mapRotationEnabled ? userHeading || 0 : 0;
        
        map.flyTo({
          center: userLocation,
          zoom: 18,
          bearing: bearing,
          duration: 1000,
          easing: (t) => t * (2 - t) // Funkcja easing dla płynniejszej animacji
        });
        
        isMapCentered = true;
        userMovedMap = false;
      });

      // Wyświetlanie komunikatu o błędzie
      function displayErrorMessage(message, durationMs = 5000) {
        if (!messageBox || !messageBoxContent) {
          console.error("Elementy UI nie zostały jeszcze zainicjalizowane");
          console.log("Komunikat:", message);
          // Spróbuj pobrać elementy jeszcze raz
          const msgBox = document.getElementById("messageBox");
          const msgContent = document.getElementById("messageBoxContent");
          
          if (msgBox && msgContent) {
            msgContent.textContent = message;
            msgBox.removeAttribute('hidden');
            return;
          }
          
          // Jeśli nadal nie ma elementów, utwórz tymczasowy komunikat
          let tempMsg = document.getElementById("tempMessage");
          if (!tempMsg) {
            tempMsg = document.createElement("div");
            tempMsg.id = "tempMessage";
            tempMsg.style.position = "absolute";
            tempMsg.style.top = "10px";
            tempMsg.style.left = "50%";
            tempMsg.style.transform = "translateX(-50%)";
            tempMsg.style.background = "white";
            tempMsg.style.padding = "10px";
            tempMsg.style.borderRadius = "5px";
            tempMsg.style.zIndex = "9999";
            document.body.appendChild(tempMsg);
          }
          tempMsg.textContent = message;
          return;
        }
        
        // Anuluj poprzedni timer ukrywania wiadomości, jeśli istnieje
        if (window.messageHideTimeout) {
          clearTimeout(window.messageHideTimeout);
          window.messageHideTimeout = null;
        }
        
        // Standardowe wyświetlanie
        messageBoxContent.textContent = message;
        messageBox.removeAttribute('hidden');
        
        // Dodaj klasę dla lepszej widoczności
        messageBox.style.opacity = "1";
        
        // Automatyczne ukrycie po określonym czasie
        if (durationMs > 0) {
          window.messageHideTimeout = setTimeout(() => {
            if (messageBox && !messageBox.getAttribute('hidden')) {
              // Płynne ukrycie
              messageBox.style.opacity = "0";
              setTimeout(() => {
                messageBox.setAttribute('hidden', true);
                messageBox.style.opacity = "1"; // Przywróć opacity dla następnego użycia
              }, 300);
            }
          }, durationMs);
        }
        
        // Dodanie obsługi kliknięcia przycisku zamknięcia
        if (messageBoxClose) {
          messageBoxClose.onclick = function() {
            messageBox.setAttribute('hidden', true);
            if (window.messageHideTimeout) {
              clearTimeout(window.messageHideTimeout);
              window.messageHideTimeout = null;
            }
          };
        }
      }

      // Obsługa ruchu mapy
      function handleMapMove(e) {
        if (e.originalEvent) {
          lastMapMoveTime = Date.now();
          userMovedMap = true;
          isMapCentered = false;
        }
      }
      
      // Dodaj trasę do mapy
      function addRouteToMap(route) {
        // Usuń poprzednią trasę jeśli istnieje
        if (map.getLayer('route')) {
          map.removeLayer('route');
        }
        
        if (map.getSource('route')) {
          map.removeSource('route');
        }
        
        // Dodaj nowe źródło i warstwę
        const routeGeoJson = {
          type: 'Feature',
          properties: {},
          geometry: {
            type: 'LineString',
            coordinates: route.legs[0].points.map(point => [point.longitude, point.latitude])
          }
        };
        
        map.addSource('route', {
          type: 'geojson',
          data: routeGeoJson
        });
        
        map.addLayer({
          id: 'route',
          type: 'line',
          source: 'route',
          layout: {
            'line-join': 'round',
            'line-cap': 'round'
          },
          paint: {
            'line-color': '#4CAF50',
            'line-width': 6,
            'line-opacity': 0.8
          }
        });
      }
      
      // Pokaż panel nawigacji
      function showNavigationPanel(route) {
        // Przygotuj treść panelu
        let content = '';
        
        if (route.guidance && route.guidance.instructions) {
          const nextInstruction = route.guidance.instructions[0];
          
          // Dodaj informacje o dystansie i czasie
          const totalDistance = Math.round(route.summary.lengthInMeters / 10) / 100; // w km
          const eta = new Date(Date.now() + route.summary.travelTimeInSeconds * 1000);
          const etaString = eta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          
          content += `
            <div style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee;">
              <div style="font-size: 14px; color: #666;">Dystans: ${totalDistance} km</div>
              <div style="font-size: 14px; color: #666;">Przyjazd: ${etaString}</div>
            </div>
          `;
          
          // Dodaj kolejny manewr
          if (nextInstruction) {
            // Określ odpowiednią ikonę dla manewru
            let iconClass = 'arrow-right';
            if (nextInstruction.message.toLowerCase().includes('skręć w lewo')) {
              iconClass = 'arrow-left';
            } else if (nextInstruction.message.toLowerCase().includes('skręć w prawo')) {
              iconClass = 'arrow-right';
            } else if (nextInstruction.message.toLowerCase().includes('prosto')) {
              iconClass = 'arrow-up';
            } else if (nextInstruction.message.toLowerCase().includes('zawróć')) {
              iconClass = 'arrow-down';
            } else if (nextInstruction.message.toLowerCase().includes('rondo')) {
              iconClass = 'undo';
            }
            
            content += `
              <div class="navigation-step">
                <div class="navigation-icon">
                  <i class="fas fa-${iconClass}"></i>
                </div>
                <div class="navigation-info">
                  ${nextInstruction.message}
                  <div class="navigation-distance">
                    <span id="next-maneuver-distance">---</span> m
                  </div>
                </div>
              </div>
            `;
            
            // Dodaj kolejny manewr jeśli istnieje
            if (route.guidance.instructions.length > 1) {
              const followingInstruction = route.guidance.instructions[1];
              
              // Określ ikonę dla następnego manewru
              let nextIconClass = 'arrow-right';
              if (followingInstruction.message.toLowerCase().includes('skręć w lewo')) {
                nextIconClass = 'arrow-left';
              } else if (followingInstruction.message.toLowerCase().includes('skręć w prawo')) {
                nextIconClass = 'arrow-right';
              } else if (followingInstruction.message.toLowerCase().includes('prosto')) {
                nextIconClass = 'arrow-up';
              } else if (followingInstruction.message.toLowerCase().includes('zawróć')) {
                nextIconClass = 'arrow-down';
              } else if (followingInstruction.message.toLowerCase().includes('rondo')) {
                nextIconClass = 'undo';
              }
              
              content += `
                <div class="navigation-step" style="opacity: 0.7;">
                  <div class="navigation-icon" style="background: #999;">
                    <i class="fas fa-${nextIconClass}"></i>
                  </div>
                  <div class="navigation-info">
                    ${followingInstruction.message}
                  </div>
                </div>
              `;
            }
          }
        }
        
        // Aktualizuj treść panelu
        navigationContent.innerHTML = content;
        
        // Pokaż panel
        navigationPanel.style.display = 'block';
        
        // Dodaj obsługę zamknięcia
        navigationClose.addEventListener('click', () => {
          // Zatrzymaj aktualizację trasy
          if (routeUpdateInterval) {
            clearInterval(routeUpdateInterval);
            routeUpdateInterval = null;
          }
          
          // Ukryj panel
          navigationPanel.style.display = 'none';
          
          // Usuń trasę z mapy
          if (map.getLayer('route')) {
            map.removeLayer('route');
          }
          
          if (map.getSource('route')) {
            map.removeSource('route');
          }
          
          // Zresetuj zmienne nawigacji
          currentRoute = null;
          currentStep = 0;
          
          // Powiedz użytkownikowi, że nawigacja została zakończona
          speakInstruction("Nawigacja zakończona");
        });
      }
      
      // Aktualizacja postępu trasy
      function updateRouteProgress() {
        if (!currentRoute || !userLocationMarker) {
          return;
        }
        
        const userLocation = userLocationMarker.getLngLat();
        
        // Jeśli mamy instrukcje nawigacji, sprawdź czy minęliśmy jakiś punkt
        if (currentRoute.guidance && currentRoute.guidance.instructions && currentRoute.guidance.instructions.length > currentStep) {
          const nextInstruction = currentRoute.guidance.instructions[currentStep];
          
          if (nextInstruction && nextInstruction.point) {
            // Oblicz odległość do kolejnego manewru
            const distanceToManeuver = calculateDistance(
              userLocation.lat, userLocation.lng,
              nextInstruction.point.latitude, nextInstruction.point.longitude
            );
            
            // Aktualizuj wyświetlaną odległość
            const distanceElement = document.getElementById('next-maneuver-distance');
            if (distanceElement) {
              distanceElement.textContent = Math.round(distanceToManeuver);
            }
            
            // Sprawdź czy minęliśmy już ten punkt manewru
            if (distanceToManeuver < 15) {
              // Manewr wykonany, przejdź do następnego
              currentStep++;
              
              // Jeśli nie ma więcej instrukcji, to znaczy że dojechaliśmy do celu
              if (currentStep >= currentRoute.guidance.instructions.length) {
                speakInstruction("Dotarłeś do celu");
                
                // Zatrzymaj aktualizację trasy
                if (routeUpdateInterval) {
                  clearInterval(routeUpdateInterval);
                  routeUpdateInterval = null;
                }
                
                // Ukryj panel po 5 sekundach
                setTimeout(() => {
                  navigationPanel.style.display = 'none';
                  
                  // Usuń trasę z mapy
                  if (map.getLayer('route')) {
                    map.removeLayer('route');
                  }
                  
                  if (map.getSource('route')) {
                    map.removeSource('route');
                  }
                  
                  // Zresetuj zmienne nawigacji
                  currentRoute = null;
                  currentStep = 0;
                }, 5000);
                
                return;
              }
              
              // Aktualizuj panel nawigacji z nową instrukcją
              showNavigationPanel(currentRoute);
              
              // Podaj nową instrukcję głosową
              const newInstruction = currentRoute.guidance.instructions[currentStep];
              speakInstruction(newInstruction.message);
            }
          }
        }
      }

      // // Funkcja wyboru miejsca docelowego i uruchomienia nawigacji
      // function selectDestination(destination) {
      //   if (!userLocationMarker) {
      //     displayErrorMessage("Najpierw włącz lokalizację GPS");
      //     return;
      //   }
        
      //   // Wyświetl komunikat o uruchamianiu nawigacji
      //   displayErrorMessage("Uruchamianie nawigacji...");
        
      //   // Pobierz aktualne współrzędne użytkownika
      //   const userLocation = userLocationMarker.getLngLat();
        
      //   // Usuń poprzednią trasę, jeśli istnieje
      //   if (currentRoute && map.getLayer('route')) {
      //     map.removeLayer('route');
      //   }
        
      //   if (map.getSource('route')) {
      //     map.removeSource('route');
      //   }
        
      //   // Ukryj popup jeśli są otwarte
      //   const popups = document.getElementsByClassName('mapboxgl-popup');
      //   while(popups[0]) {
      //     popups[0].remove();
      //   }
        
      //   // Dodaj marker docelowy
      //   let destinationMarker = new tt.Marker()
      //     .setLngLat([destination.lng, destination.lat])
      //     .addTo(map);
        
      //   // Wycentruj mapę tak aby pokazać obie lokalizacje
      //   const bounds = new tt.LngLatBounds();
      //   bounds.extend([userLocation.lng, userLocation.lat]);
      //   bounds.extend([destination.lng, destination.lat]);
        
      //   map.fitBounds(bounds, {
      //     padding: 100,
      //     duration: 1000
      //   });
        
      //   // Wywołanie API routingu TomTom
      //   const routingApi = 'https://api.tomtom.com/routing/1/calculateRoute/' + 
      //         userLocation.lat + ',' + userLocation.lng + ':' + 
      //         destination.lat + ',' + destination.lng + 
      //         '/json?key=' + apiKey + 
      //         '&instructionsType=text' +
      //         '&language=pl-PL' +
      //         '&traffic=true' +
      //         '&travelMode=car' +
      //         '&vehicleHeading=' + (userHeading || 0);
              
      //   // Pobierz trasę
      //   fetch(routingApi)
      //     .then(response => {
      //       if (!response.ok) {
      //         throw new Error('Nie można obliczyć trasy');
      //       }
      //       return response.json();
      //     })
      //     .then(data => {
      //       // Obsłuż odpowiedź
      //       if (data && data.routes && data.routes.length > 0) {
      //         // Zapisz trasę
      //         currentRoute = data.routes[0];
              
      //         // Dodaj trasę do mapy
      //         addRouteToMap(currentRoute);
              
      //         // Pokaż panel nawigacji
      //         showNavigationPanel(currentRoute);
              
      //         // Podaj pierwszą instrukcję głosową
      //         if (currentRoute.guidance && currentRoute.guidance.instructions && currentRoute.guidance.instructions.length > 0) {
      //           currentStep = 0;
      //           const firstInstruction = currentRoute.guidance.instructions[0];
      //           speakInstruction("Rozpoczęto nawigację. " + firstInstruction.message);
      //         }
              
      //         // Ustaw timer aktualizacji trasy
      //         if (routeUpdateInterval) {
      //           clearInterval(routeUpdateInterval);
      //         }
              
      //         routeUpdateInterval = setInterval(() => {
      //           updateRouteProgress();
      //         }, 5000);
              
      //         // Ukryj komunikat o uruchamianiu
      //         if (messageBox && !messageBox.getAttribute('hidden')) {
      //           messageBox.setAttribute('hidden', true);
      //         }
      //       } else {
      //         throw new Error('Brak dostępnych tras');
      //       }
      //     })
      //     .catch(error => {
      //       console.error('Błąd podczas obliczania trasy:', error);
      //       displayErrorMessage('Nie można obliczyć trasy: ' + error.message);
            
      //       // Usuń marker docelowy w przypadku błędu
      //       destinationMarker.remove();
      //     });
      // }

      function handleZoom() {
        // Aktualizujemy rozmiar okręgu dokładności
        if (userAccuracyCircle && userAccuracyCircle.getElement() && window.lastAccuracy) {
          const zoom = map.getZoom();
          const pixelSize = window.lastAccuracy / 0.075 / Math.pow(2, zoom);
          userAccuracyCircle.getElement().style.width = `${pixelSize}px`;
          userAccuracyCircle.getElement().style.height = `${pixelSize}px`;
        }
        
        // Po zakończeniu zoom, odśwież pozycję markera
        if (userLocationMarker && lastPosition) {
          userLocationMarker.setLngLat(lastPosition);
        }
      }
    </script>
  </body>
</html>

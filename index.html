<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <title>Żółwik Pro</title>
    <link
      rel="stylesheet"
      href="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.25.0/maps/maps.css"
    />
    <script src="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.25.0/maps/maps-web.min.js"></script>
    <script src="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.25.0/services/services-web.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    />
    <style>
      html,
      body,
      #map {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
      }

      .settings-btn {
        position: absolute;
        top: 10px;
        left: 10px;
        background: white;
        border: none;
        padding: 12px;
        font-size: 20px;
        cursor: pointer;
        border-radius: 50%;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .settings-panel {
        display: none;
        position: absolute;
        top: 70px;
        left: 10px;
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 200px;
      }

      .settings-panel label {
        display: flex;
        align-items: center;
        margin-bottom: 12px;
        cursor: pointer;
        font-size: 16px;
      }

      .settings-panel input[type="checkbox"] {
        margin-right: 10px;
        width: 18px;
        height: 18px;
      }

      .center-btn {
        position: fixed;
        bottom: 30px;
        right: 30px;
        background: #0066ff;
        color: white;
        border: none;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        font-size: 24px;
        cursor: pointer;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .center-btn:hover {
        background: #0055dd;
        transform: scale(1.05);
      }

      .message-box {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        padding: 12px 15px;
        border-radius: 8px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 3;
        display: flex;
        align-items: center;
        max-width: 90%;
        width: auto;
      }

      .message-box-content {
        flex-grow: 1;
        font-size: 16px;
      }

      .message-box-close {
        margin-left: 10px;
        cursor: pointer;
        font-size: 20px;
        padding: 0 5px;
      }

      /* Style dla mobilnego UI */
      @media (max-width: 768px) {
        .settings-btn,
        .search-btn,
        .center-btn,
        .favorites-btn,
        .layers-btn {
          width: 55px;
          height: 55px;
          font-size: 24px;
        }

        .settings-panel,
        .search-panel,
        .favorites-panel,
        .layers-panel {
          width: 80%;
          max-width: 300px;
          left: 50%;
          transform: translateX(-50%);
        }

        .navigation-panel {
          bottom: 30px;
          width: 90%;
        }

        .navigation-icon {
          width: 50px;
          height: 50px;
          font-size: 24px;
        }

        .navigation-info {
          font-size: 18px;
        }

        .navigation-distance,
        .navigation-eta {
          font-size: 16px;
        }

        .search-input {
          height: 50px;
          font-size: 18px;
        }

        .search-result-item {
          padding: 15px;
          font-size: 16px;
        }

        .message-box {
          padding: 15px;
          font-size: 18px;
        }
        
        .user-direction-marker {
          width: 40px;
          height: 40px;
        }
        
        .favorite-item, 
        .add-favorite {
          padding: 15px;
          font-size: 18px;
        }
      }

      /* Styl dla strzałki */
      .user-direction-marker {
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        transform-origin: center center;
      }

      /* Efekty dla SVG strzałki */
      .user-direction-marker svg {
        filter: drop-shadow(0px 2px 3px rgba(0, 0, 0, 0.4));
      }

      /* Animacja pulsowania dla strzałki */
      @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
      }

      /* Dodaj animację pulsowania gdy GPS jest niedokładny */
      .low-accuracy .user-direction-marker svg {
        animation: pulse 2s infinite ease-in-out;
      }

      /* Zwiększ rozmiar strzałki na telefonach dla lepszej widoczności */
      @media (max-width: 768px) {
        .user-direction-marker {
          width: 40px;
          height: 40px;
        }
      }

      .user-accuracy-circle {
        background-color: rgba(0, 122, 255, 0.1);
        border: 1px solid rgba(0, 122, 255, 0.3);
        border-radius: 50%;
      }

      /* Dodatkowe style dla małych ekranów */
      @media (max-width: 480px) {
        .settings-panel {
          width: 200px;
        }

        .message-box {
          width: 85%;
        }
      }

      /* Style dla wyszukiwarki */
      .search-btn {
        position: absolute;
        top: 10px;
        left: 60px;
        background: white;
        border: none;
        padding: 12px;
        font-size: 20px;
        cursor: pointer;
        border-radius: 50%;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .search-panel {
        display: none;
        position: absolute;
        top: 70px;
        left: 60px;
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 300px;
      }

      .search-input {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 16px;
        margin-bottom: 10px;
      }

      .search-results {
        max-height: 300px;
        overflow-y: auto;
      }

      .search-result-item {
        padding: 10px;
        cursor: pointer;
        border-bottom: 1px solid #eee;
      }

      .search-result-item:hover {
        background-color: #f5f5f5;
      }

      /* Style dla nawigacji */
      .navigation-panel {
        display: none;
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 90%;
        max-width: 400px;
      }

      .navigation-step {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }

      .navigation-icon {
        width: 40px;
        height: 40px;
        background: #4CAF50;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 10px;
        color: white;
        font-size: 20px;
      }

      .navigation-info {
        flex-grow: 1;
      }

      .navigation-distance {
        font-size: 14px;
        color: #666;
      }

      .navigation-eta {
        font-size: 14px;
        color: #666;
        margin-top: 5px;
      }

      .navigation-close {
        position: absolute;
        top: 10px;
        right: 10px;
        cursor: pointer;
        font-size: 20px;
      }

      @media (max-width: 768px) {
        .search-panel {
          width: calc(100% - 40px);
          right: 20px;
        }

        .navigation-panel {
          width: calc(100% - 40px);
        }
      }

      /* Style dla ulubionych miejsc */
      .favorites-btn {
        position: absolute;
        top: 10px;
        left: 110px;
        background: white;
        border: none;
        padding: 12px;
        font-size: 20px;
        cursor: pointer;
        border-radius: 50%;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .favorites-panel {
        display: none;
        position: absolute;
        top: 70px;
        left: 110px;
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 250px;
      }

      .favorites-list {
        max-height: 300px;
        overflow-y: auto;
      }

      .favorite-item {
        padding: 10px;
        margin-bottom: 5px;
        border-radius: 5px;
        background-color: #f5f5f5;
        cursor: pointer;
        position: relative;
      }

      .favorite-item:hover {
        background-color: #e5e5e5;
      }

      .favorite-item .delete-btn {
        position: absolute;
        right: 5px;
        top: 50%;
        transform: translateY(-50%);
        color: #ff0000;
        background: none;
        border: none;
        cursor: pointer;
        font-size: 16px;
      }

      .add-favorite {
        margin-top: 10px;
        padding: 8px 12px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        width: 100%;
      }

      /* Style dla legendy */
      .map-features-legend {
        position: absolute;
        bottom: 30px;
        right: 10px;
        background: white;
        padding: 10px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        max-width: 250px;
        display: none;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
      }

      .legend-color {
        width: 15px;
        height: 15px;
        border-radius: 50%;
        margin-right: 10px;
      }

      .legend-title {
        margin: 0 0 10px 0;
        font-weight: bold;
      }

      /* Style dla warstw */
      .layers-btn {
        position: absolute;
        top: 10px;
        left: 160px;
        background: white;
        border: none;
        padding: 12px;
        font-size: 20px;
        cursor: pointer;
        border-radius: 50%;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .layers-panel {
        display: none;
        position: absolute;
        top: 70px;
        left: 160px;
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 250px;
      }

      .layers-panel label {
        display: flex;
        align-items: center;
        margin-bottom: 12px;
        cursor: pointer;
        font-size: 16px;
      }

      .layers-panel input[type="checkbox"] {
        margin-right: 10px;
        width: 18px;
        height: 18px;
      }

      /* Style dla wskaźnika prędkości */
      .speed-container {
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        z-index: 1000;
      }

      .speed-indicator {
        background-color: #0066ff;
        color: white;
        border-radius: 25px;
        padding: 8px 15px;
        margin-right: 10px;
        font-family: Arial, sans-serif;
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        min-width: 80px;
      }

      .speed-limit {
        background-color: white;
        color: #333;
        border: 2px solid #ff0000;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: Arial, sans-serif;
        font-size: 18px;
        font-weight: bold;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      /* Styl dla wskaźnika na telefonie */
      @media (max-width: 768px) {
        .speed-container {
          bottom: 120px;
        }

        .speed-indicator {
          font-size: 28px;
          padding: 10px 20px;
        }

        .speed-limit {
          width: 60px;
          height: 60px;
          font-size: 22px;
        }
      }
    </style>
  </head>

  <body>
    <div id="map" class="map"></div>

    <!-- Przycisk wyszukiwania -->
    <button class="search-btn" id="searchBtn"><i class="fas fa-search"></i></button>

    <!-- Panel wyszukiwania -->
    <div class="search-panel" id="searchPanel">
      <input type="text" class="search-input" id="searchInput" placeholder="Wyszukaj miejsce...">
      <div class="search-results" id="searchResults"></div>
    </div>

    <!-- Panel nawigacji -->
    <div class="navigation-panel" id="navigationPanel">
      <span class="navigation-close" id="navigationClose">&times;</span>
      <div id="navigationContent"></div>
    </div>

    <!-- Przycisk ustawień -->
    <button class="settings-btn"><i class="fas fa-cog"></i></button>

    <!-- Panel ustawień -->
    <div class="settings-panel" id="settingsPanel">
      <label>
        <input type="checkbox" id="flow-toggle" />
        Pokaż ruch drogowy
      </label>
      <label>
        <input id="incidents-toggle" type="checkbox" />
        Pokaż incydenty drogowe
      </label>
      <label>
        <input id="rotation-toggle" type="checkbox" checked />
        Obracaj mapę zgodnie z kierunkiem
      </label>
      <label>
        <input id="buildings-toggle" type="checkbox" />
        Pokaż budynki 3D
      </label>
    </div>

    <!-- Przycisk centrowania -->
    <button class="center-btn" id="centerButton"><i class="fas fa-location-crosshairs"></i></button>

    <!-- Komunikat o błędzie -->
    <div class="message-box" id="messageBox" hidden>
      <div class="message-box-content" id="messageBoxContent"></div>
      <span class="message-box-close" id="messageBoxClose">&times;</span>
    </div>

    <!-- Wskaźnik prędkości -->
    <div class="speed-container" id="speedContainer">
      <div class="speed-indicator" id="speedIndicator">0 km/h</div>
      <div class="speed-limit" id="speedLimit">50</div>
    </div>
    
    <!-- Przycisk ulubionych miejsc -->
    <button class="favorites-btn" id="favoritesBtn"><i class="fas fa-heart"></i></button>

    <!-- Panel ulubionych miejsc -->
    <div class="favorites-panel" id="favoritesPanel">
      <div class="favorites-list" id="favoritesList"></div>
      <button class="add-favorite" id="addFavorite">Dodaj ulubione miejsce</button>
    </div>

    <!-- Przycisk warstw -->
    <button class="layers-btn" id="layersBtn"><i class="fas fa-layer-group"></i></button>

    <!-- Panel warstw -->
    <div class="layers-panel" id="layersPanel">
      <label>
        <input type="checkbox" id="speedcams-toggle" />
        Fotoradary i kontrole prędkości
      </label>
      <label>
        <input type="checkbox" id="roadworks-toggle" />
        Prace drogowe
      </label>
      <label>
        <input type="checkbox" id="poi-toggle" />
        Punkty zainteresowania (POI)
      </label>
      <label>
        <input type="checkbox" id="reports-toggle" />
        Zgłoszenia użytkowników
      </label>
    </div>

    <!-- Legenda -->
    <div class="map-features-legend" id="mapFeaturesLegend">
      <h4 class="legend-title">Legenda</h4>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ff0000;"></div>
        <span>Fotoradar</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ffa500;"></div>
        <span>Kontrola prędkości</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ffff00;"></div>
        <span>Prace drogowe</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ff9900;"></div>
        <span>Kamera drogowa</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #cc0000;"></div>
        <span>Miejsce wypadku</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #0000ff;"></div>
        <span>Ulubione miejsca</span>
      </div>
    </div>

    <script>
      const apiKey = "5sWFmhOgtZG9Aaj19W6LgDwQrwiCFTOG";

      const map = tt.map({
        key: apiKey,
        container: "map",
        center: [21.0122, 52.2297], // Warszawa - tymczasowy punkt startowy
        zoom: 14,
        // style: "tomtom://vector/1/basic-main",
        pitch: 0
      });

      map.addControl(new tt.NavigationControl());
      map.addControl(new tt.FullscreenControl());

      // Inicjalizacja - spróbuj natychmiast pobrać lokalizację
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          function(position) {
            // Otrzymano lokalizację - wycentruj mapę
            const { latitude, longitude } = position.coords;
            map.flyTo({
              center: [longitude, latitude],
              zoom: 16,
              duration: 1000
            });
            // Komunikat
            displayErrorMessage("Lokalizacja znaleziona! Inicjalizacja śledzenia...");
          },
          function(error) {
            // Błąd lokalizacji - pozostawiamy Warszawę
            console.warn("Nie można pobrać początkowej lokalizacji:", error);
            displayErrorMessage("Nie można pobrać Twojej lokalizacji. Wyświetlam domyślny widok.");
          },
          {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 0
          }
        );
      }
      
      // Wymuszenie widoczności przycisku centrowania od początku
      // centerButton.classList.add('visible');
      
      // Obsługa zdarzeń mapy
      map.on('movestart', function(e) {
        if (e.originalEvent) {
          console.log("Użytkownik rozpoczął przesuwanie mapy");
          userMovedMap = true;
          isMapCentered = false;
        }
      });

      // Elementy UI
      const settingsBtn = document.querySelector(".settings-btn");
      const settingsPanel = document.getElementById("settingsPanel");
      const trafficToggle = document.getElementById("flow-toggle");
      const incidentsCheckbox = document.getElementById("incidents-toggle");
      const rotationToggle = document.getElementById("rotation-toggle");
      const centerButton = document.getElementById("centerButton");
      const messageBox = document.getElementById("messageBox");
      const messageBoxContent = document.getElementById("messageBoxContent");
      const messageBoxClose = document.getElementById("messageBoxClose");
      const buildingsToggle = document.getElementById("buildings-toggle");
      const searchBtn = document.getElementById('searchBtn');
      const searchPanel = document.getElementById('searchPanel');
      const searchInput = document.getElementById('searchInput');
      const searchResults = document.getElementById('searchResults');
      const navigationPanel = document.getElementById('navigationPanel');
      const navigationContent = document.getElementById('navigationContent');
      const navigationClose = document.getElementById('navigationClose');
      const favoritesBtn = document.getElementById('favoritesBtn');
      const favoritesPanel = document.getElementById('favoritesPanel');
      const favoritesList = document.getElementById('favoritesList');
      const addFavorite = document.getElementById('addFavorite');
      const layersBtn = document.getElementById('layersBtn');
      const layersPanel = document.getElementById('layersPanel');
      const speedIndicator = document.getElementById('speedIndicator');
      const speedLimit = document.getElementById('speedLimit');
      const speedContainer = document.getElementById('speedContainer');

      // Komunikaty błędów
      const messages = {
        permissionDenied: "Dostęp do lokalizacji został zablokowany. Zmień ustawienia przeglądarki, aby umożliwić geolokalizację.",
        notAvailable: "Nie można określić Twojej lokalizacji. Upewnij się, że usługi lokalizacji są włączone.",
        timeout: "Przekroczono czas oczekiwania na lokalizację. Spróbuj ponownie.",
        default: "Wystąpił błąd podczas określania lokalizacji. Spróbuj odświeżyć stronę."
      };

      // Zmienne stanu
      let trafficIncidentsLayer = null;
      let userLocationMarker = null;
      let userAccuracyCircle = null;
      let userWatchId = null;
      let userHeading = 0;
      let lastPosition = null;
      let lastPositionTimestamp = 0;
      let headingTimeout = null;
      let mapRotationEnabled = true;
      let autoCenteringEnabled = true;
      let isMapCentered = true;
      let lastMapMoveTime = 0;
      let userMovedMap = false;
      let buildings3DEnabled = false;
      
      // Zmienne dla płynnego ruchu
      let animationFrameId = null;
      let targetPosition = null;
      let currentAnimatedPosition = null;
      let lastHeadingUpdateTime = 0;
      let headingChangeRate = 0;
      let lastUpdateTime = 0;

      // Zmienne dla nawigacji
      let currentRoute = null;
      let currentStep = 0;
      let routeUpdateInterval = null;

      // Zmienne dla nawigacji głosowej
      let speechSynthesis = window.speechSynthesis;
      let lastVoiceInstruction = "";
      let lastVoiceTime = 0;
      let voiceEnabled = true;
      let nextManeuverDistance = 0;
      let upcomingManeuver = "";
      
      // Zmienne dla warstw mapy
      let speedcamsLayer = null;
      let roadworksLayer = null;
      let poiLayer = null;
      let favoritesLayer = null;
      let reportsLayer = null;
      
      // Zmienne dla audio
      let originalVolumeOfBackgroundAudio = [];
      let backgroundAudioElements = [];
      let isAudioLowered = false;
      
      // Zmienne dla prędkości
      let currentSpeed = 0;
      let currentSpeedLimit = 50;  // Domyślne ograniczenie prędkości
      let lastSpeedUpdate = 0;
      
      // Ulubione miejsca
      let favoriteLocations = JSON.parse(localStorage.getItem('favoriteLocations') || '[]');

      // Obsługa ruchu drogowego
      trafficToggle.addEventListener("change", () => {
        if (trafficToggle.checked) {
          map.showTrafficFlow();
        } else {
          map.hideTrafficFlow();
        }
      });

      // Obsługa budynków 3D
      buildingsToggle.addEventListener("change", () => {
        if (buildingsToggle.checked) {
          if (!buildings3DEnabled) {
            map.set3DBuildings(true);
            buildings3DEnabled = true;
            
            // Ustaw odpowiedni pitch dla lepszego widoku 3D
            map.easeTo({
              pitch: 45,
              duration: 1000
            });
          }
        } else if (buildings3DEnabled) {
          map.set3DBuildings(false);
          buildings3DEnabled = false;
          
          // Przywróć płaski widok
          map.easeTo({
            pitch: 0,
            duration: 1000
          });
        }
      });

      // Obsługa panelu ustawień
      settingsBtn.addEventListener("click", () => {
        settingsPanel.style.display =
          settingsPanel.style.display === "block" ? "none" : "block";
      });

      // Obsługa przełącznika rotacji
      rotationToggle.addEventListener("change", () => {
        mapRotationEnabled = rotationToggle.checked;
        
        // Jeśli wyłączono rotację, zresetuj orientację mapy
        if (!mapRotationEnabled && isMapCentered) {
          map.easeTo({
            bearing: 0,
            pitch: 0,
            duration: 500
          });
        } else if (mapRotationEnabled && isMapCentered && userHeading !== null) {
          // Włączono rotację i znamy kierunek - obróć mapę
          map.easeTo({
            bearing: userHeading,
            duration: 500
          });
        }
      });

      // Obsługa incydentów drogowych
      incidentsCheckbox.addEventListener("change", () => {
        if (incidentsCheckbox.checked) {
          if (!trafficIncidentsLayer) {
            // Tworzenie warstwy incydentów drogowych
            trafficIncidentsLayer = new tt.VectorTileLayer({
              key: apiKey,
              style: "tomtom://vector/incident",
              refresh: 30000, // Odświeżanie co 30 sekund
              minZoom: 5,
              maxZoom: 19,
              language: 'pl-PL'
            });

            // Dodaj warstwę do mapy
            map.addLayer(trafficIncidentsLayer);

            // Dodaj obsługę kliknięcia w incydent
            map.on('click', 'incidents', (e) => {
              if (e.features.length > 0) {
                const incident = e.features[0].properties;
                const coordinates = e.features[0].geometry.coordinates.slice();
                const description = incident.description || 'Brak opisu';
                const type = incident.type || 'Nieznany typ';
                const severity = incident.severity || 'Nieznana ważność';

                // Utwórz popup z informacjami o incydencie
                new tt.Popup()
                  .setLngLat(coordinates)
                  .setHTML(`
                    <div style="padding: 10px;">
                      <h3 style="margin: 0 0 5px 0;">${type}</h3>
                      <p style="margin: 0 0 5px 0;"><strong>Opis:</strong> ${description}</p>
                      <p style="margin: 0;"><strong>Ważność:</strong> ${severity}</p>
                    </div>
                  `)
                  .addTo(map);
              }
            });

            // Zmień kursor przy najechaniu na incydent
            map.on('mouseenter', 'incidents', () => {
              map.getCanvas().style.cursor = 'pointer';
            });

            map.on('mouseleave', 'incidents', () => {
              map.getCanvas().style.cursor = '';
            });

            // Dodaj legendę incydentów
            const legend = document.createElement('div');
            legend.id = 'incidents-legend';
            legend.style.display = 'none';
            legend.style.position = 'absolute';
            legend.style.bottom = '30px';
            legend.style.left = '10px';
            legend.style.backgroundColor = 'white';
            legend.style.padding = '10px';
            legend.style.borderRadius = '4px';
            legend.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
            legend.style.zIndex = '1';
            legend.innerHTML = `
              <h4 style="margin: 0 0 10px 0;">Legenda incydentów</h4>
              <div style="display: grid; grid-template-columns: auto 1fr; gap: 5px; align-items: center;">
                <span style="display: inline-block; width: 10px; height: 10px; background: #ff0000; border-radius: 50%;"></span>
                <span>Wypadek</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ffa500; border-radius: 50%;"></span>
                <span>Zatłoczenie</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ffff00; border-radius: 50%;"></span>
                <span>Roboty drogowe</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ff00ff; border-radius: 50%;"></span>
                <span>Uszkodzony pojazd</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #00ffff; border-radius: 50%;"></span>
                <span>Zamknięty pas</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #000000; border-radius: 50%;"></span>
                <span>Zamknięta droga</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ff4500; border-radius: 50%;"></span>
                <span>Zagrożenie na drodze</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #800080; border-radius: 50%;"></span>
                <span>Wydarzenie planowane</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #4169e1; border-radius: 50%;"></span>
                <span>Zła pogoda</span>
              </div>
            `;
            document.body.appendChild(legend);

            // Pokaż/ukryj legendę przy zmianie stanu checkboxa
            incidentsCheckbox.addEventListener('change', () => {
              legend.style.display = incidentsCheckbox.checked ? 'block' : 'none';
            });
          }
        } else if (trafficIncidentsLayer) {
          map.removeLayer(trafficIncidentsLayer);
          trafficIncidentsLayer = null;
          
          // Ukryj legendę
          const legend = document.getElementById('incidents-legend');
          if (legend) {
            legend.style.display = 'none';
          }
        }
      });

      // Obsługa wyszukiwania
      searchBtn.addEventListener('click', () => {
        searchPanel.style.display = searchPanel.style.display === 'block' ? 'none' : 'block';
        if (searchPanel.style.display === 'block') {
          searchInput.focus();
        }
      });

      // Autocomplete dla wyszukiwania
      let searchTimeout;
      searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value;
        
        if (query.length < 3) {
          searchResults.innerHTML = '';
          return;
        }

        searchTimeout = setTimeout(() => {
          tt.services.fuzzySearch({
            key: apiKey,
            query: query,
            language: 'pl-PL',
            limit: 5
          })
          .then(response => {
            searchResults.innerHTML = '';
            response.results.forEach(result => {
              const div = document.createElement('div');
              div.className = 'search-result-item';
              div.textContent = result.address.freeformAddress;
              div.addEventListener('click', () => {
                selectDestination(result.position);
                searchPanel.style.display = 'none';
              });
              searchResults.appendChild(div);
            });
          })
          .catch(error => {
            console.error('Błąd wyszukiwania:', error);
          });
        }, 300);
      });

      // Obsługa warstw
      layersBtn.addEventListener('click', () => {
        layersPanel.style.display = layersPanel.style.display === 'block' ? 'none' : 'block';
      });

      // Obsługa fotoradarów i kontroli prędkości
      document.getElementById('speedcams-toggle').addEventListener('change', (e) => {
        if (e.target.checked) {
          loadSpeedCameras();
          document.getElementById('mapFeaturesLegend').style.display = 'block';
        } else {
          if (speedcamsLayer) {
            map.removeLayer('speedcams');
            map.removeSource('speedcams');
            speedcamsLayer = null;
          }
          updateLegendVisibility();
        }
      });

      // Obsługa prac drogowych
      document.getElementById('roadworks-toggle').addEventListener('change', (e) => {
        if (e.target.checked) {
          loadRoadworks();
          document.getElementById('mapFeaturesLegend').style.display = 'block';
        } else {
          if (roadworksLayer) {
            map.removeLayer('roadworks');
            map.removeSource('roadworks');
            roadworksLayer = null;
          }
          updateLegendVisibility();
        }
      });

      // Obsługa POI
      document.getElementById('poi-toggle').addEventListener('change', (e) => {
        if (e.target.checked) {
          loadPointsOfInterest();
        } else {
          if (poiLayer) {
            map.removeLayer('pois');
            map.removeSource('pois');
            poiLayer = null;
          }
        }
      });

      // Obsługa zgłoszeń użytkowników
      document.getElementById('reports-toggle').addEventListener('change', (e) => {
        if (e.target.checked) {
          if (lastPosition) {
            loadReportsFromOverpass(lastPosition[1], lastPosition[0]);
          } else {
          displayErrorMessage('Najpierw włącz lokalizację GPS');
            e.target.checked = false;
          }
        } else {
          if (reportsLayer) {
            map.removeLayer('reports');
            map.removeSource('reports');
            reportsLayer = null;
          }
        }
      });

      // Ładowanie zgłoszeń z Overpass API
      function loadReportsFromOverpass(lat, lng) {
        // Pokaż informację o ładowaniu
        displayErrorMessage('Ładowanie zgłoszeń z Overpass API...');
        
        // Promień wyszukiwania w metrach
        const radius = 10000; // 10km
        
        // Budowanie zapytania Overpass
        const query = `
          [out:json][timeout:25];
          (
            // Fotoradary
            node["highway"="speed_camera"](around:${radius},${lat},${lng});
            // Kamery drogowe
            node["highway"="traffic_signals"]["camera"](around:${radius},${lat},${lng});
            // Prace drogowe
            way["highway"]["construction"](around:${radius},${lat},${lng});
            // Miejsca częstej kontroli prędkości
            node["highway"]["traffic_calming"](around:${radius},${lat},${lng});
            // Miejsca wypadków
            node["hazard"="accident"](around:${radius},${lat},${lng});
          );
          out body;
          >;
          out skel qt;
        `;
        
        // Teraz faktycznie używamy API Overpass zamiast symulowanych danych
        const overpassUrl = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;
        
        fetch(overpassUrl)
          .then(response => {
            if (!response.ok) {
              throw new Error('Błąd pobierania danych z API Overpass');
            }
            return response.json();
          })
          .then(data => {
            processOverpassResults(data);
          })
          .catch(error => {
            console.error('Błąd zapytania Overpass:', error);
            displayErrorMessage('Nie udało się pobrać zgłoszeń. Używam danych lokalnych.');
            
            // Fallback na dane offline jeśli API nie odpowiada
            const simulatedResults = {
              elements: [
                { 
                  id: 1, 
                  type: "node", 
                  lat: lat + 0.002, 
                  lon: lng + 0.003, 
                  tags: { 
                    highway: "speed_camera", 
                    name: "Fotoradar stacjonarny", 
                    description: "Kontrola prędkości na prostym odcinku" 
                  } 
                },
                { 
                  id: 2, 
                  type: "node", 
                  lat: lat - 0.001, 
                  lon: lng + 0.002, 
                  tags: { 
                    highway: "traffic_signals", 
                    camera: "yes", 
                    name: "Kamera na skrzyżowaniu", 
                    description: "Monitoring przejazdu na czerwonym świetle" 
                  } 
                },
                { 
                  id: 3, 
                  type: "node", 
                  lat: lat + 0.003, 
                  lon: lng - 0.002, 
                  tags: { 
                    highway: "traffic_calming", 
                    name: "Częste kontrole prędkości", 
                    description: "Miejsce regularnych kontroli policyjnych" 
                  } 
                },
                { 
                  id: 4, 
                  type: "node", 
                  lat: lat - 0.002, 
                  lon: lng - 0.001, 
                  tags: { 
                    hazard: "accident", 
                    name: "Miejsce wypadku", 
                    description: "Niebezpieczne skrzyżowanie, częste kolizje" 
                  } 
                }
              ]
            };
            processOverpassResults(simulatedResults);
          });
      }
      
      // Przetwarzanie wyników z Overpass API
      function processOverpassResults(data) {
        if (!data || !data.elements || data.elements.length === 0) {
          displayErrorMessage('Brak zgłoszeń w okolicy');
          return;
        }
        
        // Ukryj komunikat o ładowaniu
        if (messageBox && !messageBox.getAttribute('hidden')) {
          messageBox.setAttribute('hidden', true);
        }
        
        // Przygotuj features dla GeoJSON
        const features = data.elements.map(element => {
          // Sprawdź czy element ma współrzędne
          if (!element.lat || !element.lon) return null;
          
          // Określ typ zgłoszenia i ikonę
          let type = 'unknown';
          let icon = 'marker-15';
          let color = '#ff0000';
          let description = 'Brak opisu';
          
          if (element.tags) {
            if (element.tags.highway === 'speed_camera') {
              type = 'speed_camera';
              icon = 'camera-15';
              color = '#ff0000';
              description = element.tags.description || 'Fotoradar';
            } else if (element.tags.camera === 'yes') {
              type = 'traffic_camera';
              icon = 'camera-15';
              color = '#ff9900';
              description = element.tags.description || 'Kamera drogowa';
            } else if (element.tags.construction) {
              type = 'roadworks';
              icon = 'roadblock-15';
              color = '#ffcc00';
              description = element.tags.description || 'Prace drogowe';
            } else if (element.tags.traffic_calming) {
              type = 'speed_control';
              icon = 'police-15';
              color = '#ffa500';
              description = element.tags.description || 'Kontrola prędkości';
            } else if (element.tags.hazard === 'accident') {
              type = 'accident';
              icon = 'danger-15';
              color = '#cc0000';
              description = element.tags.description || 'Miejsce wypadku';
            }
          }
          
          // Utwórz feature GeoJSON
          return {
              type: 'Feature',
            properties: {
              id: element.id,
              type: type,
              name: element.tags?.name || 'Zgłoszenie',
              description: description,
              color: color
            },
              geometry: {
              type: 'Point',
              coordinates: [element.lon, element.lat]
            }
          };
        }).filter(feature => feature !== null);
        
        // Usuń istniejącą warstwę jeśli istnieje
        if (map.getLayer('reports')) {
          map.removeLayer('reports');
        }
        
        if (map.getSource('reports')) {
          map.removeSource('reports');
        }
        
        // Dodaj źródło danych
        map.addSource('reports', {
                type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features: features
          }
              });

        // Dodaj warstwę
              map.addLayer({
          id: 'reports',
          type: 'symbol',
          source: 'reports',
                layout: {
            'icon-image': [
              'match',
              ['get', 'type'],
              'speed_camera', 'camera-15',
              'traffic_camera', 'camera-15',
              'roadworks', 'roadblock-15',
              'speed_control', 'police-15',
              'accident', 'danger-15',
              'marker-15'
            ],
            'icon-size': 1.2,
            'icon-allow-overlap': true,
            'text-field': ['get', 'name'],
            'text-font': ['Arial Unicode MS Bold'],
            'text-offset': [0, 1],
            'text-anchor': 'top'
                },
                paint: {
            'text-color': ['get', 'color'],
            'text-halo-color': '#ffffff',
            'text-halo-width': 1
          }
        });
        
        // Dodaj obsługę kliknięcia
        map.on('click', 'reports', (e) => {
          const properties = e.features[0].properties;
          const coordinates = e.features[0].geometry.coordinates.slice();
          
          // Utwórz popup
          new tt.Popup()
            .setLngLat(coordinates)
            .setHTML(`
              <div style="padding: 10px;">
                <h3 style="margin: 0 0 5px 0;">${properties.name}</h3>
                <p style="margin: 0;">${properties.description}</p>
              </div>
            `)
            .addTo(map);
        });
        
        // Zmień kursor przy najeździe
        map.on('mouseenter', 'reports', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        
        map.on('mouseleave', 'reports', () => {
          map.getCanvas().style.cursor = '';
        });
        
        reportsLayer = true;
        
        // Aktualizuj legendę
        document.getElementById('mapFeaturesLegend').style.display = 'block';
      }

      // Funkcja aktualizująca widoczność legendy
      function updateLegendVisibility() {
        const shouldShowLegend = document.getElementById('speedcams-toggle').checked || 
                                document.getElementById('roadworks-toggle').checked ||
                                document.getElementById('reports-toggle').checked;
        document.getElementById('mapFeaturesLegend').style.display = shouldShowLegend ? 'block' : 'none';
      }

      // Obsługa ulubionych miejsc
      favoritesBtn.addEventListener('click', () => {
        favoritesPanel.style.display = favoritesPanel.style.display === 'block' ? 'none' : 'block';
        if (favoritesPanel.style.display === 'block') {
          renderFavorites();
        }
      });

      // Dodanie ulubionego miejsca
      addFavorite.addEventListener('click', () => {
        if (!userLocationMarker) {
          displayErrorMessage('Najpierw włącz lokalizację GPS');
          return;
        }

        const position = userLocationMarker.getLngLat();
        const name = prompt('Nazwa ulubionego miejsca:');
        
        if (!name) return;
        
        const favorite = {
          id: Date.now().toString(),
          name,
          position: {
            lat: position.lat,
            lng: position.lng
          }
        };
        
        favoriteLocations.push(favorite);
        localStorage.setItem('favoriteLocations', JSON.stringify(favoriteLocations));
        
        renderFavorites();
        updateFavoritesOnMap();
      });

      // Renderowanie listy ulubionych miejsc
      function renderFavorites() {
        favoritesList.innerHTML = '';
        
        if (favoriteLocations.length === 0) {
          favoritesList.innerHTML = '<div style="padding: 10px;">Brak ulubionych miejsc</div>';
          return;
        }
        
        favoriteLocations.forEach(favorite => {
          const item = document.createElement('div');
          item.className = 'favorite-item';
          item.textContent = favorite.name;
          
          // Przycisk usuwania
          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'delete-btn';
          deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
          deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removeFavorite(favorite.id);
          });
          
          item.appendChild(deleteBtn);
          
          // Wybór ulubionego miejsca
          item.addEventListener('click', () => {
            selectDestination(favorite.position);
            favoritesPanel.style.display = 'none';
          });
          
          favoritesList.appendChild(item);
        });
      }

      // Usuwanie ulubionego miejsca
      function removeFavorite(id) {
        favoriteLocations = favoriteLocations.filter(fav => fav.id !== id);
        localStorage.setItem('favoriteLocations', JSON.stringify(favoriteLocations));
        renderFavorites();
        updateFavoritesOnMap();
      }

      // Aktualizacja ulubionych miejsc na mapie
      function updateFavoritesOnMap() {
        // Usuń istniejącą warstwę
        if (map.getLayer('favorites')) {
          map.removeLayer('favorites');
        }
        
        if (map.getSource('favorites')) {
          map.removeSource('favorites');
        }
        
        // Stwórz źródło danych GeoJSON
        const features = favoriteLocations.map(favorite => ({
          type: 'Feature',
          properties: {
            name: favorite.name,
            id: favorite.id
          },
          geometry: {
            type: 'Point',
            coordinates: [favorite.position.lng, favorite.position.lat]
          }
        }));
        
        // Dodaj źródło danych
        map.addSource('favorites', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features
          }
        });
        
        // Dodaj warstwę
        map.addLayer({
          id: 'favorites',
          type: 'symbol',
          source: 'favorites',
          layout: {
            'icon-image': 'marker-15',
            'icon-size': 1.5,
            'text-field': ['get', 'name'],
            'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
            'text-offset': [0, 1.5],
            'text-anchor': 'top'
          },
          paint: {
            'text-color': '#0000ff',
            'text-halo-color': '#ffffff',
            'text-halo-width': 1
          }
        });
        
        // Dodaj obsługę kliknięcia
        map.on('click', 'favorites', (e) => {
          const properties = e.features[0].properties;
          const coordinates = e.features[0].geometry.coordinates.slice();
          
          // Utwórz popup
          new tt.Popup()
            .setLngLat(coordinates)
            .setHTML(`
              <div style="padding: 10px;">
                <h3 style="margin: 0 0 10px 0;">${properties.name}</h3>
                <button id="navigate-favorite" style="padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Nawiguj</button>
              </div>
            `)
            .addTo(map);
            
          // Obsługa przycisku w popup
                  setTimeout(() => {
            document.getElementById('navigate-favorite').addEventListener('click', () => {
              const favorite = favoriteLocations.find(f => f.id === properties.id);
              if (favorite) {
                selectDestination(favorite.position);
              }
            });
          }, 100);
        });
        
        // Zmień kursor przy najeździe na ulubione miejsce
        map.on('mouseenter', 'favorites', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        
        map.on('mouseleave', 'favorites', () => {
          map.getCanvas().style.cursor = '';
        });
      }

      // Ładowanie fotoradarów i kontroli prędkości
      function loadSpeedCameras() {
        // Symulacja danych - w rzeczywistej aplikacji użylibyśmy API
        const speedCameras = [
          // Przykładowe dane - w rzeczywistej aplikacji pobralibyśmy te informacje z API
          { type: "speed_camera", lat: 52.2297, lng: 21.0122, description: "Fotoradar stacjonarny" },
          { type: "speed_control", lat: 52.2350, lng: 21.0091, description: "Częsta kontrola prędkości" }
        ];
        
        // Przygotowanie źródła danych GeoJSON
        const features = speedCameras.map(camera => ({
          type: 'Feature',
          properties: {
            type: camera.type,
            description: camera.description
          },
          geometry: {
            type: 'Point',
            coordinates: [camera.lng, camera.lat]
          }
        }));
        
        // Dodaj źródło danych
        map.addSource('speedcams', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features
          }
        });
        
        // Dodaj warstwę
        map.addLayer({
          id: 'speedcams',
          type: 'symbol',
          source: 'speedcams',
          layout: {
            'icon-image': 'marker-15',
            'icon-size': 1.2,
            'icon-allow-overlap': true
          },
          paint: {
            'icon-color': [
              'match',
              ['get', 'type'],
              'speed_camera', '#ff0000',
              'speed_control', '#ffa500',
              '#ff0000'
            ]
          }
        });
        
        // Dodaj obsługę kliknięcia
        map.on('click', 'speedcams', (e) => {
          const properties = e.features[0].properties;
          const coordinates = e.features[0].geometry.coordinates.slice();
          
          // Utwórz popup
          new tt.Popup()
            .setLngLat(coordinates)
            .setHTML(`
              <div style="padding: 10px;">
                <h3 style="margin: 0 0 5px 0;">${properties.type === 'speed_camera' ? 'Fotoradar' : 'Kontrola prędkości'}</h3>
                <p style="margin: 0;">${properties.description}</p>
              </div>
            `)
            .addTo(map);
        });
        
        // Zmień kursor przy najeździe
        map.on('mouseenter', 'speedcams', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        
        map.on('mouseleave', 'speedcams', () => {
          map.getCanvas().style.cursor = '';
        });
        
        speedcamsLayer = true;
      }

      // Ładowanie prac drogowych
      function loadRoadworks() {
        // W rzeczywistej aplikacji użylibyśmy API Overpass
        // Symulacja danych
        const roadworks = [
          // Przykładowe dane
          { lat: 52.2340, lng: 21.0180, description: "Przebudowa drogi, zwężenie do jednego pasa", endDate: "2023-12-31" },
          { lat: 52.2280, lng: 21.0050, description: "Remont chodnika", endDate: "2023-11-15" }
        ];
        
        // Przygotowanie źródła danych GeoJSON
        const features = roadworks.map(work => ({
          type: 'Feature',
          properties: {
            description: work.description,
            endDate: work.endDate
          },
          geometry: {
            type: 'Point',
            coordinates: [work.lng, work.lat]
          }
        }));
        
        // Dodaj źródło danych
        map.addSource('roadworks', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features
          }
        });
        
        // Dodaj warstwę
        map.addLayer({
          id: 'roadworks',
          type: 'symbol',
          source: 'roadworks',
          layout: {
            'icon-image': 'marker-15',
            'icon-size': 1.2,
            'icon-allow-overlap': true
          },
          paint: {
            'icon-color': '#ffff00'
          }
        });
        
        // Dodaj obsługę kliknięcia
        map.on('click', 'roadworks', (e) => {
          const properties = e.features[0].properties;
          const coordinates = e.features[0].geometry.coordinates.slice();
          
          // Utwórz popup
          new tt.Popup()
            .setLngLat(coordinates)
            .setHTML(`
              <div style="padding: 10px;">
                <h3 style="margin: 0 0 5px 0;">Prace drogowe</h3>
                <p style="margin: 0 0 5px 0;">${properties.description}</p>
                <p style="margin: 0;"><strong>Planowany koniec:</strong> ${properties.endDate}</p>
              </div>
            `)
            .addTo(map);
        });
        
        // Zmień kursor przy najeździe
        map.on('mouseenter', 'roadworks', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        
        map.on('mouseleave', 'roadworks', () => {
          map.getCanvas().style.cursor = '';
        });
        
        roadworksLayer = true;
      }

      // Ładowanie punktów zainteresowania (POI)
      function loadPointsOfInterest() {
        // W rzeczywistej aplikacji użylibyśmy Overpass API
        // Przykładowy kod zapytania Overpass:
        // const query = `
        //   [out:json];
        //   (
        //     node["amenity"](around:1000,${lat},${lng});
        //     node["shop"](around:1000,${lat},${lng});
        //   );
        //   out;
        // `;
        
        // Symulacja danych
        const pois = [
          { lat: 52.2320, lng: 21.0100, name: "Restauracja Pod Jabłonią", type: "restaurant" },
          { lat: 52.2300, lng: 21.0150, name: "Stacja paliw BP", type: "fuel" },
          { lat: 52.2270, lng: 21.0080, name: "Sklep spożywczy", type: "shop" }
        ];
        
        // Przygotowanie źródła danych GeoJSON
        const features = pois.map(poi => ({
          type: 'Feature',
          properties: {
            name: poi.name,
            type: poi.type
          },
          geometry: {
            type: 'Point',
            coordinates: [poi.lng, poi.lat]
          }
        }));
        
        // Dodaj źródło danych
        map.addSource('pois', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features
          }
        });
        
        // Dodaj warstwę
        map.addLayer({
          id: 'pois',
          type: 'symbol',
          source: 'pois',
          layout: {
            'icon-image': 'marker-15',
            'icon-size': 1,
            'text-field': ['get', 'name'],
            'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
            'text-offset': [0, 1.5],
            'text-anchor': 'top'
          },
          paint: {
            'text-color': '#333333',
            'text-halo-color': '#ffffff',
            'text-halo-width': 1
          }
        });
        
        // Dodaj obsługę kliknięcia
        map.on('click', 'pois', (e) => {
          const properties = e.features[0].properties;
          const coordinates = e.features[0].geometry.coordinates.slice();
          
          // Utwórz popup
          new tt.Popup()
            .setLngLat(coordinates)
            .setHTML(`
              <div style="padding: 10px;">
                <h3 style="margin: 0 0 5px 0;">${properties.name}</h3>
                <p style="margin: 0 0 5px 0;">Typ: ${properties.type}</p>
                <button id="navigate-poi" style="padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Nawiguj</button>
              </div>
            `)
            .addTo(map);
            
          // Obsługa przycisku w popup
          setTimeout(() => {
            document.getElementById('navigate-poi').addEventListener('click', () => {
              selectDestination({lat: coordinates[1], lng: coordinates[0]});
            });
          }, 100);
        });
        
        // Zmień kursor przy najeździe
        map.on('mouseenter', 'pois', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        
        map.on('mouseleave', 'pois', () => {
          map.getCanvas().style.cursor = '';
        });
        
        poiLayer = true;
      }

      // Wyciszanie dźwięków w tle podczas nawigacji głosowej
      function lowerBackgroundAudio() {
        // Jeśli już wyciszone, nie rób nic
        if (isAudioLowered) return;
        
        console.log("Wyciszanie dźwięków w tle...");
        
        // Zbierz wszystkie elementy audio i video na stronie
        const mediaElements = [
          ...document.querySelectorAll('audio:not([data-navigation-voice])'),
          ...document.querySelectorAll('video')
        ];
        
        if (mediaElements.length === 0) {
          console.log("Nie znaleziono elementów audio/video do wyciszenia");
          return;
        }
        
        // Zapisz obecną głośność i elementy
        backgroundAudioElements = mediaElements;
        originalVolumeOfBackgroundAudio = mediaElements.map(el => el.volume);
        
        // Wycisz każdy element
        mediaElements.forEach(el => {
          // Zapisz aktualną głośność i zmniejsz do 20%
          try {
            if (el.volume > 0.2) {
              const originalVolume = el.volume;
              el.volume = 0.2; // Zmniejsz głośność do 20%
              console.log(`Zmniejszono głośność z ${originalVolume} do ${el.volume}`);
            }
          } catch (error) {
            console.error("Błąd podczas zmiany głośności:", error);
          }
        });
        
        isAudioLowered = true;
      }

      // Przywracanie głośności
      function restoreBackgroundAudio() {
        // Jeśli nie są wyciszone, nie rób nic
        if (!isAudioLowered) return;
        
        console.log("Przywracanie oryginalnej głośności...");
        
        // Przywróć głośność każdego elementu
        backgroundAudioElements.forEach((el, index) => {
          if (index < originalVolumeOfBackgroundAudio.length) {
            try {
              const targetVolume = originalVolumeOfBackgroundAudio[index];
              el.volume = targetVolume;
              console.log(`Przywrócono głośność do ${targetVolume}`);
            } catch (error) {
              console.error("Błąd podczas przywracania głośności:", error);
            }
          }
        });
        
        isAudioLowered = false;
      }

      // Funkcja do odtwarzania instrukcji głosowych
      function speakInstruction(text) {
        if (!voiceEnabled || !speechSynthesis) return;
        
        // Nie powtarzaj tej samej instrukcji zbyt często
        const now = Date.now();
        if (text === lastVoiceInstruction && now - lastVoiceTime < 10000) return;
        
        // Wycisz dźwięki w tle
        lowerBackgroundAudio();
        
        // Zatrzymaj wszystkie aktualnie odtwarzane głosy
        speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'pl-PL';
        utterance.volume = 1;
        utterance.rate = 1;
        utterance.pitch = 1;
        
        // Znajdź polski głos, jeśli jest dostępny
        const voices = speechSynthesis.getVoices();
        const polishVoice = voices.find(voice => voice.lang.includes('pl'));
        if (polishVoice) {
          utterance.voice = polishVoice;
        }
        
        // Przywróć głośność po zakończeniu wypowiedzi
        utterance.onend = function() {
          console.log("Wypowiedź zakończona, przywracanie głośności");
          setTimeout(restoreBackgroundAudio, 500);
        };
        
        // Na wypadek błędu w odtwarzaniu
        utterance.onerror = function(event) {
          console.error("Błąd podczas odtwarzania głosu:", event);
          restoreBackgroundAudio();
        };
        
        speechSynthesis.speak(utterance);
        
        lastVoiceInstruction = text;
        lastVoiceTime = now;
      }

      // Aktualizacja instrukcji głosowych na podstawie aktualnej pozycji
      function updateVoiceGuidance(userLocation) {
        if (!currentRoute || !currentRoute.guidance || !currentRoute.guidance.instructions) return;
        
        if (currentStep >= currentRoute.guidance.instructions.length) return;
        
        const currentInstruction = currentRoute.guidance.instructions[currentStep];
        
        if (!currentInstruction || !currentInstruction.point) return;
        
        // Oblicz odległość do kolejnego manewru
        const distanceToManeuver = calculateDistance(
          userLocation[1], userLocation[0],
          currentInstruction.point.latitude, currentInstruction.point.longitude
        );
        
        // Aktualizuj wartości dla wyświetlania i komunikatów
        nextManeuverDistance = distanceToManeuver;
        upcomingManeuver = currentInstruction.message;
        
        // Odtwórz instrukcje głosowe na podstawie odległości
        if (distanceToManeuver <= 35) {
          // Tuż przed manewrem (35m lub mniej)
          speakInstruction(formatVoiceInstruction(currentInstruction, distanceToManeuver));
        } else if (distanceToManeuver <= 150 && Math.abs(distanceToManeuver - nextManeuverDistance) > 20) {
          // Zbliżamy się do manewru (150-35m)
          speakInstruction(formatVoiceInstruction(currentInstruction, distanceToManeuver));
        } else if (distanceToManeuver <= 500 && Math.abs(distanceToManeuver - nextManeuverDistance) > 50) {
          // Manewr jest w zasięgu (500-150m)
          speakInstruction(formatVoiceInstruction(currentInstruction, distanceToManeuver));
        }
        
        // Aktualizacja panelu nawigacji
        updateNavigationPanel(distanceToManeuver);
      }

      // Funkcja do formatowania instrukcji głosowej
      function formatVoiceInstruction(step, distance) {
        if (!step) return "";
        
        let message = step.message.toLowerCase();
        const distanceInMeters = Math.round(distance);
        
        if (distanceInMeters <= 35) {
          // Jeśli jesteśmy blisko manewru (35 metrów lub mniej)
          if (message.includes("skręć w lewo")) {
            return "Skręć w lewo";
          } else if (message.includes("skręć w prawo")) {
            return "Skręć w prawo";
          } else if (message.includes("zawróć")) {
            return "Zawróć";
          } else if (message.includes("prosto")) {
            return "Jedź prosto";
          } else if (message.includes("rondo")) {
            if (message.includes("pierwszy")) {
              return "Na rondzie pierwszy zjazd";
            } else if (message.includes("drugi")) {
              return "Na rondzie drugi zjazd";
            } else if (message.includes("trzeci")) {
              return "Na rondzie trzeci zjazd";
            } else {
              return message;
            }
          } else {
            return message;
          }
        } else {
          // Jeśli jesteśmy dalej od manewru
          let instruction = `Za ${distanceInMeters} metrów `;
          
          if (message.includes("skręć w lewo")) {
            instruction += "skręć w lewo";
          } else if (message.includes("skręć w prawo")) {
            instruction += "skręć w prawo";
          } else if (message.includes("zawróć")) {
            instruction += "zawróć";
          } else if (message.includes("prosto")) {
            instruction += "jedź prosto";
          } else if (message.includes("rondo")) {
            if (message.includes("pierwszy")) {
              instruction += "na rondzie pierwszy zjazd";
            } else if (message.includes("drugi")) {
              instruction += "na rondzie drugi zjazd";
            } else if (message.includes("trzeci")) {
              instruction += "na rondzie trzeci zjazd";
            } else {
              instruction += message;
            }
          } else {
            instruction += message;
          }
          
          return instruction;
        }
      }

      // Aktualizacja panelu nawigacji
      function updateNavigationPanel(distanceToManeuver) {
        const distanceElement = document.querySelector('.navigation-distance');
        if (distanceElement) {
          distanceElement.textContent = `${Math.round(distanceToManeuver)} m`;
        }
      }

      // Aktualizacja lokalizacji użytkownika
      function updateUserLocation(position) {
        const { latitude, longitude, accuracy, heading, speed } = position.coords;
        
        // Zapisz dokładność do późniejszego użycia
        window.lastAccuracy = accuracy;
        
        // Dla debugowania
        console.log("GPS update - heading:", heading, "accuracy:", accuracy, "coords:", latitude, longitude, "speed:", speed);
        
        // Aktualizacja prędkości
        updateSpeedIndicator(speed, latitude, longitude);
        
        // Filtrujemy odczyty z niską dokładnością
        // Na telefonach często początkowe odczyty mają bardzo niską dokładność
        if (accuracy > 500) {
          console.warn("Niska dokładność GPS:", accuracy, "m - czekam na lepszy sygnał");
          
          // Jeśli jeszcze nie mamy markera, to wyświetlamy pozycję z niską dokładnością
          // ale komunikujemy użytkownikowi, że dokładność jest niska
          if (!userLocationMarker) {
            displayErrorMessage("Niska dokładność GPS (" + Math.round(accuracy) + "m). Poczekaj na lepszy sygnał.");
            
            // Tworzymy marker mimo wszystko, aby użytkownik widział przybliżoną lokalizację
            createUserMarker(latitude, longitude);
            
            // Dodajemy klasę niskiej dokładności dla efektu pulsowania
            if (userLocationMarker && userLocationMarker.getElement()) {
              userLocationMarker.getElement().classList.add('low-accuracy');
            }
            
            // Większy okrąg dokładności
            updateAccuracyCircle([longitude, latitude], accuracy);
            
            // Zapisz pozycję (ale jej nie używaj do nawigacji)
            lastPosition = [longitude, latitude];
            lastPositionTimestamp = Date.now();
          } else if (userLocationMarker && userLocationMarker.getElement()) {
            // Jeśli już mamy marker, to tylko zaktualizujmy klasę
            userLocationMarker.getElement().classList.add('low-accuracy');
          }
          return;
        } else if (userLocationMarker && userLocationMarker.getElement()) {
          // Jeśli dokładność jest wystarczająca, usuń klasę low-accuracy
          userLocationMarker.getElement().classList.remove('low-accuracy');
        }

        const userLocation = [longitude, latitude];
        const currentTime = Date.now();

        // Utwórz lub aktualizuj marker lokalizacji
        if (!userLocationMarker) {
          createUserMarker(latitude, longitude);
        } else {
          // Ustaw lokalizację dla markera
          userLocationMarker.setLngLat(userLocation);
          console.log("Zaktualizowano pozycję markera");
        }

        // Aktualizacja kierunku - rotate marker
        if (heading !== null && heading !== undefined) {
          // Obracamy strzałkę zgodnie z kierunkiem
          userHeading = heading;
          if (userLocationMarker && userLocationMarker.getElement()) {
            userLocationMarker.getElement().style.transform = `rotate(${heading}deg)`;
            console.log("Obrócono strzałkę:", heading);
          }
        } else if (lastPosition && (currentTime - lastPositionTimestamp) > 200) {
          // Oblicz kierunek na podstawie przemieszczenia jeśli brak odczytu z kompasu
          if (calculateDistance(lastPosition[1], lastPosition[0], latitude, longitude) > 2) {
            const calculatedHeading = calculateHeading(
              lastPosition[1], lastPosition[0], 
              latitude, longitude
            );
            userHeading = calculatedHeading;
            
            // Obracamy strzałkę zgodnie z kierunkiem
            if (userLocationMarker && userLocationMarker.getElement()) {
              userLocationMarker.getElement().style.transform = `rotate(${calculatedHeading}deg)`;
              console.log("Obrócono strzałkę (obliczone):", calculatedHeading);
            }
          }
        }

        // Zapisz aktualną pozycję
        lastPosition = [longitude, latitude];
        lastPositionTimestamp = currentTime;

        // Aktualizuj okrąg dokładności
        updateAccuracyCircle(userLocation, accuracy);

        // Aktualizuj obrót mapy aby strzałka pokazywała w górę - płynniejsze na telefonach
        if (isMapCentered && mapRotationEnabled && userHeading !== null) {
          // Używamy płynniejszego obrotu z mniejszą wartością duration dla telefonów
          const duration = userMovedMap ? 700 : 300;
          map.easeTo({
            center: userLocation,
            bearing: userHeading,
            duration: duration
          });
          
          // Reset flagi ruchu użytkownika po wykonaniu animacji
          if (userMovedMap) {
            setTimeout(() => {
              userMovedMap = false;
            }, duration + 100);
          }
        }
        
        // Aktualizacja nawigacji głosowej, jeśli trasa jest aktywna
        if (currentRoute && currentRoute.guidance && currentRoute.guidance.instructions) {
          updateVoiceGuidance(userLocation);
        }
        
        // Aktualizuj faktyczne ograniczenie prędkości na podstawie pozycji
        updateRealSpeedLimit(latitude, longitude);
      }
      
      // Funkcja tworząca marker użytkownika
      function createUserMarker(latitude, longitude) {
        // Tworzenie strzałki jako element DOM z SVG
          const el = document.createElement('div');
        el.className = 'user-direction-marker';
        
        // Zamiast używać obrazka, używamy SVG wbudowanego w kod z szerszą strzałką i zaokrąglonymi rogami
        el.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="100%" height="100%">
            <path d="M12 2C11.5 2 11 2.2 10.6 2.6L3 18C2.6 18.8 2.8 19.6 3.2 20.2C3.6 20.8 4.4 21 5 21H19C19.6 21 20.4 20.8 20.8 20.2C21.2 19.6 21.4 18.8 21 18L13.4 2.6C13 2.2 12.5 2 12 2Z" 
                  fill="#0066ff" stroke="#ffffff" stroke-width="1.5" stroke-linejoin="round"/>
          </svg>
        `;
        
        // Utwórz marker TomTom
        userLocationMarker = new tt.Marker({
            element: el,
          anchor: 'center',
          rotationAlignment: 'viewport' // Zmiana z 'map' na 'viewport' - lepsze działanie na urządzeniach mobilnych
          })
          .setLngLat([longitude, latitude])
            .addTo(map);
          
        // Po pierwszym pobraniu lokalizacji, wycentruj mapę i obróć ją zgodnie z kierunkiem ruchu
        map.flyTo({
          center: [longitude, latitude],
          zoom: 18,
          duration: 1000,
          bearing: userHeading || 0
        });
        
        console.log("Utworzono marker użytkownika");
        isMapCentered = true;
        userMovedMap = false;
        
        // Ukryj komunikat o uruchamianiu lokalizacji
        messageBox.setAttribute('hidden', true);
        
        // Załaduj ulubione miejsca i rzeczywiste ograniczenia prędkości
        setTimeout(() => {
          if (favoriteLocations.length > 0) {
            updateFavoritesOnMap();
          }
          
          // Pobierz rzeczywiste ograniczenia prędkości
          updateRealSpeedLimit(latitude, longitude);
        }, 1000);
      }

      // Mapa jest w pełni załadowana
      map.on('load', function() {
        console.log("Mapa załadowana");
        
        // Dodanie niestandardowego markera do mapy
        map.loadImage('https://api.tomtom.com/maps-sdk-for-web/cdn/static/pictures/poi.png', function(error, image) {
          if (error) throw error;
          map.addImage('marker-custom', image);
        });
        
        // Włącz śledzenie lokalizacji
        startUserLocationTracking();
        
        // Po załadowaniu mapy, pobierz ulubione miejsca z localStorage
        if (favoriteLocations.length > 0) {
          // Odrocz, aby mapa się w pełni załadowała
          setTimeout(updateFavoritesOnMap, 1000);
        }
      });

      // Obsługa geolokalizacji
      function startUserLocationTracking() {
        if (!navigator.geolocation) {
          displayErrorMessage("Twoja przeglądarka nie obsługuje geolokalizacji.");
          return;
        }

        console.log("Uruchamiam śledzenie lokalizacji");

        // Obsługa zdarzenia zoom - ważna dla stabilności markerów
        map.on('zoom', handleZoom);
        map.on('move', handleMapMove);
        map.on('moveend', handleMapMoveEnd);

        // Opcje geolokalizacji z maksymalną dokładnością
        const options = {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 30000  // Zwiększamy timeout do 30 sekund
        };

        // Pokaż informację o uruchamianiu lokalizacji
        displayErrorMessage("Uruchamianie lokalizacji...");
        
        // Najpierw spróbujmy uzyskać jednorazową pozycję, aby szybciej ustawić mapę
        navigator.geolocation.getCurrentPosition(
          (position) => {
            console.log("Otrzymano początkową pozycję");
            // Aktualizuj mapę na podstawie początkowej pozycji
            updateUserLocation(position);
            
            // Rozpocznij ciągłe śledzenie
            startContinuousTracking(options);
          },
          (error) => {
            console.error("Błąd podczas uzyskiwania początkowej pozycji:", error);
            // Mimo błędu, rozpocznij ciągłe śledzenie
            startContinuousTracking(options);
          },
          { ...options, timeout: 10000 } // Krótszy timeout dla pierwszej próby
        );
      }
      
      // Funkcja do ciągłego śledzenia lokalizacji
      function startContinuousTracking(options) {
        // Rozpocznij śledzenie lokalizacji
        try {
          if (userWatchId) {
            navigator.geolocation.clearWatch(userWatchId);
          }
          
          // Dodanie dodatkowych opcji dla urządzeń mobilnych
          const mobileOptions = {
            ...options,
            // Na urządzeniach mobilnych częściej aktualizujemy pozycję
            maximumAge: 0
          };
          
          userWatchId = navigator.geolocation.watchPosition(
            updateUserLocation,
            handleLocationError,
            mobileOptions
          );
          
          // Domyślnie włączamy obrót mapy - bardzo ważne na telefonie
          mapRotationEnabled = true;
          rotationToggle.checked = true;
          
          console.log("Rozpoczęto ciągłe śledzenie lokalizacji, ID:", userWatchId);
        } catch (e) {
          console.error("Błąd podczas uruchamiania geolokalizacji:", e);
          displayErrorMessage("Błąd podczas uruchamiania lokalizacji: " + e.message);
        }
      }

      // Aktualizacja widoczności przycisku centrowania
      function updateCenterButtonVisibility() {
        if (isMapCentered && !userMovedMap) {
          centerButton.classList.remove('visible');
        } else {
          centerButton.classList.add('visible');
        }
      }

      // Obsługa przycisku centrowania
      centerButton.addEventListener('click', function() {
        console.log("Kliknięto przycisk centrowania");
        
        if (!userLocationMarker) {
          console.log("Brak markera użytkownika - uruchamiam śledzenie");
          displayErrorMessage("Uruchamiam śledzenie lokalizacji...");
          startUserLocationTracking();
          return;
        }
        
        const userLocation = userLocationMarker.getLngLat();
        console.log("Centrowanie na pozycji:", userLocation);
        
        // Używaj kierunku jeśli mapa ma być obracana, w przeciwnym razie ustaw na 0
        const bearing = mapRotationEnabled ? userHeading || 0 : 0;
        
        map.flyTo({
          center: userLocation,
          zoom: 18,
          bearing: bearing,
          duration: 700
        });
        
        isMapCentered = true;
        userMovedMap = false;
      });

      // Wyświetlanie komunikatu o błędzie
      function displayErrorMessage(message, durationMs = 5000) {
        if (!messageBox || !messageBoxContent) {
          console.error("Elementy UI nie zostały jeszcze zainicjalizowane");
          console.log("Komunikat:", message);
          // Spróbuj pobrać elementy jeszcze raz
          const msgBox = document.getElementById("messageBox");
          const msgContent = document.getElementById("messageBoxContent");
          
          if (msgBox && msgContent) {
            msgContent.textContent = message;
            msgBox.removeAttribute('hidden');
            return;
          }
          
          // Jeśli nadal nie ma elementów, utwórz tymczasowy komunikat
          let tempMsg = document.getElementById("tempMessage");
          if (!tempMsg) {
            tempMsg = document.createElement("div");
            tempMsg.id = "tempMessage";
            tempMsg.style.position = "absolute";
            tempMsg.style.top = "10px";
            tempMsg.style.left = "50%";
            tempMsg.style.transform = "translateX(-50%)";
            tempMsg.style.background = "white";
            tempMsg.style.padding = "10px";
            tempMsg.style.borderRadius = "5px";
            tempMsg.style.zIndex = "9999";
            document.body.appendChild(tempMsg);
          }
          tempMsg.textContent = message;
          return;
        }
        
        // Standardowe wyświetlanie
        messageBoxContent.textContent = message;
        messageBox.removeAttribute('hidden');
        
        // Automatyczne ukrycie po określonym czasie
        setTimeout(() => {
          if (messageBox && !messageBox.getAttribute('hidden')) {
            messageBox.setAttribute('hidden', true);
          }
        }, durationMs);
      }

      // Obsługa ruchu mapy
      function handleMapMove(e) {
        if (e.originalEvent) {
          lastMapMoveTime = Date.now();
          userMovedMap = true;
          isMapCentered = false;
        }
      }

      // Obsługa zakończenia ruchu mapy
      function handleMapMoveEnd() {
        // Stabilizacja pozycji markerów po zakończeniu ruchu mapy
        if (userLocationMarker && lastPosition) {
          userLocationMarker.setLngLat([lastPosition[0], lastPosition[1]]);
        }
        
        if (userAccuracyCircle && lastPosition) {
          userAccuracyCircle.setLngLat([lastPosition[0], lastPosition[1]]);
        }
      }

      // Obsługa zmiany zooma mapy
      function handleZoom() {
        // Aktualizujemy rozmiar okręgu dokładności
        if (userAccuracyCircle && userAccuracyCircle.getElement() && window.lastAccuracy) {
          const pixelSize = window.lastAccuracy / 0.075 / Math.pow(2, map.getZoom());
          userAccuracyCircle.getElement().style.width = `${pixelSize}px`;
          userAccuracyCircle.getElement().style.height = `${pixelSize}px`;
        }
      }

      // Funkcja do aktualizacji wskaźnika prędkości
      function updateSpeedIndicator(speedInMetersPerSecond, latitude, longitude) {
        // Zabezpieczenie przed null/undefined/NaN
        if (speedInMetersPerSecond === null || speedInMetersPerSecond === undefined || isNaN(speedInMetersPerSecond)) {
          speedInMetersPerSecond = 0;
        }
        
        // Filtrowanie wartości ujemnych (niekiedy GPS zwraca błędne odczyty)
        if (speedInMetersPerSecond < 0) {
          speedInMetersPerSecond = 0;
        }
        
        // Konwersja m/s na km/h
        const speedInKmh = Math.round(speedInMetersPerSecond * 3.6);
        
        // Aktualizacja bieżącej prędkości
        currentSpeed = speedInKmh;
        
        // Aktualizacja wyświetlacza
        speedIndicator.textContent = `${speedInKmh} km/h`;
        
        // Pobieranie ograniczenia prędkości z API
        // W rzeczywistej aplikacji, moglibyśmy pobierać to z API TomTom lub innego źródła
        // Na potrzeby demonstracji, używamy stałej wartości lub symulujemy zmiany
        checkSpeedLimit(latitude, longitude);
        
        // Zmieniamy kolor wskaźnika prędkości w zależności od przekroczenia prędkości
        if (currentSpeed > currentSpeedLimit) {
          // Przekroczenie prędkości - czerwony
          speedIndicator.style.backgroundColor = '#ff0000';
        } else if (currentSpeed > currentSpeedLimit * 0.9) {
          // Blisko limitu - pomarańczowy
          speedIndicator.style.backgroundColor = '#ff9900';
        } else {
          // W normie - niebieski
          speedIndicator.style.backgroundColor = '#0066ff';
        }
      }

      // Funkcja sprawdzająca ograniczenie prędkości na danej drodze
      function checkSpeedLimit(lat, lon) {
        // W rzeczywistej aplikacji, tutaj pobieralibyśmy dane z API (np. TomTom, Overpass)
        // Dla demonstracji, używamy symulowanych danych
        
        // Symulacja zmiany ograniczenia prędkości na podstawie lokalizacji
        // W prawdziwej aplikacji zastąpilibyśmy to API
        const randomValue = Math.floor(Math.sin(lat * lon * 1000) * 10);
        
        if (randomValue < -7) {
          setSpeedLimit(30);
        } else if (randomValue < -3) {
          setSpeedLimit(50);
        } else if (randomValue < 3) {
          setSpeedLimit(70);
        } else if (randomValue < 7) {
          setSpeedLimit(90);
        } else {
          setSpeedLimit(120);
        }
      }
      
      // Ustawienie ograniczenia prędkości
      function setSpeedLimit(limit) {
        if (currentSpeedLimit !== limit) {
        currentSpeedLimit = limit;
        speedLimit.textContent = limit;
        
        // Zmiana koloru obramowania w zależności od limitu
        if (limit <= 30) {
          speedLimit.style.borderColor = '#007aff'; // niebieski
        } else if (limit <= 50) {
          speedLimit.style.borderColor = '#ff0000'; // czerwony
        } else if (limit <= 70) {
          speedLimit.style.borderColor = '#ffcc00'; // żółty
        } else if (limit <= 90) {
          speedLimit.style.borderColor = '#ff6600'; // pomarańczowy
        } else {
          speedLimit.style.borderColor = '#666666'; // szary dla autostrad
          }
        }
      }

      // Obsługa błędów geolokalizacji
      function handleLocationError(error) {
        console.error('Błąd geolokalizacji:', error);
        
        switch (error.code) {
          case error.PERMISSION_DENIED:
            displayErrorMessage("Dostęp do lokalizacji został zablokowany. Zmień ustawienia przeglądarki, aby umożliwić geolokalizację.");
            break;
          case error.POSITION_UNAVAILABLE:
            displayErrorMessage("Nie można określić Twojej lokalizacji. Upewnij się, że usługi lokalizacji są włączone.");
            break;
          case error.TIMEOUT:
            displayErrorMessage("Przekroczono czas oczekiwania na lokalizację. Spróbuj ponownie.");
            break;
          default:
            displayErrorMessage("Wystąpił błąd podczas określania lokalizacji: " + error.message);
        }

        // Spróbuj ponownie po 5 sekundach
        setTimeout(() => {
          if (userWatchId === null) {
            startUserLocationTracking();
          }
        }, 5000);
      }

      // Pobieranie ograniczenia prędkości na podstawie danych drogowych
      function updateRealSpeedLimit(latitude, longitude) {
        // Dane z API TomTom można pobrać używając tego endpointu:
        // https://api.tomtom.com/map/1/tile/basic/main/0/0/0.pbf?key=YOUR_API_KEY
        
        // Dla celów demonstracyjnych, użyjemy bardziej inteligentnej symulacji
        // która lepiej odzwierciedla rzeczywiste ograniczenia prędkości
        
        // Pobierz typ drogi na podstawie współrzędnych (symulacja)
        const roadType = determineRoadType(latitude, longitude);
        
        // Ustaw odpowiednie ograniczenie na podstawie typu drogi
        switch(roadType) {
          case 'motorway':
            setSpeedLimit(140);
            break;
          case 'trunk':
            setSpeedLimit(120);
            break;
          case 'primary':
            setSpeedLimit(90);
            break;
          case 'secondary':
            setSpeedLimit(70);
            break;
          case 'tertiary':
            setSpeedLimit(50);
            break;
          case 'residential':
            setSpeedLimit(30);
            break;
          case 'living_street':
            setSpeedLimit(20);
            break;
          default:
            setSpeedLimit(50); // Domyślnie 50 km/h
        }
        
        // Dodaj wyświetlenie aktualnej ulicy/drogi
        updateStreetInfo(latitude, longitude, roadType);
        
        // Pobierz rzeczywiste dane z OpenStreetMap
        fetchOSMRoadData(latitude, longitude);
      }
      
      // Funkcja określająca typ drogi na podstawie współrzędnych (symulacja)
      function determineRoadType(latitude, longitude) {
        // W rzeczywistej aplikacji, używalibyśmy API drogowego (np. TomTom lub OpenStreetMap)
        // Tutaj symulujemy to na podstawie współrzędnych
        
        // Używamy kombinacji współrzędnych do symulowania różnych typów dróg
        const latMod = Math.abs(Math.sin(latitude * 10)) * 10;
        const lngMod = Math.abs(Math.cos(longitude * 10)) * 10;
        const combinedValue = (latMod + lngMod) % 10;
        
        // Przypisujemy typ drogi na podstawie wartości
        if (combinedValue < 1) return 'motorway';       // Autostrada
        if (combinedValue < 2) return 'trunk';          // Droga ekspresowa
        if (combinedValue < 3.5) return 'primary';      // Droga krajowa
        if (combinedValue < 5) return 'secondary';      // Droga wojewódzka
        if (combinedValue < 7) return 'tertiary';       // Droga powiatowa
        if (combinedValue < 9) return 'residential';    // Droga miejska
        return 'living_street';                         // Strefa zamieszkania
      }
      
      // Tłumacz nazwy kategorii
      function getTranslatedCategory(category) {
        switch (category) {
          case 'prohibition':
            return 'Zakazy';
          case 'limitation':
            return 'Ograniczenia';
          case 'access':
            return 'Dostęp';
          case 'conditional':
            return 'Warunki czasowe';
          case 'warning':
            return 'Ostrzeżenia';
          case 'info':
            return 'Informacje';
          default:
            return 'Inne';
        }
      }
      
      // Wyświetlenie informacji o aktualnej ulicy
      function updateStreetInfo(latitude, longitude, roadType) {
        // Ta funkcja została zastąpiona przez updateStreetDisplay, więc przekierowujemy do niej
        // z pustymi ograniczeniami, zanim otrzymamy dane OSM
        const streets = {
          'motorway': ['Autostrada A1', 'Autostrada A2', 'Autostrada A4'],
          'trunk': ['Droga ekspresowa S7', 'Droga ekspresowa S8', 'Droga ekspresowa S5'],
          'primary': ['Droga krajowa 7', 'Droga krajowa 8', 'Aleja Niepodległości'],
          'secondary': ['Droga wojewódzka 123', 'Ulica Mickiewicza', 'Aleja Jana Pawła II'],
          'tertiary': ['Ulica Kościuszki', 'Ulica Piastowska', 'Ulica Chrobrego'],
          'residential': ['Ulica Polna', 'Ulica Kwiatowa', 'Ulica Słoneczna'],
          'living_street': ['Osiedle Słoneczne', 'Ulica Cicha', 'Ulica Spokojna']
        };
        
        // Wybierz losową nazwę ulicy z odpowiedniej kategorii
        const streetIndex = Math.floor((latitude + longitude) * 10) % 3;
        const streetName = streets[roadType][streetIndex];
        
        // Wyświetl tymczasowo nazwę ulicy, zanim otrzymamy prawdziwe dane z OSM
        updateStreetDisplay(streetName, []);
      }
      
      // Pobieranie danych drogowych z OpenStreetMap przez Overpass API
      function fetchOSMRoadData(latitude, longitude) {
        // Ograniczamy liczbę zapytań, aby nie przeciążać API
        const now = Date.now();
        if (window.lastOSMRequest && (now - window.lastOSMRequest < 5000)) {
          return; // Ograniczamy do jednego zapytania na 5 sekund
        }
        window.lastOSMRequest = now;
        
        // Tworzymy zapytanie Overpass
        const radius = 100; // Zwiększony promień wyszukiwania w metrach
        const query = `
          [out:json][timeout:25];
          (
            // Wyszukaj wszystkie drogi w pobliżu z dodatkowymi tagami dla ograniczeń
            way["highway"](around:${radius},${latitude},${longitude});
            // Drogi z ograniczeniami dostępu
            way["access"](around:${radius},${latitude},${longitude});
            // Drogi jednokierunkowe
            way["oneway"="yes"](around:${radius},${latitude},${longitude});
            // Drogi z ograniczeniami masy
            way["maxweight"](around:${radius},${latitude},${longitude});
            // Drogi z ograniczeniami wysokości
            way["maxheight"](around:${radius},${latitude},${longitude});
            // Drogi z ograniczeniami szerokości
            way["maxwidth"](around:${radius},${latitude},${longitude});
            // Drogi w budowie
            way["highway"="construction"](around:${radius},${latitude},${longitude});
            // Drogi z ograniczeniami dla pojazdów
            way["vehicle"](around:${radius},${latitude},${longitude});
            way["motor_vehicle"](around:${radius},${latitude},${longitude});
            way["hgv"](around:${radius},${latitude},${longitude});
            // Drogi z ograniczeniami dla pieszych i rowerzystów
            way["foot"](around:${radius},${latitude},${longitude});
            way["bicycle"](around:${radius},${latitude},${longitude});
            // Drogi z ograniczeniami czasowymi
            way["opening_hours"](around:${radius},${latitude},${longitude});
          );
          out body;
          >;
          out skel qt;
        `;
        
        const overpassUrl = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;
        
        // Pokaż komunikat o ładowaniu
        console.log("Pobieranie danych OSM...");
        
        // Ustaw timeout dla zapytania
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 sekund timeout
        
        // Wykonuj zapytanie
        fetch(overpassUrl, { signal: controller.signal })
          .then(response => {
            clearTimeout(timeoutId);
            if (!response.ok) {
              throw new Error('Błąd podczas pobierania danych z Overpass API');
            }
            return response.json();
          })
          .then(data => {
            console.log("Otrzymano dane OSM:", data);
            processOSMRoadData(data, latitude, longitude);
          })
          .catch(error => {
            clearTimeout(timeoutId);
            console.error("Błąd Overpass API:", error);
            
            if (error.name === 'AbortError') {
              console.log("Zapytanie przerwane z powodu timeout");
              displayErrorMessage('Przekroczono czas oczekiwania na dane drogowe. Używam danych lokalnych.');
        } else {
              displayErrorMessage('Nie udało się pobrać danych drogowych. Używam danych lokalnych.');
            }
            
            // Kontynuuj z symulowanymi danymi w przypadku błędu
            const simulatedRoadType = determineRoadType(latitude, longitude);
            updateStreetInfo(latitude, longitude, simulatedRoadType);
          });
      }
      
      // Przetwarzanie danych drogowych z OpenStreetMap
      function processOSMRoadData(data, latitude, longitude) {
        if (!data || !data.elements || data.elements.length === 0) {
          console.log("Brak danych drogowych z OSM");
          const simulatedRoadType = determineRoadType(latitude, longitude);
          updateStreetInfo(latitude, longitude, simulatedRoadType);
          return;
        }
        
        // Przygotuj wszystkie drogi z danymi GPS
        const roadsWithLocations = [];
        
        // Najpierw zbierzmy wszystkie węzły
        const nodes = {};
        data.elements.forEach(element => {
          if (element.type === 'node' && element.lat && element.lon) {
            nodes[element.id] = {
              lat: element.lat,
              lon: element.lon
            };
          }
        });
        
        // Teraz przygotujmy drogi z ich danymi GPS
        data.elements.forEach(element => {
          if (element.type === 'way' && element.tags && element.tags.highway && element.nodes) {
            // Zbierz współrzędne drogi
            const wayPoints = [];
            let validWay = false;
            
            element.nodes.forEach(nodeId => {
              if (nodes[nodeId]) {
                wayPoints.push(nodes[nodeId]);
                validWay = true;
              }
            });
            
            if (validWay && wayPoints.length > 0) {
              // Oblicz średnie współrzędne drogi
              let sumLat = 0, sumLon = 0;
              wayPoints.forEach(point => {
                sumLat += point.lat;
                sumLon += point.lon;
              });
              
              const centerLat = sumLat / wayPoints.length;
              const centerLon = sumLon / wayPoints.length;
              
              // Oblicz odległość od bieżącej pozycji do drogi
              const distance = calculateDistance(latitude, longitude, centerLat, centerLon);
              
              // Oblicz najbliższy punkt na drodze (jeśli mamy więcej niż 1 punkt)
              let closestPointDistance = distance;
              if (wayPoints.length > 1) {
                wayPoints.forEach(point => {
                  const pointDistance = calculateDistance(latitude, longitude, point.lat, point.lon);
                  if (pointDistance < closestPointDistance) {
                    closestPointDistance = pointDistance;
                  }
                });
              }
              
              // Oblicz priorytet drogi (niższy priorytet = ważniejsza droga)
              let priority = 10; // Domyślny priorytet
              
              // Drogi z nazwami są ważniejsze (niższy priorytet)
              if (element.tags.name) priority -= 3;
              
              // Drogi z ograniczeniem prędkości są ważniejsze
              if (element.tags.maxspeed) priority -= 2;
              
              // Większe drogi są ważniejsze
              const roadType = element.tags.highway;
              if (roadType === 'motorway' || roadType === 'trunk') priority -= 5;
              if (roadType === 'primary') priority -= 4;
              if (roadType === 'secondary') priority -= 3;
              if (roadType === 'tertiary') priority -= 2;
              if (roadType === 'residential') priority -= 1;
              
              // Dodaj drogę do listy
              roadsWithLocations.push({
                road: element,
                distance: closestPointDistance,
                centerLat,
                centerLon,
                priority
              });
            }
          }
        });
        
        // Posortuj drogi według odległości i priorytetu
        roadsWithLocations.sort((a, b) => {
          // Jeśli drogi są w podobnej odległości (w promieniu 20m), decyduje priorytet
          if (Math.abs(a.distance - b.distance) < 20) {
            return a.priority - b.priority;
          }
          return a.distance - b.distance;
        });
        
        // Pobierz najbliższą drogę
        if (roadsWithLocations.length > 0) {
          const bestRoad = roadsWithLocations[0];
          console.log("Wybrana droga:", bestRoad.road, "odległość:", bestRoad.distance, "priorytet:", bestRoad.priority);
          updateRoadInfoFromOSM(bestRoad.road);
        } else {
          console.log("Nie znaleziono odpowiedniej drogi w pobliżu");
          const simulatedRoadType = determineRoadType(latitude, longitude);
          updateStreetInfo(latitude, longitude, simulatedRoadType);
        }
      }
      
      // Aktualizacja informacji o drodze na podstawie danych OSM
      function updateRoadInfoFromOSM(road) {
        if (!road || !road.tags) return;
        
        // Pobierz nazwę ulicy
        const roadName = road.tags.name || road.tags.ref || "Droga bez nazwy";
        
        // Pobierz ograniczenie prędkości
        let speedLimit = road.tags.maxspeed;
        
        // Konwersja tekstowych ograniczeń na liczby
        if (speedLimit) {
          // Usuń jednostki i spacje
          speedLimit = speedLimit.replace(/\s+/g, '');
          // Wyciągnij samą liczbę
          const speedMatch = speedLimit.match(/(\d+)/);
          if (speedMatch && speedMatch[1]) {
            speedLimit = parseInt(speedMatch[1], 10);
            } else {
            // Domyślne ograniczenia dla różnych typów dróg
            speedLimit = getDefaultSpeedLimit(road.tags.highway);
            }
          } else {
          // Brak jawnego ograniczenia prędkości - użyj domyślnego na podstawie typu drogi
          speedLimit = getDefaultSpeedLimit(road.tags.highway);
        }
        
        // Zaktualizuj wyświetlane ograniczenie prędkości
        setSpeedLimit(speedLimit);
        
        // Znajdź ograniczenia na drodze
        const restrictions = findRoadRestrictions(road);
        
        // Zaktualizuj nazwę ulicy i ograniczenia na wyświetlaczu
        updateStreetDisplay(roadName, restrictions);
        
        // Pokaż komunikat jeśli znaleziono ograniczenia
        if (restrictions.length > 0) {
          const restrictionTypes = restrictions.map(r => r.type);
          
          // Sprawdź czy są jakieś ważne ograniczenia
          const hasImportantRestrictions = restrictionTypes.some(type => 
            ['no_entry', 'no_vehicles', 'no_motor_vehicles', 'construction', 'weight', 'height', 'width'].includes(type)
          );
          
          if (hasImportantRestrictions) {
            displayErrorMessage(`Uwaga: Na drodze "${roadName}" obowiązują ważne ograniczenia!`, 6000);
          }
        }
        
        console.log(`Aktualizacja danych drogi: ${roadName}, ograniczenie: ${speedLimit} km/h, ograniczenia:`, restrictions);
      }
      
      // Funkcja znajdująca ograniczenia na drodze
      function findRoadRestrictions(road) {
        if (!road || !road.tags) return [];
        
        const restrictions = [];
        const tags = road.tags;
        
        // Sprawdź różne możliwe ograniczenia
        if (tags.access === 'no' || tags.access === 'private') {
          restrictions.push({ type: 'no_entry', description: 'Zakaz wjazdu' });
        }
        
        if (tags.oneway === 'yes') {
          restrictions.push({ type: 'one_way', description: 'Droga jednokierunkowa' });
        }
        
        if (tags.maxweight) {
          restrictions.push({ type: 'weight', description: `Ograniczenie masy: ${tags.maxweight}` });
        }
        
        if (tags.maxheight) {
          restrictions.push({ type: 'height', description: `Ograniczenie wysokości: ${tags.maxheight}` });
        }
        
        if (tags.maxwidth) {
          restrictions.push({ type: 'width', description: `Ograniczenie szerokości: ${tags.maxwidth}` });
        }
        
        if (tags.maxspeed) {
          // Pomiń ograniczenie prędkości, ponieważ jest już wyświetlane w innym miejscu
        }
        
        if (tags.highway === 'construction') {
          restrictions.push({ type: 'construction', description: 'Droga w budowie' });
        }
        
        if (tags['vehicle:forward'] === 'no' || tags['vehicle:backward'] === 'no') {
          restrictions.push({ type: 'no_vehicles', description: 'Zakaz ruchu pojazdów w jednym kierunku' });
        }
        
        if (tags.vehicle === 'no') {
          restrictions.push({ type: 'no_vehicles', description: 'Zakaz ruchu pojazdów' });
        }
        
        if (tags.motor_vehicle === 'no') {
          restrictions.push({ type: 'no_motor_vehicles', description: 'Zakaz ruchu pojazdów silnikowych' });
        }
        
        if (tags.hgv === 'no') {
          restrictions.push({ type: 'no_trucks', description: 'Zakaz ruchu ciężarówek' });
        }
        
        if (tags.motorcycle === 'no') {
          restrictions.push({ type: 'no_motorcycles', description: 'Zakaz ruchu motocykli' });
        }
        
        if (tags.foot === 'no') {
          restrictions.push({ type: 'no_pedestrians', description: 'Zakaz ruchu pieszych' });
        }
        
        if (tags.bicycle === 'no') {
          restrictions.push({ type: 'no_bicycles', description: 'Zakaz ruchu rowerów' });
        }
        
        // Inne ograniczenia czasowe
        if (tags.opening_hours) {
          restrictions.push({ type: 'time_restriction', description: `Ograniczenia czasowe: ${tags.opening_hours}` });
        }
        
        // Ograniczenia prędkości warunkowe
        if (tags['maxspeed:conditional']) {
          restrictions.push({ type: 'speed_conditional', description: `Warunkowe ograniczenie prędkości: ${tags['maxspeed:conditional']}` });
        }
        
        // Ulica mieszkalna
        if (tags.highway === 'living_street') {
          restrictions.push({ type: 'living_street', description: 'Strefa zamieszkania' });
        }
        
        // Strefa dla pieszych
        if (tags.highway === 'pedestrian') {
          restrictions.push({ type: 'pedestrian_zone', description: 'Strefa dla pieszych' });
        }
        
        // Ulica z ograniczeniami tonażu
        if (tags.hgv === 'destination') {
          restrictions.push({ type: 'trucks_destination', description: 'Ciężarówki tylko dla docelowego ruchu' });
        }
        
        // Droga z ograniczonym dostępem
        if (tags.access === 'destination') {
          restrictions.push({ type: 'destination_only', description: 'Tylko dla docelowego ruchu' });
        }
        
        // Zakaz wjazdu o określonych porach
        if (tags['access:conditional']) {
          restrictions.push({ type: 'access_conditional', description: `Warunkowy dostęp: ${tags['access:conditional']}` });
        }
        
        // Ograniczenie długości pojazdu
        if (tags.maxlength) {
          restrictions.push({ type: 'length', description: `Ograniczenie długości: ${tags.maxlength}` });
        }
        
        // Zakaz skrętu
        if (tags['restriction'] && tags['restriction'].includes('no_')) {
          restrictions.push({ type: 'no_turn', description: 'Zakaz skrętu' });
        }
        
        // Zakaz zawracania
        if (tags['restriction'] === 'no_u_turn') {
          restrictions.push({ type: 'no_u_turn', description: 'Zakaz zawracania' });
        }
        
        // Pobieramy także informacje o nawierzchni drogi
        if (tags.surface) {
          const surfaceType = tags.surface;
          let surfaceDescription = 'Nawierzchnia: ';
          
          switch(surfaceType) {
            case 'asphalt':
              surfaceDescription += 'asfaltowa';
              break;
            case 'concrete':
              surfaceDescription += 'betonowa';
              break;
            case 'paved':
              surfaceDescription += 'utwardzona';
              break;
            case 'unpaved':
              surfaceDescription += 'nieutwardzona';
              break;
            case 'gravel':
              surfaceDescription += 'żwirowa';
              break;
            case 'paving_stones':
              surfaceDescription += 'brukowa';
              break;
            case 'cobblestone':
              surfaceDescription += 'kocie łby';
              break;
            case 'dirt':
              surfaceDescription += 'gruntowa';
              break;
            case 'grass':
              surfaceDescription += 'trawiasta';
              break;
            case 'sand':
              surfaceDescription += 'piaszczysta';
              break;
            default:
              surfaceDescription += surfaceType;
          }
          
          restrictions.push({ type: 'surface', description: surfaceDescription });
        }
        
        // Dozwolona maksymalna prędkość jest już obsługiwana osobno
        
        return restrictions;
      }
      
      // Zwróć ikonę dla danego typu ograniczenia
      function getRestrictionIcon(type) {
        switch (type) {
          case 'no_entry':
            return '<i class="fas fa-ban" style="color: #ff0000;"></i>';
          case 'one_way':
            return '<i class="fas fa-arrow-right" style="color: #0066ff;"></i>';
          case 'weight':
            return '<i class="fas fa-truck" style="color: #ff9900;"></i>';
          case 'height':
            return '<i class="fas fa-arrows-alt-v" style="color: #ff9900;"></i>';
          case 'width':
            return '<i class="fas fa-arrows-alt-h" style="color: #ff9900;"></i>';
          case 'construction':
            return '<i class="fas fa-hard-hat" style="color: #ffcc00;"></i>';
          case 'no_vehicles':
            return '<i class="fas fa-car" style="color: #ff0000;"></i>';
          case 'no_motor_vehicles':
            return '<i class="fas fa-car" style="color: #ff0000;"></i>';
          case 'no_trucks':
            return '<i class="fas fa-truck" style="color: #ff0000;"></i>';
          case 'no_motorcycles':
            return '<i class="fas fa-motorcycle" style="color: #ff0000;"></i>';
          case 'no_pedestrians':
            return '<i class="fas fa-walking" style="color: #ff0000;"></i>';
          case 'no_bicycles':
            return '<i class="fas fa-bicycle" style="color: #ff0000;"></i>';
          case 'time_restriction':
            return '<i class="fas fa-clock" style="color: #0066ff;"></i>';
          case 'speed_conditional':
            return '<i class="fas fa-tachometer-alt" style="color: #ff9900;"></i>';
          case 'living_street':
            return '<i class="fas fa-home" style="color: #0066ff;"></i>';
          case 'pedestrian_zone':
            return '<i class="fas fa-walking" style="color: #0066ff;"></i>';
          case 'trucks_destination':
            return '<i class="fas fa-truck" style="color: #0066ff;"></i>';
          case 'destination_only':
            return '<i class="fas fa-flag-checkered" style="color: #0066ff;"></i>';
          case 'access_conditional':
            return '<i class="fas fa-calendar-alt" style="color: #ff9900;"></i>';
          case 'length':
            return '<i class="fas fa-ruler-horizontal" style="color: #ff9900;"></i>';
          case 'no_turn':
            return '<i class="fas fa-undo" style="color: #ff0000;"></i>';
          case 'no_u_turn':
            return '<i class="fas fa-undo" style="color: #ff0000;"></i>';
          case 'surface':
            return '<i class="fas fa-road" style="color: #999999;"></i>';
          default:
            return '<i class="fas fa-exclamation-triangle" style="color: #ff9900;"></i>';
        }
      }
      
      // Zaktualizuj wyświetlanie informacji o ulicy i ograniczeniach
      function updateStreetDisplay(roadName, restrictions) {
        // Usuń poprzedni element, jeśli istnieje
        const oldStreetDisplay = document.getElementById('streetDisplay');
        if (oldStreetDisplay) {
          oldStreetDisplay.remove();
        }
        
        // Utwórz kontener dla informacji o ulicy
        const streetDisplay = document.createElement('div');
        streetDisplay.className = 'street-display';
        streetDisplay.id = 'streetDisplay';
        streetDisplay.style.position = 'fixed';
        streetDisplay.style.bottom = '180px';
        streetDisplay.style.left = '50%';
        streetDisplay.style.transform = 'translateX(-50%)';
        streetDisplay.style.background = 'rgba(0,0,0,0.8)';
        streetDisplay.style.color = 'white';
        streetDisplay.style.padding = '10px 15px';
        streetDisplay.style.borderRadius = '20px';
        streetDisplay.style.fontFamily = 'Arial, sans-serif';
        streetDisplay.style.fontSize = '16px';
        streetDisplay.style.zIndex = '1000';
        streetDisplay.style.minWidth = '220px';
        streetDisplay.style.maxWidth = '90%';
        streetDisplay.style.textAlign = 'center';
        streetDisplay.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        streetDisplay.style.transition = 'all 0.3s ease';
        
        // Dodaj nazwę ulicy
        const roadNameElement = document.createElement('div');
        roadNameElement.textContent = roadName;
        roadNameElement.style.fontWeight = 'bold';
        roadNameElement.style.fontSize = '18px';
        roadNameElement.style.marginBottom = restrictions.length > 0 ? '5px' : '0';
        streetDisplay.appendChild(roadNameElement);
        
        // Dodaj ograniczenia, jeśli istnieją
        if (restrictions.length > 0) {
          // Dodaj informację o liczbie ograniczeń i przycisk zwijania/rozwijania
          const toggleContainer = document.createElement('div');
          toggleContainer.style.display = 'flex';
          toggleContainer.style.justifyContent = 'space-between';
          toggleContainer.style.alignItems = 'center';
          toggleContainer.style.marginTop = '5px';
          toggleContainer.style.marginBottom = '8px';
          toggleContainer.style.padding = '5px 0';
          toggleContainer.style.borderTop = '1px solid rgba(255, 255, 255, 0.2)';
          toggleContainer.style.borderBottom = '1px solid rgba(255, 255, 255, 0.2)';
          
          const restrictionsCount = document.createElement('div');
          restrictionsCount.textContent = `${restrictions.length} ${restrictions.length === 1 ? 'ograniczenie' : 'ograniczenia'}`;
          restrictionsCount.style.fontSize = '14px';
          restrictionsCount.style.color = '#999';
          toggleContainer.appendChild(restrictionsCount);
          
          const toggleButton = document.createElement('button');
          toggleButton.innerHTML = '<i class="fas fa-chevron-down"></i>';
          toggleButton.style.background = 'transparent';
          toggleButton.style.border = 'none';
          toggleButton.style.color = '#999';
          toggleButton.style.cursor = 'pointer';
          toggleButton.style.fontSize = '14px';
          toggleButton.style.padding = '0 5px';
          toggleButton.setAttribute('aria-label', 'Pokaż/ukryj ograniczenia');
          toggleContainer.appendChild(toggleButton);
          
          streetDisplay.appendChild(toggleContainer);
          
          // Kontener dla ograniczeń, który będzie można zwinąć/rozwinąć
          const restrictionsContainer = document.createElement('div');
          restrictionsContainer.id = 'restrictionsContainer';
          restrictionsContainer.style.display = 'flex';
          restrictionsContainer.style.flexDirection = 'column';
          restrictionsContainer.style.gap = '6px';
          restrictionsContainer.style.fontSize = '14px';
          restrictionsContainer.style.maxHeight = '200px';
          restrictionsContainer.style.overflow = 'auto';
          restrictionsContainer.style.transition = 'max-height 0.3s ease';
          restrictionsContainer.style.padding = '5px 0';
          
          // Pogrupuj ograniczenia według typu
          const groupedRestrictions = {};
          restrictions.forEach(restriction => {
            const category = getCategoryForRestriction(restriction.type);
            if (!groupedRestrictions[category]) {
              groupedRestrictions[category] = [];
            }
            groupedRestrictions[category].push(restriction);
          });
          
          // Dodaj ograniczenia pogrupowane
          Object.keys(groupedRestrictions).forEach(category => {
            // Nagłówek kategorii
            const categoryHeader = document.createElement('div');
            categoryHeader.textContent = getTranslatedCategory(category);
            categoryHeader.style.fontWeight = 'bold';
            categoryHeader.style.color = '#aaa';
            categoryHeader.style.fontSize = '12px';
            categoryHeader.style.textAlign = 'left';
            categoryHeader.style.marginTop = '5px';
            categoryHeader.style.textTransform = 'uppercase';
            restrictionsContainer.appendChild(categoryHeader);
            
            // Ograniczenia w kategorii
            groupedRestrictions[category].forEach(restriction => {
              const restrictionElement = document.createElement('div');
              restrictionElement.style.display = 'flex';
              restrictionElement.style.alignItems = 'center';
              restrictionElement.style.textAlign = 'left';
              restrictionElement.style.padding = '3px 0';
              
              // Dodaj ikonę ograniczenia
              const iconSpan = document.createElement('span');
              iconSpan.innerHTML = getRestrictionIcon(restriction.type);
              iconSpan.style.marginRight = '8px';
              iconSpan.style.display = 'flex';
              iconSpan.style.alignItems = 'center';
              iconSpan.style.justifyContent = 'center';
              iconSpan.style.width = '20px';
              
              const textSpan = document.createElement('span');
              textSpan.textContent = restriction.description;
              
              restrictionElement.appendChild(iconSpan);
              restrictionElement.appendChild(textSpan);
              restrictionsContainer.appendChild(restrictionElement);
            });
          });
          
          streetDisplay.appendChild(restrictionsContainer);
          
          // Logika zwijania/rozwijania
          let isExpanded = true;
          toggleButton.addEventListener('click', () => {
            isExpanded = !isExpanded;
            if (isExpanded) {
              restrictionsContainer.style.maxHeight = '200px';
              restrictionsContainer.style.padding = '5px 0';
              toggleButton.innerHTML = '<i class="fas fa-chevron-up"></i>';
          } else {
              restrictionsContainer.style.maxHeight = '0';
              restrictionsContainer.style.padding = '0';
              toggleButton.innerHTML = '<i class="fas fa-chevron-down"></i>';
            }
          });
        }
        
        // Dodaj do dokumentu
        document.body.appendChild(streetDisplay);
      }
      
      // Określ kategorię dla ograniczenia
      function getCategoryForRestriction(type) {
        switch (type) {
          case 'no_entry':
          case 'no_vehicles':
          case 'no_motor_vehicles':
          case 'no_trucks':
          case 'no_motorcycles':
          case 'no_pedestrians':
          case 'no_bicycles':
          case 'no_turn':
          case 'no_u_turn':
            return 'prohibition';
            
          case 'weight':
          case 'height':
          case 'width':
          case 'length':
            return 'limitation';
            
          case 'one_way':
          case 'living_street':
          case 'pedestrian_zone':
          case 'trucks_destination':
          case 'destination_only':
            return 'access';
            
          case 'time_restriction':
          case 'speed_conditional':
          case 'access_conditional':
            return 'conditional';
            
          case 'construction':
            return 'warning';
            
          case 'surface':
            return 'info';
            
          default:
            return 'other';
        }
      }
      
      // Domyślne ograniczenia prędkości dla różnych typów dróg w Polsce
      function getDefaultSpeedLimit(highwayType) {
        switch (highwayType) {
          case 'motorway':
            return 140;
          case 'trunk':
            return 120;
          case 'primary':
            return 90;
          case 'secondary':
            return 90;
          case 'tertiary':
            return 90;
          case 'unclassified':
            return 90;
          case 'residential':
            return 50;
          case 'service':
            return 30;
          case 'living_street':
            return 20;
          default:
            return 50;
        }
      }

      // Funkcja do obliczania kierunku na podstawie dwóch punktów
      function calculateHeading(lat1, lon1, lat2, lon2) {
        // Konwersja stopni na radiany
        const toRad = (val) => val * Math.PI / 180;
        
        // Obliczenie kierunku
        const y = Math.sin(toRad(lon2-lon1)) * Math.cos(toRad(lat2));
        const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
                Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(toRad(lon2-lon1));
        
        let bearing = Math.atan2(y, x) * 180 / Math.PI;
        bearing = (bearing + 360) % 360; // Normalizacja do 0-360
        
        return bearing;
      }

      // Funkcja do obliczania odległości między dwoma punktami
      function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3; // Promień Ziemi w metrach
        const toRad = (val) => val * Math.PI / 180;
        
        const φ1 = toRad(lat1);
        const φ2 = toRad(lat2);
        const Δφ = toRad(lat2-lat1);
        const Δλ = toRad(lon2-lon1);

        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        return R * c; // Odległość w metrach
      }

      // Aktualizacja okręgu dokładności
      function updateAccuracyCircle(position, accuracy) {
        if (!userAccuracyCircle) {
          // Tworzenie okręgu dokładności
          const el = document.createElement('div');
          el.className = 'user-accuracy-circle';
          
          userAccuracyCircle = new tt.Marker({
            element: el,
            anchor: 'center'
          })
            .setLngLat(position)
            .addTo(map);
        } else {
          userAccuracyCircle.setLngLat(position);
        }
        
        // Aktualizacja rozmiaru okręgu
        if (userAccuracyCircle.getElement()) {
          const pixelSize = accuracy / 0.075 / Math.pow(2, map.getZoom());
          userAccuracyCircle.getElement().style.width = `${pixelSize}px`;
          userAccuracyCircle.getElement().style.height = `${pixelSize}px`;
        }
      }
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <title>Żółwik Pro</title>
    <link
      rel="stylesheet"
      href="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.25.0/maps/maps.css"
    />
    <script src="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.25.0/maps/maps-web.min.js"></script>
    <script src="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.25.0/services/services-web.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    />
    <style>
      html,
      body,
      #map {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
      }

      .settings-btn {
        position: absolute;
        top: 10px;
        left: 10px;
        background: white;
        border: none;
        padding: 12px;
        font-size: 20px;
        cursor: pointer;
        border-radius: 50%;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .settings-panel {
        display: none;
        position: absolute;
        top: 70px;
        left: 10px;
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 200px;
      }

      .settings-panel label {
        display: flex;
        align-items: center;
        margin-bottom: 12px;
        cursor: pointer;
        font-size: 16px;
      }

      .settings-panel input[type="checkbox"] {
        margin-right: 10px;
        width: 18px;
        height: 18px;
      }

      .center-btn {
        position: absolute;
        bottom: 100px;
        right: 15px;
        background: white;
        border: none;
        border-radius: 50%;
        width: 45px;
        height: 45px;
        font-size: 20px;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        z-index: 2;
        display: none;
        transition: opacity 0.3s ease-in-out;
        opacity: 0;
      }

      .center-btn.visible {
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 1;
      }

      .message-box {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        padding: 12px 15px;
        border-radius: 8px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 3;
        display: flex;
        align-items: center;
        max-width: 90%;
        width: auto;
      }

      .message-box-content {
        flex-grow: 1;
        font-size: 16px;
      }

      .message-box-close {
        margin-left: 10px;
        cursor: pointer;
        font-size: 20px;
        padding: 0 5px;
      }

      .user-direction-marker {
        width: 40px;
        height: 40px;
        background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="%23ff8000"><path d="M256 0L32 445.7 256 352l224 93.7z"/></svg>');
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        transform-origin: center center;
      }

      .user-accuracy-circle {
        background-color: rgba(0, 122, 255, 0.1);
        border: 1px solid rgba(0, 122, 255, 0.3);
        border-radius: 50%;
      }

      /* Media queries dla urządzeń mobilnych */
      @media (max-width: 768px) {
        .settings-btn {
          top: 15px;
          left: 15px;
          width: 50px;
          height: 50px;
          font-size: 22px;
        }

        .settings-panel {
          top: 80px;
          left: 15px;
          width: 250px;
          padding: 20px;
        }

        .settings-panel label {
          font-size: 18px;
          margin-bottom: 15px;
        }

        .settings-panel input[type="checkbox"] {
          width: 20px;
          height: 20px;
        }

        .center-btn {
          bottom: 120px;
          right: 20px;
          width: 50px;
          height: 50px;
          font-size: 22px;
        }

        .message-box {
          top: 15px;
          padding: 15px;
        }

        .message-box-content {
          font-size: 18px;
        }

        .message-box-close {
          font-size: 24px;
        }
      }

      /* Dodatkowe style dla małych ekranów */
      @media (max-width: 480px) {
        .settings-panel {
          width: 200px;
        }

        .message-box {
          width: 85%;
        }
      }

      /* Style dla wyszukiwarki */
      .search-btn {
        position: absolute;
        top: 10px;
        left: 60px;
        background: white;
        border: none;
        padding: 12px;
        font-size: 20px;
        cursor: pointer;
        border-radius: 50%;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .search-panel {
        display: none;
        position: absolute;
        top: 70px;
        left: 60px;
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 300px;
      }

      .search-input {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 16px;
        margin-bottom: 10px;
      }

      .search-results {
        max-height: 300px;
        overflow-y: auto;
      }

      .search-result-item {
        padding: 10px;
        cursor: pointer;
        border-bottom: 1px solid #eee;
      }

      .search-result-item:hover {
        background-color: #f5f5f5;
      }

      /* Style dla nawigacji */
      .navigation-panel {
        display: none;
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 90%;
        max-width: 400px;
      }

      .navigation-step {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }

      .navigation-icon {
        width: 40px;
        height: 40px;
        background: #4CAF50;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 10px;
        color: white;
        font-size: 20px;
      }

      .navigation-info {
        flex-grow: 1;
      }

      .navigation-distance {
        font-size: 14px;
        color: #666;
      }

      .navigation-eta {
        font-size: 14px;
        color: #666;
        margin-top: 5px;
      }

      .navigation-close {
        position: absolute;
        top: 10px;
        right: 10px;
        cursor: pointer;
        font-size: 20px;
      }

      @media (max-width: 768px) {
        .search-panel {
          width: calc(100% - 40px);
          right: 20px;
        }

        .navigation-panel {
          width: calc(100% - 40px);
        }
      }
    </style>
  </head>

  <body>
    <div id="map" class="map"></div>

    <!-- Przycisk wyszukiwania -->
    <button class="search-btn" id="searchBtn"><i class="fas fa-search"></i></button>

    <!-- Panel wyszukiwania -->
    <div class="search-panel" id="searchPanel">
      <input type="text" class="search-input" id="searchInput" placeholder="Wyszukaj miejsce...">
      <div class="search-results" id="searchResults"></div>
    </div>

    <!-- Panel nawigacji -->
    <div class="navigation-panel" id="navigationPanel">
      <span class="navigation-close" id="navigationClose">&times;</span>
      <div id="navigationContent"></div>
    </div>

    <!-- Przycisk ustawień -->
    <button class="settings-btn"><i class="fas fa-cog"></i></button>

    <!-- Panel ustawień -->
    <div class="settings-panel" id="settingsPanel">
      <label>
        <input type="checkbox" id="flow-toggle" />
        Pokaż ruch drogowy
      </label>
      <label>
        <input id="incidents-toggle" type="checkbox" />
        Pokaż incydenty drogowe
      </label>
      <label>
        <input id="rotation-toggle" type="checkbox" checked />
        Obracaj mapę zgodnie z kierunkiem
      </label>
      <label>
        <input id="buildings-toggle" type="checkbox" />
        Pokaż budynki 3D
      </label>
    </div>

    <!-- Przycisk centrowania -->
    <button class="center-btn" id="centerButton"><i class="fas fa-location-arrow"></i></button>

    <!-- Komunikat o błędzie -->
    <div class="message-box" id="messageBox" hidden>
      <div class="message-box-content" id="messageBoxContent"></div>
      <span class="message-box-close" id="messageBoxClose">&times;</span>
    </div>

    <script>
      const apiKey = "5sWFmhOgtZG9Aaj19W6LgDwQrwiCFTOG";

      const map = tt.map({
        key: apiKey,
        container: "map",
        center: [21.0122, 52.2297], // Warszawa
        zoom: 14,
        // style: "tomtom://vector/1/basic-main",
        pitch: 0
      });

      map.addControl(new tt.NavigationControl());
      map.addControl(new tt.FullscreenControl());

      // Elementy UI
      const settingsBtn = document.querySelector(".settings-btn");
      const settingsPanel = document.getElementById("settingsPanel");
      const trafficToggle = document.getElementById("flow-toggle");
      const incidentsCheckbox = document.getElementById("incidents-toggle");
      const rotationToggle = document.getElementById("rotation-toggle");
      const centerButton = document.getElementById("centerButton");
      const messageBox = document.getElementById("messageBox");
      const messageBoxContent = document.getElementById("messageBoxContent");
      const messageBoxClose = document.getElementById("messageBoxClose");
      const buildingsToggle = document.getElementById("buildings-toggle");
      const searchBtn = document.getElementById('searchBtn');
      const searchPanel = document.getElementById('searchPanel');
      const searchInput = document.getElementById('searchInput');
      const searchResults = document.getElementById('searchResults');
      const navigationPanel = document.getElementById('navigationPanel');
      const navigationContent = document.getElementById('navigationContent');
      const navigationClose = document.getElementById('navigationClose');

      // Komunikaty błędów
      const messages = {
        permissionDenied: "Dostęp do lokalizacji został zablokowany. Zmień ustawienia przeglądarki, aby umożliwić geolokalizację.",
        notAvailable: "Nie można określić Twojej lokalizacji. Upewnij się, że usługi lokalizacji są włączone.",
        timeout: "Przekroczono czas oczekiwania na lokalizację. Spróbuj ponownie.",
        default: "Wystąpił błąd podczas określania lokalizacji. Spróbuj odświeżyć stronę."
      };

      // Zmienne stanu
      let trafficIncidentsLayer = null;
      let userLocationMarker = null;
      let userAccuracyCircle = null;
      let userWatchId = null;
      let userHeading = 0;
      let lastPosition = null;
      let lastPositionTimestamp = 0;
      let headingTimeout = null;
      let mapRotationEnabled = true;
      let autoCenteringEnabled = true;
      let isMapCentered = false;
      let lastMapMoveTime = 0;
      let userMovedMap = false;
      let buildings3DEnabled = false;
      
      // Zmienne dla płynnego ruchu
      let animationFrameId = null;
      let targetPosition = null;
      let currentAnimatedPosition = null;
      let lastHeadingUpdateTime = 0;
      let headingChangeRate = 0;
      let lastUpdateTime = 0;

      // Zmienne dla nawigacji
      let currentRoute = null;
      let currentStep = 0;
      let routeUpdateInterval = null;

      // Obsługa ruchu drogowego
      trafficToggle.addEventListener("change", () => {
        if (trafficToggle.checked) {
          map.showTrafficFlow();
        } else {
          map.hideTrafficFlow();
        }
      });

      // Obsługa budynków 3D
      buildingsToggle.addEventListener("change", () => {
        if (buildingsToggle.checked) {
          if (!buildings3DEnabled) {
            map.set3DBuildings(true);
            buildings3DEnabled = true;
            
            // Ustaw odpowiedni pitch dla lepszego widoku 3D
            map.easeTo({
              pitch: 45,
              duration: 1000
            });
          }
        } else if (buildings3DEnabled) {
          map.set3DBuildings(false);
          buildings3DEnabled = false;
          
          // Przywróć płaski widok
          map.easeTo({
            pitch: 0,
            duration: 1000
          });
        }
      });

      // Obsługa panelu ustawień
      settingsBtn.addEventListener("click", () => {
        settingsPanel.style.display =
          settingsPanel.style.display === "block" ? "none" : "block";
      });

      // Obsługa przełącznika rotacji
      rotationToggle.addEventListener("change", () => {
        mapRotationEnabled = rotationToggle.checked;
        
        // Jeśli wyłączono rotację, zresetuj orientację mapy
        if (!mapRotationEnabled && isMapCentered) {
          map.easeTo({
            bearing: 0,
            pitch: 0,
            duration: 500
          });
        } else if (mapRotationEnabled && isMapCentered && userHeading !== null) {
          // Włączono rotację i znamy kierunek - obróć mapę
          map.easeTo({
            bearing: userHeading,
            duration: 500
          });
        }
      });

      // Obsługa incydentów drogowych
      incidentsCheckbox.addEventListener("change", () => {
        if (incidentsCheckbox.checked) {
          if (!trafficIncidentsLayer) {
            // Tworzenie warstwy incydentów drogowych
            trafficIncidentsLayer = new tt.VectorTileLayer({
              key: apiKey,
              style: "tomtom://vector/incident",
              refresh: 30000, // Odświeżanie co 30 sekund
              minZoom: 5,
              maxZoom: 19,
              language: 'pl-PL'
            });

            // Dodaj warstwę do mapy
            map.addLayer(trafficIncidentsLayer);

            // Dodaj obsługę kliknięcia w incydent
            map.on('click', 'incidents', (e) => {
              if (e.features.length > 0) {
                const incident = e.features[0].properties;
                const coordinates = e.features[0].geometry.coordinates.slice();
                const description = incident.description || 'Brak opisu';
                const type = incident.type || 'Nieznany typ';
                const severity = incident.severity || 'Nieznana ważność';

                // Utwórz popup z informacjami o incydencie
                new tt.Popup()
                  .setLngLat(coordinates)
                  .setHTML(`
                    <div style="padding: 10px;">
                      <h3 style="margin: 0 0 5px 0;">${type}</h3>
                      <p style="margin: 0 0 5px 0;"><strong>Opis:</strong> ${description}</p>
                      <p style="margin: 0;"><strong>Ważność:</strong> ${severity}</p>
                    </div>
                  `)
                  .addTo(map);
              }
            });

            // Zmień kursor przy najechaniu na incydent
            map.on('mouseenter', 'incidents', () => {
              map.getCanvas().style.cursor = 'pointer';
            });

            map.on('mouseleave', 'incidents', () => {
              map.getCanvas().style.cursor = '';
            });

            // Dodaj legendę incydentów
            const legend = document.createElement('div');
            legend.id = 'incidents-legend';
            legend.style.display = 'none';
            legend.style.position = 'absolute';
            legend.style.bottom = '30px';
            legend.style.left = '10px';
            legend.style.backgroundColor = 'white';
            legend.style.padding = '10px';
            legend.style.borderRadius = '4px';
            legend.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
            legend.style.zIndex = '1';
            legend.innerHTML = `
              <h4 style="margin: 0 0 10px 0;">Legenda incydentów</h4>
              <div style="display: grid; grid-template-columns: auto 1fr; gap: 5px; align-items: center;">
                <span style="display: inline-block; width: 10px; height: 10px; background: #ff0000; border-radius: 50%;"></span>
                <span>Wypadek</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ffa500; border-radius: 50%;"></span>
                <span>Zatłoczenie</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ffff00; border-radius: 50%;"></span>
                <span>Roboty drogowe</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ff00ff; border-radius: 50%;"></span>
                <span>Uszkodzony pojazd</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #00ffff; border-radius: 50%;"></span>
                <span>Zamknięty pas</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #000000; border-radius: 50%;"></span>
                <span>Zamknięta droga</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ff4500; border-radius: 50%;"></span>
                <span>Zagrożenie na drodze</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #800080; border-radius: 50%;"></span>
                <span>Wydarzenie planowane</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #4169e1; border-radius: 50%;"></span>
                <span>Zła pogoda</span>
              </div>
            `;
            document.body.appendChild(legend);

            // Pokaż/ukryj legendę przy zmianie stanu checkboxa
            incidentsCheckbox.addEventListener('change', () => {
              legend.style.display = incidentsCheckbox.checked ? 'block' : 'none';
            });
          }
        } else if (trafficIncidentsLayer) {
          map.removeLayer(trafficIncidentsLayer);
          trafficIncidentsLayer = null;
          
          // Ukryj legendę
          const legend = document.getElementById('incidents-legend');
          if (legend) {
            legend.style.display = 'none';
          }
        }
      });

      // Obsługa wyszukiwania
      searchBtn.addEventListener('click', () => {
        searchPanel.style.display = searchPanel.style.display === 'block' ? 'none' : 'block';
        if (searchPanel.style.display === 'block') {
          searchInput.focus();
        }
      });

      // Autocomplete dla wyszukiwania
      let searchTimeout;
      searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value;
        
        if (query.length < 3) {
          searchResults.innerHTML = '';
          return;
        }

        searchTimeout = setTimeout(() => {
          tt.services.fuzzySearch({
            key: apiKey,
            query: query,
            language: 'pl-PL',
            limit: 5
          })
          .then(response => {
            searchResults.innerHTML = '';
            response.results.forEach(result => {
              const div = document.createElement('div');
              div.className = 'search-result-item';
              div.textContent = result.address.freeformAddress;
              div.addEventListener('click', () => {
                selectDestination(result.position);
                searchPanel.style.display = 'none';
              });
              searchResults.appendChild(div);
            });
          })
          .catch(error => {
            console.error('Błąd wyszukiwania:', error);
          });
        }, 300);
      });

      // Obliczanie kursu na podstawie dwóch pozycji GPS
      function calculateHeading(lat1, lon1, lat2, lon2) {
        const toRad = (value) => (value * Math.PI) / 180;
        const toDeg = (value) => (value * 180) / Math.PI;
        
        const dLon = toRad(lon2 - lon1);
        const y = Math.sin(dLon) * Math.cos(toRad(lat2));
        const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
                Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
        
        let bearing = toDeg(Math.atan2(y, x));
        bearing = (bearing + 360) % 360;
        
        return bearing;
      }

      // Wybór celu i rozpoczęcie nawigacji
      function selectDestination(position) {
        if (!userLocationMarker) {
          displayErrorMessage('Najpierw włącz lokalizację GPS');
          return;
        }

        const start = userLocationMarker.getLngLat();
        const destination = position;

        // Dodaj markery
        if (window.destinationMarker) {
          window.destinationMarker.remove();
        }
        
        window.destinationMarker = new tt.Marker({
          rotationAlignment: 'viewport',
          pitchAlignment: 'viewport'
        })
          .setLngLat([destination.lng, destination.lat])
          .addTo(map);

        // Wyśrodkuj mapę, aby zobaczyć obie lokalizacje
        const bounds = new tt.LngLatBounds()
          .extend([start.lng, start.lat])
          .extend([destination.lng, destination.lat]);
          
        map.fitBounds(bounds, { padding: 100 });

        // Opcje routingu
        const routeOptions = {
          key: apiKey,
          traffic: true,
          travelMode: 'car',
          language: 'pl-PL',
          instructionsType: 'text',
          locations: `${start.lng},${start.lat}:${destination.lng},${destination.lat}`
        };

        // Pobierz trasę
        fetch(`https://api.tomtom.com/routing/1/calculateRoute/${start.lat},${start.lng}:${destination.lat},${destination.lng}/json?key=${apiKey}&traffic=true&instructionsType=text&language=pl-PL&travelMode=car`)
          .then(response => response.json())
          .then(routeData => {
            // Wyczyść poprzednią trasę
            if (window.routeLayer) {
              map.removeLayer('route');
              map.removeSource('route');
            }

            // Ustaw aktualną trasę
            currentRoute = routeData.routes[0];
            currentStep = 0;

            // Wyświetl trasę na mapie
            const routeGeoJson = {
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'LineString',
                coordinates: routeData.routes[0].legs[0].points.map(point => 
                  [point.longitude, point.latitude]
                )
              }
            };

            if (map.getSource('route')) {
              map.getSource('route').setData(routeGeoJson);
            } else {
              map.addSource('route', {
                type: 'geojson',
                data: routeGeoJson
              });

              map.addLayer({
                id: 'route',
                type: 'line',
                source: 'route',
                layout: {
                  'line-join': 'round',
                  'line-cap': 'round'
                },
                paint: {
                  'line-color': '#4CAF50',
                  'line-width': 6
                }
              });

              window.routeLayer = true;
            }

            // Pokaż nawigację
            showNavigation();
            startRouteUpdates();
          })
          .catch(error => {
            console.error('Błąd pobierania trasy:', error);
            displayErrorMessage('Nie udało się zaplanować trasy');
          });
      }

      // Wyświetlanie nawigacji
      function showNavigation() {
        if (!currentRoute || !currentRoute.guidance || !currentRoute.guidance.instructions) {
          console.error("Brak instrukcji nawigacji", currentRoute);
          return;
        }

        const instructions = currentRoute.guidance.instructions;
        if (currentStep >= instructions.length) {
          console.error("Indeks instrukcji poza zakresem", currentStep, instructions.length);
          return;
        }

        const step = instructions[currentStep];
        const nextStep = currentStep + 1 < instructions.length ? instructions[currentStep + 1] : null;
        const distance = step.routeOffsetInMeters;
        const eta = new Date(Date.now() + currentRoute.summary.travelTimeInSeconds * 1000);

        let icon = 'fa-arrow-right';
        let maneuver = step.message.toLowerCase();
        
        if (maneuver.includes('rondo')) {
          icon = 'fa-circle-notch';
        } else if (maneuver.includes('lewo')) {
          icon = 'fa-arrow-left';
        } else if (maneuver.includes('prawo')) {
          icon = 'fa-arrow-right';
        } else if (maneuver.includes('prosto')) {
          icon = 'fa-arrow-up';
        } else if (maneuver.includes('zawróć')) {
          icon = 'fa-arrow-down';
        }

        navigationContent.innerHTML = `
          <div class="navigation-step">
            <div class="navigation-icon">
              <i class="fas ${icon}"></i>
            </div>
            <div class="navigation-info">
              <div>${step.message}</div>
              <div class="navigation-distance">${distance} m</div>
              <div class="navigation-eta">ETA: ${eta.toLocaleTimeString()}</div>
            </div>
          </div>
        `;

        navigationPanel.style.display = 'block';
      }

      // Aktualizacja nawigacji
      function startRouteUpdates() {
        if (routeUpdateInterval) {
          clearInterval(routeUpdateInterval);
        }

        routeUpdateInterval = setInterval(() => {
          if (!userLocationMarker || !currentRoute || !currentRoute.guidance || !currentRoute.guidance.instructions) return;

          const currentPosition = userLocationMarker.getLngLat();
          const instructions = currentRoute.guidance.instructions;
          
          if (currentStep >= instructions.length) return;
          
          const step = instructions[currentStep];
          
          // Sprawdź czy użytkownik zbliża się do następnego kroku
          if (step.point && step.point.latitude && step.point.longitude) {
            const distanceToNextPoint = calculateDistance(
              currentPosition.lat,
              currentPosition.lng,
              step.point.latitude,
              step.point.longitude
            );
            
            // Jeśli jesteśmy blisko następnego punktu nawigacji (20 metrów)
            if (distanceToNextPoint < 20) {
              currentStep++;
              
              // Sprawdź czy to koniec trasy
              if (currentStep >= instructions.length) {
                clearInterval(routeUpdateInterval);
                navigationPanel.style.display = 'none';
                displayErrorMessage('Dotarłeś do celu!');
                
                // Usuń trasę z mapy
                if (window.routeLayer) {
                  map.removeLayer('route');
                  map.removeSource('route');
                  window.routeLayer = false;
                }
                
                // Usuń marker celu
                if (window.destinationMarker) {
                  window.destinationMarker.remove();
                  window.destinationMarker = null;
                }
              } else {
                showNavigation();
              }
            } else {
              // Aktualizuj odległość w panelu nawigacyjnym
              const distanceElement = document.querySelector('.navigation-distance');
              if (distanceElement) {
                distanceElement.textContent = `${Math.round(distanceToNextPoint)} m`;
              }
              
              // Aktualizuj ETA
              const etaElement = document.querySelector('.navigation-eta');
              if (etaElement) {
                const remainingTime = currentRoute.summary.travelTimeInSeconds;
                const eta = new Date(Date.now() + remainingTime * 1000);
                etaElement.textContent = `ETA: ${eta.toLocaleTimeString()}`;
              }
            }
          }
        }, 1000);
      }

      // Obliczanie odległości między punktami
      function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3;
        const φ1 = lat1 * Math.PI/180;
        const φ2 = lat2 * Math.PI/180;
        const Δφ = (lat2-lat1) * Math.PI/180;
        const Δλ = (lon2-lon1) * Math.PI/180;

        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        return R * c;
      }

      // Zamykanie nawigacji
      navigationClose.addEventListener('click', () => {
        navigationPanel.style.display = 'none';
        if (routeUpdateInterval) {
          clearInterval(routeUpdateInterval);
        }
        currentRoute = null;
      });

      // Obsługa geolokalizacji
      function startUserLocationTracking() {
        if (!navigator.geolocation) {
          displayErrorMessage("Twoja przeglądarka nie obsługuje geolokalizacji.");
          return;
        }

        // Obsługa zdarzenia zoom - ważna dla stabilności markerów
        map.on('zoom', handleZoom);
        map.on('move', handleMapMove);
        map.on('moveend', handleMapMoveEnd);

        // Opcje geolokalizacji z maksymalną dokładnością
        const options = {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 10000
        };

        // Rozpocznij śledzenie lokalizacji
        userWatchId = navigator.geolocation.watchPosition(
          updateUserLocation,
          handleLocationError,
          options
        );
        
        // Domyślnie włączamy obrót mapy
        mapRotationEnabled = true;
        rotationToggle.checked = true;
      }

      // Obsługa zmiany zooma mapy
      function handleZoom() {
        // Tylko aktualizujemy rozmiar okręgu dokładności
        if (userAccuracyCircle && userAccuracyCircle.getElement() && window.lastAccuracy) {
          const pixelSize = window.lastAccuracy / 0.075 / Math.pow(2, map.getZoom());
          userAccuracyCircle.getElement().style.width = `${pixelSize}px`;
          userAccuracyCircle.getElement().style.height = `${pixelSize}px`;
        }
      }

      // Obsługa ruchu mapy
      function handleMapMove(e) {
        if (e.originalEvent) {
          lastMapMoveTime = Date.now();
          userMovedMap = true;
          isMapCentered = false;
          updateCenterButtonVisibility();
        }
      }

      // Obsługa zakończenia ruchu mapy
      function handleMapMoveEnd() {
        // Stabilizacja pozycji markerów po zakończeniu ruchu mapy
        if (userLocationMarker && lastPosition) {
          userLocationMarker.setLngLat([lastPosition[0], lastPosition[1]]);
        }
        
        if (userAccuracyCircle && lastPosition) {
          userAccuracyCircle.setLngLat([lastPosition[0], lastPosition[1]]);
        }
      }

      // Płynne aktualizowanie pozycji markera
      function animatePositionUpdate() {
        if (!targetPosition || !userLocationMarker) {
          animationFrameId = requestAnimationFrame(animatePositionUpdate);
          return;
        }
        
        const now = Date.now();
        const elapsed = now - lastUpdateTime;
        
        if (!currentAnimatedPosition) {
          currentAnimatedPosition = userLocationMarker.getLngLat();
        }
        
        // Płynna interpolacja pozycji (easing)
        const t = Math.min(1, elapsed / 300); // 300ms dla płynnego przejścia
        const easingT = t * (2 - t); // Funkcja wygładzająca
        
        const newLng = currentAnimatedPosition.lng + (targetPosition.lng - currentAnimatedPosition.lng) * easingT;
        const newLat = currentAnimatedPosition.lat + (targetPosition.lat - currentAnimatedPosition.lat) * easingT;
        
        // Aktualizacja markera
        userLocationMarker.setLngLat([newLng, newLat]);
        
        // Aktualizacja okręgu dokładności
        if (userAccuracyCircle) {
          userAccuracyCircle.setLngLat([newLng, newLat]);
        }
        
        // Płynna aktualizacja obrotu
        if (userHeading !== null && mapRotationEnabled && isMapCentered && !userMovedMap) {
          const currentBearing = map.getBearing();
          const targetBearing = userHeading;
          
          // Oblicz różnicę kątów (uwzględniając przekroczenie 360 stopni)
          let bearingDiff = targetBearing - currentBearing;
          if (bearingDiff > 180) bearingDiff -= 360;
          if (bearingDiff < -180) bearingDiff += 360;
          
          // Płynne przejście do docelowego kąta
          const newBearing = currentBearing + bearingDiff * easingT;
          
          map.setBearing(newBearing);
        }
        
        // Kontynuuj animację, jeśli nadal trwa
        if (t < 1) {
          currentAnimatedPosition = targetPosition;
          targetPosition = null;
          lastUpdateTime = now;
          
          // Kontynuuj nasłuchiwanie
          animationFrameId = requestAnimationFrame(animatePositionUpdate);
        } else {
          // Zakończ animację
          currentAnimatedPosition = targetPosition;
          targetPosition = null;
          lastUpdateTime = now;
          
          // Kontynuuj nasłuchiwanie
          animationFrameId = requestAnimationFrame(animatePositionUpdate);
        }
      }

      // Rozpocznij animację
      function startPositionAnimation() {
        if (!animationFrameId) {
          lastUpdateTime = Date.now();
          animationFrameId = requestAnimationFrame(animatePositionUpdate);
        }
      }

      // Aktualizacja widoku mapy
      function updateMapViewport() {
        // Jeśli mamy trasę, upewnij się, że jest widoczna
        if (window.routeLayer && currentRoute) {
          // Sprawdź, czy jesteśmy w małym zoomie (poniżej 10)
          if (map.getZoom() < 10) {
            // Dostosuj widok, aby pokazać całą trasę
            const bounds = new tt.LngLatBounds();
            
            // Dodaj punkty trasy do granic
            if (currentRoute.legs && currentRoute.legs[0] && currentRoute.legs[0].points) {
              currentRoute.legs[0].points.forEach(point => {
                bounds.extend([point.longitude, point.latitude]);
              });
            }
            
            // Dodaj pozycję użytkownika
            if (lastPosition) {
              bounds.extend(lastPosition);
            }
            
            // Ustaw bounds z odpowiednim paddingiem
            map.fitBounds(bounds, { padding: 50 });
          }
        }
      }

      // Aktualizacja lokalizacji użytkownika
      function updateUserLocation(position) {
        const { latitude, longitude, accuracy, heading } = position.coords;
        
        // Zapisz dokładność do późniejszego użycia
        window.lastAccuracy = accuracy;
        
        if (accuracy > 100) {
          return;
        }

        const userLocation = [longitude, latitude];
        const currentTime = Date.now();

        // Utwórz lub aktualizuj marker lokalizacji
        if (!userLocationMarker) {
          // Tworzenie strzałki jako element DOM
          const el = document.createElement('div');
          el.style.width = '30px';
          el.style.height = '30px';
          el.style.backgroundImage = "url('https://cdn3.iconfinder.com/data/icons/arrows-set-3/100/Arrow23-512.png')";
          el.style.backgroundSize = 'contain';
          el.style.backgroundRepeat = 'no-repeat';
          
          // Utwórz marker TomTom
          userLocationMarker = new tt.Marker({element: el})
            .setLngLat(userLocation)
            .addTo(map);

          // Po pierwszym pobraniu lokalizacji, wycentruj mapę
          map.flyTo({
            center: userLocation,
            zoom: 19,
            duration: 1000,
            bearing: heading || 0
          });
          
          isMapCentered = true;
          userMovedMap = false;
          updateCenterButtonVisibility();
        } else {
          // Aktualizuj pozycję markera
          userLocationMarker.setLngLat(userLocation);
        }

        // Aktualizacja kierunku - obracamy mapę, nie marker
        if (heading !== null && heading !== undefined) {
          userHeading = heading;
        } else if (lastPosition && (currentTime - lastPositionTimestamp) > 200) {
          if (calculateDistance(lastPosition[1], lastPosition[0], latitude, longitude) > 2) {
            const calculatedHeading = calculateHeading(
              lastPosition[1], lastPosition[0], 
              latitude, longitude
            );
            userHeading = calculatedHeading;
          }
        }

        // Zapisz aktualną pozycję
        lastPosition = [longitude, latitude];
        lastPositionTimestamp = currentTime;

        // Aktualizuj okrąg dokładności
        updateAccuracyCircle(userLocation, accuracy);

        // Aktualizuj obrót mapy aby strzałka pokazywała w górę
        if (isMapCentered && !userMovedMap && mapRotationEnabled && userHeading !== null) {
          map.easeTo({
            center: userLocation,
            bearing: userHeading,
            duration: 300
          });
        }
      }

      // Aktualizacja okręgu dokładności
      function updateAccuracyCircle(userLocation, accuracy) {
        if (!userAccuracyCircle) {
          // Utwórz element DOM dla okręgu dokładności
          const el = document.createElement('div');
          el.className = 'user-accuracy-circle';
          
          userAccuracyCircle = new tt.Marker({
            element: el,
            anchor: 'center'
          })
            .setLngLat(userLocation)
            .addTo(map);
          
          // Upewnij się, że okrąg jest pod markerem
          userAccuracyCircle.getElement().style.zIndex = "90";
        } else {
          userAccuracyCircle.setLngLat(userLocation);
        }

        // Ustaw rozmiar okręgu dokładności
        if (userAccuracyCircle.getElement()) {
          const pixelSize = accuracy / 0.075 / Math.pow(2, map.getZoom());
          userAccuracyCircle.getElement().style.width = `${pixelSize}px`;
          userAccuracyCircle.getElement().style.height = `${pixelSize}px`;
        }
      }

      // Obsługa błędów geolokalizacji
      function handleLocationError(error) {
        console.error('Błąd geolokalizacji:', error);
        
        switch (error.code) {
          case error.PERMISSION_DENIED:
            displayErrorMessage(messages.permissionDenied);
            break;
          case error.POSITION_UNAVAILABLE:
            displayErrorMessage(messages.notAvailable);
            break;
          case error.TIMEOUT:
            displayErrorMessage(messages.timeout);
            break;
          default:
            displayErrorMessage(messages.default);
        }

        // Spróbuj ponownie po 5 sekundach
        setTimeout(() => {
          if (userWatchId === null) {
            startUserLocationTracking();
          }
        }, 5000);
      }

      // Wyświetlanie komunikatu o błędzie
      function displayErrorMessage(message) {
        messageBoxContent.textContent = message;
        messageBox.removeAttribute('hidden');
        
        // Dodaj przycisk "Spróbuj ponownie"
        const retryButton = document.createElement('button');
        retryButton.textContent = 'Spróbuj ponownie';
        retryButton.style.marginLeft = '10px';
        retryButton.style.padding = '5px 10px';
        retryButton.style.cursor = 'pointer';
        
        retryButton.onclick = function() {
          messageBox.setAttribute('hidden', true);
          startUserLocationTracking();
        };
        
        // Usuń poprzedni przycisk jeśli istnieje
        const oldButton = messageBox.querySelector('button');
        if (oldButton) {
          oldButton.remove();
        }
        
        messageBox.appendChild(retryButton);
      }

      // Zamykanie komunikatu o błędzie
      messageBoxClose.addEventListener('click', function() {
        messageBox.setAttribute('hidden', true);
      });

      // Obsługa przycisku centrowania
      centerButton.addEventListener('click', function() {
        if (userLocationMarker) {
          const userLocation = userLocationMarker.getLngLat();
          const bearing = mapRotationEnabled ? userHeading : 0;
          
          map.flyTo({
            center: userLocation,
            zoom: 19,
            bearing: bearing,
            duration: 700
          });
          
          isMapCentered = true;
          userMovedMap = false;
          updateCenterButtonVisibility();
        } else {
          startUserLocationTracking();
        }
      });

      // Aktualizacja widoczności przycisku centrowania
      function updateCenterButtonVisibility() {
        if (isMapCentered && !userMovedMap) {
          centerButton.classList.remove('visible');
        } else {
          centerButton.classList.add('visible');
        }
      }

      // Obsługa zmiany widoku mapy
      map.on('move', function(e) {
        if (e.originalEvent) {
          lastMapMoveTime = Date.now();
          userMovedMap = true;
          isMapCentered = false;
          updateCenterButtonVisibility();
        }
      });
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <title>Żółwik Pro</title>
    <link
      rel="stylesheet"
      href="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.25.0/maps/maps.css"
    />
    <script src="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.25.0/maps/maps-web.min.js"></script>
    <script src="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.25.0/services/services-web.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    />
    <style>
      html,
      body,
      #map {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
      }

      .settings-btn {
        position: absolute;
        top: 10px;
        left: 10px;
        background: white;
        border: none;
        padding: 12px;
        font-size: 20px;
        cursor: pointer;
        border-radius: 50%;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .settings-panel {
        display: none;
        position: absolute;
        top: 70px;
        left: 10px;
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 200px;
      }

      .settings-panel label {
        display: flex;
        align-items: center;
        margin-bottom: 12px;
        cursor: pointer;
        font-size: 16px;
      }

      .settings-panel input[type="checkbox"] {
        margin-right: 10px;
        width: 18px;
        height: 18px;
      }

      .center-btn {
        position: fixed;
        bottom: 30px;
        right: 30px;
        background: #0066ff;
        color: white;
        border: none;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        font-size: 24px;
        cursor: pointer;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .center-btn:hover {
        background: #0055dd;
        transform: scale(1.05);
      }

      .message-box {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        padding: 12px 15px;
        border-radius: 8px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 3;
        display: flex;
        align-items: center;
        max-width: 90%;
        width: auto;
      }

      .message-box-content {
        flex-grow: 1;
        font-size: 16px;
      }

      .message-box-close {
        margin-left: 10px;
        cursor: pointer;
        font-size: 20px;
        padding: 0 5px;
      }

      /* Style dla mobilnego UI */
      @media (max-width: 768px) {
        .settings-btn,
        .search-btn,
        .center-btn,
        .favorites-btn,
        .layers-btn {
          width: 55px;
          height: 55px;
          font-size: 24px;
        }

        .settings-panel,
        .search-panel,
        .favorites-panel,
        .layers-panel {
          width: 80%;
          max-width: 300px;
          left: 50%;
          transform: translateX(-50%);
        }

        .navigation-panel {
          bottom: 30px;
          width: 90%;
        }

        .navigation-icon {
          width: 50px;
          height: 50px;
          font-size: 24px;
        }

        .navigation-info {
          font-size: 18px;
        }

        .navigation-distance,
        .navigation-eta {
          font-size: 16px;
        }

        .search-input {
          height: 50px;
          font-size: 18px;
        }

        .search-result-item {
          padding: 15px;
          font-size: 16px;
        }

        .message-box {
          padding: 15px;
          font-size: 18px;
        }
        
        .user-direction-marker {
          width: 40px;
          height: 40px;
        }
        
        .favorite-item, 
        .add-favorite {
          padding: 15px;
          font-size: 18px;
        }
      }

      /* Styl dla strzałki */
      .user-direction-marker {
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        transform-origin: center center;
      }

      /* Efekty dla SVG strzałki */
      .user-direction-marker svg {
        filter: drop-shadow(0px 2px 3px rgba(0, 0, 0, 0.4));
      }

      /* Animacja pulsowania dla strzałki */
      @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
      }

      /* Dodaj animację pulsowania gdy GPS jest niedokładny */
      .low-accuracy .user-direction-marker svg {
        animation: pulse 2s infinite ease-in-out;
      }

      /* Zwiększ rozmiar strzałki na telefonach dla lepszej widoczności */
      @media (max-width: 768px) {
        .user-direction-marker {
          width: 40px;
          height: 40px;
        }
      }

      .user-accuracy-circle {
        background-color: rgba(0, 122, 255, 0.1);
        border: 1px solid rgba(0, 122, 255, 0.3);
        border-radius: 50%;
      }

      /* Dodatkowe style dla małych ekranów */
      @media (max-width: 480px) {
        .settings-panel {
          width: 200px;
        }

        .message-box {
          width: 85%;
        }
      }

      /* Style dla wyszukiwarki */
      .search-btn {
        position: absolute;
        top: 10px;
        left: 60px;
        background: white;
        border: none;
        padding: 12px;
        font-size: 20px;
        cursor: pointer;
        border-radius: 50%;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .search-panel {
        display: none;
        position: absolute;
        top: 70px;
        left: 60px;
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 300px;
      }

      .search-input {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 16px;
        margin-bottom: 10px;
      }

      .search-results {
        max-height: 300px;
        overflow-y: auto;
      }

      .search-result-item {
        padding: 10px;
        cursor: pointer;
        border-bottom: 1px solid #eee;
      }

      .search-result-item:hover {
        background-color: #f5f5f5;
      }

      /* Style dla nawigacji */
      .navigation-panel {
        display: none;
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 90%;
        max-width: 400px;
      }

      .navigation-step {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }

      .navigation-icon {
        width: 40px;
        height: 40px;
        background: #4CAF50;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 10px;
        color: white;
        font-size: 20px;
      }

      .navigation-info {
        flex-grow: 1;
      }

      .navigation-distance {
        font-size: 14px;
        color: #666;
      }

      .navigation-eta {
        font-size: 14px;
        color: #666;
        margin-top: 5px;
      }

      .navigation-close {
        position: absolute;
        top: 10px;
        right: 10px;
        cursor: pointer;
        font-size: 20px;
      }

      @media (max-width: 768px) {
        .search-panel {
          width: calc(100% - 40px);
          right: 20px;
        }

        .navigation-panel {
          width: calc(100% - 40px);
        }
      }

      /* Style dla ulubionych miejsc */
      .favorites-btn {
        position: absolute;
        top: 10px;
        left: 110px;
        background: white;
        border: none;
        padding: 12px;
        font-size: 20px;
        cursor: pointer;
        border-radius: 50%;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .favorites-panel {
        display: none;
        position: absolute;
        top: 70px;
        left: 110px;
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 250px;
      }

      .favorites-list {
        max-height: 300px;
        overflow-y: auto;
      }

      .favorite-item {
        padding: 10px;
        margin-bottom: 5px;
        border-radius: 5px;
        background-color: #f5f5f5;
        cursor: pointer;
        position: relative;
      }

      .favorite-item:hover {
        background-color: #e5e5e5;
      }

      .favorite-item .delete-btn {
        position: absolute;
        right: 5px;
        top: 50%;
        transform: translateY(-50%);
        color: #ff0000;
        background: none;
        border: none;
        cursor: pointer;
        font-size: 16px;
      }

      .add-favorite {
        margin-top: 10px;
        padding: 8px 12px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        width: 100%;
      }

      /* Style dla legendy */
      .map-features-legend {
        position: absolute;
        bottom: 30px;
        right: 10px;
        background: white;
        padding: 10px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        max-width: 250px;
        display: none;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
      }

      .legend-color {
        width: 15px;
        height: 15px;
        border-radius: 50%;
        margin-right: 10px;
      }

      .legend-title {
        margin: 0 0 10px 0;
        font-weight: bold;
      }

      /* Style dla warstw */
      .layers-btn {
        position: absolute;
        top: 10px;
        left: 160px;
        background: white;
        border: none;
        padding: 12px;
        font-size: 20px;
        cursor: pointer;
        border-radius: 50%;
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .layers-panel {
        display: none;
        position: absolute;
        top: 70px;
        left: 160px;
        background: white;
        padding: 15px;
        border-radius: 10px;
        font-family: sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2;
        width: 250px;
      }

      .layers-panel label {
        display: flex;
        align-items: center;
        margin-bottom: 12px;
        cursor: pointer;
        font-size: 16px;
      }

      .layers-panel input[type="checkbox"] {
        margin-right: 10px;
        width: 18px;
        height: 18px;
      }

      /* Style dla wskaźnika prędkości */
      .speed-container {
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        z-index: 1000;
      }

      .speed-indicator {
        background-color: #0066ff;
        color: white;
        border-radius: 25px;
        padding: 8px 15px;
        margin-right: 10px;
        font-family: Arial, sans-serif;
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        min-width: 80px;
      }

      .speed-limit {
        background-color: white;
        color: #333;
        border: 2px solid #ff0000;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: Arial, sans-serif;
        font-size: 18px;
        font-weight: bold;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      /* Styl dla wskaźnika na telefonie */
      @media (max-width: 768px) {
        .speed-container {
          bottom: 120px;
        }

        .speed-indicator {
          font-size: 28px;
          padding: 10px 20px;
        }

        .speed-limit {
          width: 60px;
          height: 60px;
          font-size: 22px;
        }
      }

      /* Make sure UI elements stay visible in fullscreen mode */
      .mapboxgl-ctrl-fullscreen,
      .mapboxgl-canvas.mapboxgl-canvas-container--fullscreen,
      .mapboxgl-map.mapboxgl-fullscreen-ancestor {
        z-index: 1; /* Lower z-index than UI elements */
      }

      /* Ensure UI elements stay on top in fullscreen mode */
      .center-btn,
      .settings-btn,
      .search-btn,
      .message-box,
      .speed-container,
      .favorites-btn,
      .layers-btn,
      .settings-panel,
      .favorites-panel,
      .layers-panel,
      .search-panel,
      .navigation-panel,
      .street-info,
      .permanent-search,
      .permanent-speed {
        position: fixed !important; /* Use !important to override any inline styles */
        z-index: 9999 !important; /* Very high z-index to ensure visibility */
        pointer-events: auto !important; /* Ensure clicks are captured */
      }
      
      /* Additional styles for fullscreen mode */
      .mapboxgl-map:-webkit-full-screen {
        width: 100% !important;
        height: 100% !important;
      }
      
      .mapboxgl-map:-ms-fullscreen {
        width: 100% !important;
        height: 100% !important;
      }
      
      .mapboxgl-map:fullscreen {
        width: 100% !important;
        height: 100% !important;
      }
      
      /* Fix for navigation controls in fullscreen */
      .mapboxgl-ctrl-group {
        pointer-events: auto !important;
      }
      
      /* Ensure clickable areas work correctly in fullscreen */
      #map:-webkit-full-screen .mapboxgl-ctrl-top-right,
      #map:-webkit-full-screen .mapboxgl-ctrl-top-left,
      #map:-webkit-full-screen .mapboxgl-ctrl-bottom-right,
      #map:-webkit-full-screen .mapboxgl-ctrl-bottom-left {
        position: fixed !important;
        pointer-events: auto !important;
      }
      
      /* Adjust position for fullscreen mode */
      :fullscreen .speed-container {
        bottom: 30px !important;
        left: 30px !important;
        right: auto !important;
        transform: none !important;
      }
      
      /* Special handling for the fullscreen button itself */
      .tt-fullscreen-button {
        margin-right: 10px;
      }
      
      /* Specific positioning for search panel in fullscreen */
      :fullscreen .search-panel {
        top: 70px !important;
        left: 60px !important;
        display: none; /* Initially hidden */
      }
      
      /* Specific positioning for favorites panel in fullscreen */
      :fullscreen .favorites-panel {
        top: 70px !important;
        left: 110px !important;
        display: none; /* Initially hidden */
      }
      
      /* Specific positioning for layers panel in fullscreen */
      :fullscreen .layers-panel {
        top: 70px !important;
        left: 160px !important;
        display: none; /* Initially hidden */
      }
      
      /* Specific positioning for settings panel in fullscreen */
      :fullscreen .settings-panel {
        top: 70px !important;
        left: 10px !important;
        display: none; /* Initially hidden */
      }

      /* Permanent search box that's always visible at the top */
      .permanent-search {
        position: fixed !important;
        top: 10px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        width: 80% !important;
        max-width: 500px !important;
        background: white !important;
        border-radius: 8px !important;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3) !important;
        z-index: 10000 !important;
        display: none !important; /* Domyślnie ukryte */
        align-items: center !important;
        padding: 5px !important;
      }

      /* Permanent speed indicator */
      .permanent-speed {
        position: fixed !important;
        bottom: 20px !important;
        left: 20px !important;
        display: none !important; /* Domyślnie ukryte */
        align-items: center !important;
        z-index: 10000 !important;
      }

      /* Ensure fullscreen mode displays the permanent search */
      :fullscreen .permanent-search,
      :-webkit-full-screen .permanent-search,
      :-ms-fullscreen .permanent-search,
      :-moz-full-screen .permanent-search {
        display: flex !important;
        top: 10px !important; 
        z-index: 10000 !important;
      }

      /* Ensure permanent speed is visible in fullscreen */
      :fullscreen .permanent-speed,
      :-webkit-full-screen .permanent-speed,
      :-ms-fullscreen .permanent-speed,
      :-moz-full-screen .permanent-speed {
        display: flex !important;
        bottom: 20px !important;
        left: 20px !important;
        z-index: 10000 !important;
      }

      /* Ensures user marker and speed limit are visible */
      :fullscreen .user-direction-marker,
      :-webkit-full-screen .user-direction-marker,
      :-ms-fullscreen .user-direction-marker,
      :-moz-full-screen .user-direction-marker,
      :fullscreen .user-speed-limit,
      :-webkit-full-screen .user-speed-limit,
      :-ms-fullscreen .user-speed-limit,
      :-moz-full-screen .user-speed-limit {
        display: block !important;
        visibility: visible !important;
        z-index: 9999 !important;
      }

      .permanent-search input {
        flex-grow: 1 !important;
        padding: 8px 12px !important;
        border: none !important;
        border-radius: 4px !important;
        font-size: 16px !important;
        outline: none !important;
      }

      .permanent-search button {
        background: #0066ff !important;
        color: white !important;
        border: none !important;
        border-radius: 4px !important;
        padding: 8px 12px !important;
        margin-left: 5px !important;
        cursor: pointer !important;
      }

      /* Permanent speed indicator */
      .permanent-speed {
        position: fixed !important;
        bottom: 20px !important;
        left: 20px !important;
        display: flex !important;
        align-items: center !important;
        z-index: 10000 !important;
      }

      .permanent-speed-value {
        background-color: #0066ff !important;
        color: white !important;
        border-radius: 8px !important;
        padding: 8px 15px !important;
        margin-right: 10px !important;
        font-family: Arial, sans-serif !important;
        font-size: 24px !important;
        font-weight: bold !important;
        text-align: center !important;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3) !important;
        min-width: 80px !important;
      }

      .permanent-speed-limit {
        background-color: white !important;
        color: #333 !important;
        border: 2px solid #ff0000 !important;
        border-radius: 50% !important;
        width: 50px !important;
        height: 50px !important;
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        font-family: Arial, sans-serif !important;
        font-size: 18px !important;
        font-weight: bold !important;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3) !important;
      }

      /* Speed limit near user */
      .user-speed-limit {
        position: absolute;
        top: -45px;
        left: -15px;
        background-color: white;
        color: #333;
        border: 2px solid #ff0000;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: Arial, sans-serif;
        font-size: 12px;
        font-weight: bold;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        z-index: 11000;
      }
    </style>
  </head>

  <body>
    <div id="map" class="map"></div>

    <!-- Permanent search box that's always visible -->
    <div class="permanent-search" id="permanentSearch">
      <input type="text" id="permanentSearchInput" placeholder="Wyszukaj miejsce...">
      <button id="permanentSearchButton"><i class="fas fa-search"></i></button>
    </div>

    <!-- Permanent speed indicator -->
    <!--<div class="permanent-speed" id="permanentSpeed">
      <div class="permanent-speed-value" id="permanentSpeedValue">0 km/h</div>
      <div class="permanent-speed-limit" id="permanentSpeedLimit">50</div>
    </div> -->

    <!-- Przycisk wyszukiwania -->
    <button class="search-btn" id="searchBtn"><i class="fas fa-search"></i></button>

    <!-- Panel wyszukiwania -->
    <div class="search-panel" id="searchPanel">
      <input type="text" class="search-input" id="searchInput" placeholder="Wyszukaj miejsce...">
      <div class="search-results" id="searchResults"></div>
    </div>

    <!-- Panel nawigacji -->
    <div class="navigation-panel" id="navigationPanel">
      <span class="navigation-close" id="navigationClose">&times;</span>
      <div id="navigationContent"></div>
    </div>

    <!-- Przycisk ustawień -->
    <button class="settings-btn"><i class="fas fa-cog"></i></button>

    <!-- Panel ustawień -->
    <div class="settings-panel" id="settingsPanel">
      <label>
        <input type="checkbox" id="flow-toggle" />
        Pokaż ruch drogowy
      </label>
      <label>
        <input id="incidents-toggle" type="checkbox" />
        Pokaż incydenty drogowe
      </label>
      <label>
        <input id="rotation-toggle" type="checkbox" checked />
        Obracaj mapę zgodnie z kierunkiem
      </label>
      <label>
        <input id="buildings-toggle" type="checkbox" />
        Pokaż budynki 3D
      </label>
    </div>

    <!-- Przycisk centrowania -->
    <button class="center-btn" id="centerButton"><i class="fas fa-location-crosshairs"></i></button>

    <!-- Komunikat o błędzie -->
    <div class="message-box" id="messageBox" hidden>
      <div class="message-box-content" id="messageBoxContent"></div>
      <span class="message-box-close" id="messageBoxClose">&times;</span>
    </div>

    <!-- Wskaźnik prędkości -->
    <div class="speed-container" id="speedContainer">
      <div class="speed-indicator" id="speedIndicator">0 km/h</div>
      <div class="speed-limit" id="speedLimit">50</div>
    </div>
    
    <!-- Przycisk ulubionych miejsc -->
    <button class="favorites-btn" id="favoritesBtn"><i class="fas fa-heart"></i></button>

    <!-- Panel ulubionych miejsc -->
    <div class="favorites-panel" id="favoritesPanel">
      <div class="favorites-list" id="favoritesList"></div>
      <button class="add-favorite" id="addFavorite">Dodaj ulubione miejsce</button>
    </div>

    <!-- Przycisk warstw -->
    <button class="layers-btn" id="layersBtn"><i class="fas fa-layer-group"></i></button>

    <!-- Panel warstw -->
    <div class="layers-panel" id="layersPanel">
      <label>
        <input type="checkbox" id="speedcams-toggle" />
        Fotoradary i kontrole prędkości
      </label>
      <label>
        <input type="checkbox" id="roadworks-toggle" />
        Prace drogowe
      </label>
      <label>
        <input type="checkbox" id="poi-toggle" />
        Punkty zainteresowania (POI)
      </label>
      <label>
        <input type="checkbox" id="reports-toggle" />
        Zgłoszenia użytkowników
      </label>
    </div>

    <!-- Legenda -->
    <div class="map-features-legend" id="mapFeaturesLegend">
      <h4 class="legend-title">Legenda</h4>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ff0000;"></div>
        <span>Fotoradar</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ffa500;"></div>
        <span>Kontrola prędkości</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ffff00;"></div>
        <span>Prace drogowe</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ff9900;"></div>
        <span>Kamera drogowa</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #cc0000;"></div>
        <span>Miejsce wypadku</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #0000ff;"></div>
        <span>Ulubione miejsca</span>
      </div>
    </div>

    <script>
      const apiKey = "5sWFmhOgtZG9Aaj19W6LgDwQrwiCFTOG";

      const map = tt.map({
        key: apiKey,
        container: "map",
        center: [21.0122, 52.2297], // Warszawa - tymczasowy punkt startowy
        zoom: 14,
        // style: "tomtom://vector/1/basic-main",
        pitch: 0
      });

      map.addControl(new tt.NavigationControl());
      map.addControl(new tt.FullscreenControl());

      // Uruchom śledzenie lokalizacji od razu po załadowaniu mapy
      window.addEventListener('load', function() {
        setTimeout(() => {
          // Opóźnij trochę uruchomienie geolokalizacji, aby mapa mogła się poprawnie załadować
          startUserLocationTracking();
        }, 1000);
      });

      // Dodaj wyszukiwanie jako kontrolkę
      class SearchControl {
        onAdd(map) {
          this.map = map;
          this.container = document.createElement('div');
          this.container.className = 'mapboxgl-ctrl mapboxgl-ctrl-group search-control';
          this.container.style.background = 'white';
          this.container.style.padding = '5px';
          this.container.style.borderRadius = '4px';
          this.container.style.width = '240px';
          this.container.style.zIndex = '9999'; // Dodaj wysoki z-index
          
          // Stwórz pole wyszukiwania
          const searchBox = document.createElement('div');
          searchBox.style.display = 'flex';
          
          // Pole wejściowe
          const input = document.createElement('input');
          input.type = 'text';
          input.placeholder = 'Wyszukaj miejsce...';
          input.className = 'search-input-control';
          input.style.width = '200px';
          input.style.padding = '8px';
          input.style.border = '1px solid #ccc';
          input.style.borderRadius = '4px';
          input.style.marginRight = '5px';
          
          // Przycisk wyszukiwania
          const button = document.createElement('button');
          button.innerHTML = '<i class="fas fa-search"></i>';
          button.className = 'search-button-control';
          button.style.padding = '8px';
          button.style.background = '#0066ff';
          button.style.color = 'white';
          button.style.border = 'none';
          button.style.borderRadius = '4px';
          button.style.cursor = 'pointer';
          
          // Kontener na wyniki
          const results = document.createElement('div');
          results.className = 'search-results-control';
          results.style.display = 'none';
          results.style.maxHeight = '200px';
          results.style.overflowY = 'auto';
          results.style.marginTop = '5px';
          results.style.background = 'white';
          results.style.borderRadius = '4px';
          results.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
          
          // Event listeners
          input.addEventListener('input', debounce((e) => {
            const query = e.target.value;
            if (query.length < 3) {
              results.style.display = 'none';
              return;
            }
            
            this.performSearch(query, results);
          }, 300));
          
          button.addEventListener('click', () => {
            const query = input.value;
            if (query.length >= 3) {
              this.performSearch(query, results);
            }
          });
          
          // Dodaj komponenty do kontenera
          searchBox.appendChild(input);
          searchBox.appendChild(button);
          this.container.appendChild(searchBox);
          this.container.appendChild(results);
          
          return this.container;
        }
        
        performSearch(query, resultsContainer) {
          resultsContainer.style.display = 'block';
          resultsContainer.innerHTML = '<div style="padding:8px;text-align:center;">Wyszukiwanie...</div>';
          
          tt.services.fuzzySearch({
            key: apiKey,
            query: query,
            language: 'pl-PL',
            limit: 5
          })
          .then(response => {
            resultsContainer.innerHTML = '';
            
            if (response.results && response.results.length > 0) {
              response.results.forEach(result => {
                const item = document.createElement('div');
                item.className = 'search-result-item-control';
                item.style.padding = '8px 12px';
                item.style.borderBottom = '1px solid #eee';
                item.style.cursor = 'pointer';
                item.textContent = result.address.freeformAddress;
                
                item.addEventListener('click', () => {
                  selectDestination(result.position);
                  resultsContainer.style.display = 'none';
                });
                
                item.addEventListener('mouseenter', () => {
                  item.style.backgroundColor = '#f5f5f5';
                });
                
                item.addEventListener('mouseleave', () => {
                  item.style.backgroundColor = 'white';
                });
                
                resultsContainer.appendChild(item);
              });
            } else {
              resultsContainer.innerHTML = '<div style="padding:8px;text-align:center;">Brak wyników</div>';
            }
          })
          .catch(error => {
            resultsContainer.innerHTML = '<div style="padding:8px;text-align:center;color:red;">Błąd wyszukiwania</div>';
            console.error('Search error:', error);
          });
        }
        
        onRemove() {
          this.container.parentNode.removeChild(this.container);
          this.map = undefined;
        }
      }
      
      // Funkcja debounce dla wyszukiwania
      function debounce(func, wait) {
        let timeout;
        return function(...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
        };
      }
      
      // Dodaj kontrolkę wyszukiwania
      const searchControl = new SearchControl();
      map.addControl(searchControl, 'top-left');
      
      // Dodaj kontrolkę prędkości
      class SpeedControl {
        onAdd(map) {
          this.map = map;
          this.container = document.createElement('div');
          this.container.className = 'mapboxgl-ctrl mapboxgl-ctrl-group speed-info-control';
          this.container.style.background = 'white';
          this.container.style.padding = '8px 12px';
          this.container.style.borderRadius = '4px';
          this.container.style.display = 'flex';
          this.container.style.alignItems = 'center';
          this.container.style.justifyContent = 'center';
          this.container.style.minWidth = '120px';
          this.container.style.zIndex = '9999'; // Dodaj wysoki z-index
          
          // Aktualnej prędkości
          this.speedValue = document.createElement('div');
          this.speedValue.className = 'current-speed-control';
          this.speedValue.style.fontSize = '20px';
          this.speedValue.style.fontWeight = 'bold';
          this.speedValue.style.marginRight = '8px';
          this.speedValue.style.color = '#0066ff';
          this.speedValue.textContent = '0 km/h';
          
          // Ograniczenie prędkości
          this.speedLimit = document.createElement('div');
          this.speedLimit.className = 'speed-limit-control';
          this.speedLimit.style.fontSize = '16px';
          this.speedLimit.style.padding = '3px 8px';
          this.speedLimit.style.borderRadius = '50%';
          this.speedLimit.style.border = '2px solid red';
          this.speedLimit.style.background = 'white';
          this.speedLimit.style.color = 'black';
          this.speedLimit.textContent = '50';
          
          this.container.appendChild(this.speedValue);
          this.container.appendChild(this.speedLimit);
          
          // Aktualizuj wartości, jeśli dostępne
          this.updateDisplay();
          
          // Ustaw interwał aktualizacji
          setInterval(() => this.updateDisplay(), 1000);
          
          return this.container;
        }
        
        updateDisplay() {
          // Pobierz aktualną prędkość z istniejących elementów
          const speedIndicator = document.getElementById('speedIndicator');
          const speedLimitElement = document.getElementById('speedLimit');
          
          if (speedIndicator) {
            this.speedValue.textContent = speedIndicator.textContent;
          }
          
          if (speedLimitElement) {
            this.speedLimit.textContent = speedLimitElement.textContent;
          }
        }
        
        onRemove() {
          this.container.parentNode.removeChild(this.container);
          this.map = undefined;
        }
      }
      
      // Dodaj kontrolkę prędkości
      const speedControl = new SpeedControl();
      map.addControl(speedControl, 'top-right');

      // Domyślnie ukryj dodatkowe kontrolki (będą widoczne tylko w trybie pełnoekranowym)
      document.querySelector('.search-control').style.display = 'none';
      document.querySelector('.speed-info-control').style.display = 'none';

      // Funkcja do tworzenia niestandardowej kontrolki
      function createCustomControl(options) {
        const defaultOptions = {
          iconClass: 'fa-solid fa-layer-group',
          title: 'Kontrolka',
          onClick: () => {},
          position: 'top-right'
        };
        
        // Połącz opcje domyślne z przekazanymi
        const controlOptions = {...defaultOptions, ...options};
        
        // Stwórz własną kontrolkę TomTom
        class CustomControl {
          onAdd(map) {
            this.map = map;
            this.container = document.createElement('div');
            this.container.className = 'mapboxgl-ctrl mapboxgl-ctrl-group custom-control';
            
            const button = document.createElement('button');
            button.className = 'custom-control-button';
            button.type = 'button';
            button.title = controlOptions.title;
            button.setAttribute('aria-label', controlOptions.title);
            
            // Dodaj ikonę
            const icon = document.createElement('i');
            icon.className = controlOptions.iconClass;
            button.appendChild(icon);
            
            // Dodaj event listener
            button.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              controlOptions.onClick();
            });
            
            // Style dla przycisku
            button.style.width = '40px';
            button.style.height = '40px';
            button.style.display = 'flex';
            button.style.alignItems = 'center';
            button.style.justifyContent = 'center';
            button.style.border = 'none';
            button.style.background = 'white';
            button.style.cursor = 'pointer';
            
            this.container.appendChild(button);
            return this.container;
          }
          
          onRemove() {
            this.container.parentNode.removeChild(this.container);
            this.map = undefined;
          }
        }
        
        return new CustomControl();
      }

      // Przykład dodania przycisku warstw jako kontrolki
      const layersControl = createCustomControl({
        iconClass: 'fa-solid fa-layer-group',
        title: 'Zarządzaj warstwami',
        onClick: () => {
          // Obsługa kliknięcia przycisku warstw
          const layersPanel = document.getElementById('layersPanel');
          if (layersPanel) {
            const isVisible = layersPanel.style.display === 'block';
            layersPanel.style.display = isVisible ? 'none' : 'block';
          }
        }
      });
      
      // Dodaj kontrolkę do mapy w pozycji domyślnej
      map.addControl(layersControl, 'top-right');
      
      // Przykład dodania przycisku ulubione jako kontrolki
      const favoritesControl = createCustomControl({
        iconClass: 'fa-solid fa-heart',
        title: 'Ulubione miejsca',
        onClick: () => {
          // Obsługa kliknięcia przycisku ulubionych
          const favoritesPanel = document.getElementById('favoritesPanel');
          if (favoritesPanel) {
            const isVisible = favoritesPanel.style.display === 'block';
            favoritesPanel.style.display = isVisible ? 'none' : 'block';
          }
        }
      });
      
      // Dodaj kontrolkę do mapy w pozycji domyślnej
      map.addControl(favoritesControl, 'top-right');
      
      // Dodaj kontrolkę centrowania
      const centerControl = createCustomControl({
        iconClass: 'fa-solid fa-location-crosshairs',
        title: 'Centruj mapę',
        onClick: () => {
          // Centruj mapę na pozycji użytkownika
          if (!userLocationMarker) {
            displayErrorMessage("Uruchamiam śledzenie lokalizacji...");
            startUserLocationTracking();
            return;
          }
          
          const userLocation = userLocationMarker.getLngLat();
          const bearing = mapRotationEnabled ? userHeading || 0 : 0;
          
            map.flyTo({
            center: userLocation,
            zoom: 18,
            bearing: bearing,
            duration: 1000,
            easing: (t) => t * (2 - t) // Funkcja easing dla płynniejszej animacji
          });
          
          isMapCentered = true;
          userMovedMap = false;
        }
      });
      
      // Dodaj kontrolkę do mapy w pozycji bottom-right
      map.addControl(centerControl, 'bottom-right');

      // Obsługa zmiany trybu pełnoekranowego
      map.on('fullscreenchange', function() {
        const isFullscreen = document.fullscreenElement || 
                             document.mozFullScreenElement || 
                             document.webkitFullscreenElement || 
                             document.msFullscreenElement;
        
        console.log('Tryb pełnoekranowy zmieniony:', isFullscreen ? 'włączony' : 'wyłączony');
        
        // Przełączanie widoczności elementów UI
        const permanentSearch = document.getElementById('permanentSearch');
        const permanentSpeed = document.getElementById('permanentSpeed');
        const searchBtn = document.getElementById('searchBtn');
        
        if (permanentSearch) {
          permanentSearch.style.display = isFullscreen ? 'flex' : 'none';
          permanentSearch.style.position = 'fixed';
          permanentSearch.style.zIndex = '10000';
        }
        
        if (permanentSpeed) {
          permanentSpeed.style.display = isFullscreen ? 'flex' : 'none';
          permanentSpeed.style.position = 'fixed';
          permanentSpeed.style.zIndex = '10000';
        }
        
        if (searchBtn) {
          searchBtn.style.display = isFullscreen ? 'none' : 'block';
        }
        
        // Dostosuj elementy UI w trybie pełnoekranowym
        const uiElements = [
          document.getElementById('centerButton'),
          document.getElementById('searchBtn'),
          document.querySelector('.settings-btn'),
          document.getElementById('messageBox'),
          document.getElementById('speedContainer'),
          document.getElementById('favoritesBtn'),
          document.getElementById('layersBtn'),
          document.getElementById('settingsPanel'),
          document.getElementById('favoritesPanel'),
          document.getElementById('layersPanel'),
          document.getElementById('searchPanel'),
          document.getElementById('navigationPanel'),
          document.getElementById('permanentSearch'),
          document.getElementById('permanentSpeed')
        ];
        
        // Upewnij się, że elementy UI pozostają widoczne i klikalne
        uiElements.forEach(element => {
          if (element) {
            // Ustawienie stylu dla trybu pełnoekranowego
            if (isFullscreen) {
              element.style.position = 'fixed';
              element.style.zIndex = '9999';
              element.style.pointerEvents = 'auto';
            } else {
              // Przywróć oryginalne style po wyjściu z pełnego ekranu
              if (element.id !== 'permanentSearch' && element.id !== 'permanentSpeed') {
                element.style.position = '';
                element.style.zIndex = '';
                element.style.pointerEvents = '';
              }
            }
            
            // Dodatkowe dostosowania dla konkretnych elementów
            if (element === document.getElementById('speedContainer') && isFullscreen) {
              // Przesuń wskaźnik prędkości do lewego dolnego rogu
              element.style.bottom = '30px';
              element.style.left = '30px';
              element.style.right = 'auto';
              element.style.transform = 'none';
            } else if (element === document.getElementById('speedContainer') && !isFullscreen) {
              // Przywróć oryginalną pozycję
              element.style.bottom = '100px';
              element.style.left = '50%';
              element.style.right = '';
              element.style.transform = 'translateX(-50%)';
            }
          }
        });
        
        // Wymuszenie odświeżenia uchwytów zdarzeń w trybie pełnoekranowym
        if (isFullscreen) {
          // Upewnij się, że permanent search i speed są widoczne
          const permanentSearch = document.getElementById('permanentSearch');
          const permanentSpeed = document.getElementById('permanentSpeed');
          
          if (permanentSearch) {
            permanentSearch.style.display = 'flex';
            permanentSearch.style.position = 'fixed';
            permanentSearch.style.zIndex = '10000';
            permanentSearch.style.pointerEvents = 'auto';
          }
          
          if (permanentSpeed) {
            permanentSpeed.style.display = 'flex';
            permanentSpeed.style.position = 'fixed';
            permanentSpeed.style.zIndex = '10000';
            permanentSpeed.style.pointerEvents = 'auto';
          }

                                        // Odśwież strzałkę użytkownika
          if (lastPosition) {
            // Jeśli marker nie istnieje, utwórz go ponownie
            if (!userLocationMarker) {
              console.log("Tworzę nowy marker użytkownika w trybie pełnoekranowym");
              createUserMarker(lastPosition[1], lastPosition[0]);
            } 
            // Aktualizuj pozycję istniejącego markera
            else {
              console.log("Aktualizuję marker użytkownika w trybie pełnoekranowym");
              userLocationMarker.setLngLat(lastPosition);
              
              // Upewnij się, że marker jest widoczny
              try {
                const el = userLocationMarker.getElement();
                if (el) {
                  el.style.display = 'block';
                  el.style.visibility = 'visible';
                  el.style.zIndex = '9999';
                  
                  // Ustaw odpowiednią rotację
                  if (userHeading !== null) {
                    el.style.transform = `rotate(${userHeading}deg)`;
                  }
                }
              } catch (error) {
                console.error("Błąd przy aktualizacji elementu markera:", error);
              }
            }
          }
          
          // Ustaw interwał aktualizacji strzałki
          if (!window.arrowUpdateInterval) {
            window.arrowUpdateInterval = setInterval(() => {
              if (userLocationMarker && lastPosition) {
                userLocationMarker.setLngLat(lastPosition);
                try {
                  const el = userLocationMarker.getElement();
                  if (el) {
                    el.style.display = 'block';
                    el.style.visibility = 'visible';
                    el.style.zIndex = '9999';
                    
                    // Ustaw odpowiednią rotację
                    if (userHeading !== null) {
                      el.style.transform = `rotate(${userHeading}deg)`;
                    }
                  }
                } catch (error) {
                  console.error("Błąd przy interwałowej aktualizacji markera:", error);
                }
              }
            }, 500);
          }
          
          // Odświeżenie wszystkich przycisków i paneli
          removeAllEventListeners();
          reattachEventListeners();
          
          // Dodaj dla pewności aktualizator prędkości na interwał
          if (!window.speedUpdateInterval) {
            window.speedUpdateInterval = setInterval(() => {
              if (speedIndicator && currentSpeed !== null) {
                speedIndicator.textContent = Math.round(currentSpeed) + " km/h";
                
                // Aktualizuj również stały wskaźnik prędkości
                const permanentSpeedValue = document.getElementById('permanentSpeedValue');
                const permanentSpeedLimit = document.getElementById('permanentSpeedLimit');
                
                if (permanentSpeedValue) {
                  permanentSpeedValue.textContent = Math.round(currentSpeed) + " km/h";
                  
                  // Zmień kolor w zależności od przekroczenia prędkości
                  if (Math.round(currentSpeed) > currentSpeedLimit) {
                    permanentSpeedValue.style.backgroundColor = "#ff0000";
                  } else {
                    permanentSpeedValue.style.backgroundColor = "#0066ff";
                  }
                }
                
                if (permanentSpeedLimit) {
                  permanentSpeedLimit.textContent = currentSpeedLimit;
                }
              }
            }, 1000);
          }
          
          // Popraw centrowanie mapy
          if (!window.centeringInterval) {
            centerMapOnUser(true);
            
            window.centeringInterval = setInterval(() => {
              if (autoCenteringEnabled && !userMovedMap) {
                centerMapOnUser(false);
              }
            }, 2000);
          }
          
          // Dodaj obsługę zdarzeń kliknięcia dla permanentnego wyszukiwania w trybie fullscreen
          const permanentSearchInput = document.getElementById('permanentSearchInput');
          const permanentSearchButton = document.getElementById('permanentSearchButton');
          
          if (permanentSearchInput) {
            // Najpierw usuń wszystkie stare handlery
            const newPermanentSearchInput = permanentSearchInput.cloneNode(true);
            if (permanentSearchInput.parentNode) {
              permanentSearchInput.parentNode.replaceChild(newPermanentSearchInput, permanentSearchInput);
            }
            
            // Dodaj nowe handlery
            newPermanentSearchInput.addEventListener('keypress', function(e) {
              if (e.key === 'Enter') {
                performSearch(newPermanentSearchInput.value);
              }
            });
          }
          
          if (permanentSearchButton) {
            // Najpierw usuń wszystkie stare handlery
            const newPermanentSearchButton = permanentSearchButton.cloneNode(true);
            if (permanentSearchButton.parentNode) {
              permanentSearchButton.parentNode.replaceChild(newPermanentSearchButton, permanentSearchButton);
            }
            
            // Dodaj nowe handlery
            newPermanentSearchButton.addEventListener('click', function() {
              const input = document.getElementById('permanentSearchInput');
              if (input) {
                performSearch(input.value);
              }
            });
          }
        } else {
          // Wyczyść interwały po wyjściu z trybu pełnoekranowego
          if (window.speedUpdateInterval) {
            clearInterval(window.speedUpdateInterval);
            window.speedUpdateInterval = null;
          }
          
          if (window.arrowUpdateInterval) {
            clearInterval(window.arrowUpdateInterval);
            window.arrowUpdateInterval = null;
          }
          
          if (window.centeringInterval) {
            clearInterval(window.centeringInterval);
            window.centeringInterval = null;
          }
          
          // Odświeżenie wszystkich przycisków i paneli
          removeAllEventListeners();
          reattachEventListeners();
        }
      });

      // Usuń wszystkie nasłuchiwacze zdarzeń
      function removeAllEventListeners() {
        // Przycisk ustawień
        const settingsBtn = document.querySelector(".settings-btn");
        const oldSettingsBtn = settingsBtn;
        if (oldSettingsBtn) {
          const newSettingsBtn = oldSettingsBtn.cloneNode(true);
          if (oldSettingsBtn.parentNode) {
            oldSettingsBtn.parentNode.replaceChild(newSettingsBtn, oldSettingsBtn);
          }
        }
        
        // Przycisk wyszukiwania
        const searchBtn = document.getElementById('searchBtn');
        if (searchBtn) {
          const oldSearchBtn = searchBtn;
          const newSearchBtn = oldSearchBtn.cloneNode(true);
          if (oldSearchBtn.parentNode) {
            oldSearchBtn.parentNode.replaceChild(newSearchBtn, oldSearchBtn);
          }
        }
        
        // Przycisk centrowania
        const centerButton = document.getElementById('centerButton');
        if (centerButton) {
          const oldCenterButton = centerButton;
          const newCenterButton = oldCenterButton.cloneNode(true);
          if (oldCenterButton.parentNode) {
            oldCenterButton.parentNode.replaceChild(newCenterButton, oldCenterButton);
          }
        }
        
        // Przycisk ulubionych
        const favoritesBtn = document.getElementById('favoritesBtn');
        if (favoritesBtn) {
          const oldFavoritesBtn = favoritesBtn;
          const newFavoritesBtn = oldFavoritesBtn.cloneNode(true);
          if (oldFavoritesBtn.parentNode) {
            oldFavoritesBtn.parentNode.replaceChild(newFavoritesBtn, oldFavoritesBtn);
          }
        }
        
        // Przycisk warstw
        const layersBtn = document.getElementById('layersBtn');
        if (layersBtn) {
          const oldLayersBtn = layersBtn;
          const newLayersBtn = oldLayersBtn.cloneNode(true);
          if (oldLayersBtn.parentNode) {
            oldLayersBtn.parentNode.replaceChild(newLayersBtn, oldLayersBtn);
          }
        }
        
        // Przycisk zamknięcia komunikatu
        const messageBoxClose = document.getElementById('messageBoxClose');
        if (messageBoxClose) {
          const oldMessageBoxClose = messageBoxClose;
          const newMessageBoxClose = oldMessageBoxClose.cloneNode(true);
          if (oldMessageBoxClose.parentNode) {
            oldMessageBoxClose.parentNode.replaceChild(newMessageBoxClose, oldMessageBoxClose);
          }
        }
        
        // Przycisk zamknięcia panelu nawigacji
        const navigationClose = document.getElementById('navigationClose');
        if (navigationClose) {
          const oldNavigationClose = navigationClose;
          const newNavigationClose = oldNavigationClose.cloneNode(true);
          if (oldNavigationClose.parentNode) {
            oldNavigationClose.parentNode.replaceChild(newNavigationClose, oldNavigationClose);
          }
        }
      }

      // Ponownie dodaj nasłuchiwacze zdarzeń
      function reattachEventListeners() {
        // Przycisk ustawień
        const settingsBtn = document.querySelector(".settings-btn");
        if (settingsBtn) {
          settingsBtn.addEventListener("click", function() {
            const settingsPanel = document.getElementById("settingsPanel");
            if (settingsPanel) {
              settingsPanel.style.display = settingsPanel.style.display === "block" ? "none" : "block";
            }
          });
        }
        
        // Przycisk wyszukiwania
        const searchBtn = document.getElementById('searchBtn');
        if (searchBtn) {
          searchBtn.addEventListener('click', function() {
            const searchPanel = document.getElementById('searchPanel');
            if (searchPanel) {
              searchPanel.style.display = searchPanel.style.display === 'block' ? 'none' : 'block';
              
              if (searchPanel.style.display === 'block') {
                const searchInput = document.getElementById('searchInput');
                if (searchInput) {
                  searchInput.focus();
                }
              }
            }
          });
        }
        
        // Permanent search box
        const permanentSearchInput = document.getElementById('permanentSearchInput');
        const permanentSearchButton = document.getElementById('permanentSearchButton');
        
        if (permanentSearchInput && permanentSearchButton) {
          // Input on enter
          permanentSearchInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
              performSearch(permanentSearchInput.value);
            }
          });
          
          // Button click
          permanentSearchButton.addEventListener('click', function() {
            performSearch(permanentSearchInput.value);
          });
        }
        
        // Przycisk centrowania
        const centerButton = document.getElementById('centerButton');
        if (centerButton) {
          centerButton.addEventListener('click', function() {
            if (!userLocationMarker) {
              displayErrorMessage("Uruchamiam śledzenie lokalizacji...");
              startUserLocationTracking();
              return;
            }
            
            const userLocation = userLocationMarker.getLngLat();
            const bearing = mapRotationEnabled ? userHeading || 0 : 0;
            
            map.flyTo({
              center: userLocation,
              zoom: 18,
              bearing: bearing,
              duration: 1000,
              easing: (t) => t * (2 - t) // Funkcja easing dla płynniejszej animacji
            });
            
            isMapCentered = true;
            userMovedMap = false;
            
            // Włącz autocentrowanie po kliknięciu przycisku
            autoCenteringEnabled = true;
            displayErrorMessage("Autocentrowanie włączone", 2000);
          });
        }
        
        // Przycisk ulubionych
        const favoritesBtn = document.getElementById('favoritesBtn');
        if (favoritesBtn) {
          favoritesBtn.addEventListener('click', function() {
            const favoritesPanel = document.getElementById('favoritesPanel');
            if (favoritesPanel) {
              favoritesPanel.style.display = favoritesPanel.style.display === 'block' ? 'none' : 'block';
              
              if (favoritesPanel.style.display === 'block') {
                renderFavorites();
              }
            }
          });
        }
        
        // Przycisk warstw
        const layersBtn = document.getElementById('layersBtn');
        if (layersBtn) {
          layersBtn.addEventListener('click', function() {
            const layersPanel = document.getElementById('layersPanel');
            if (layersPanel) {
              layersPanel.style.display = layersPanel.style.display === 'block' ? 'none' : 'block';
            }
          });
        }
        
        // Przycisk zamknięcia komunikatu
        const messageBoxClose = document.getElementById('messageBoxClose');
        const messageBox = document.getElementById('messageBox');
        if (messageBoxClose && messageBox) {
          messageBoxClose.addEventListener('click', function() {
            messageBox.setAttribute('hidden', true);
            if (window.messageHideTimeout) {
              clearTimeout(window.messageHideTimeout);
              window.messageHideTimeout = null;
            }
          });
        }
        
        // Przycisk zamknięcia panelu nawigacji
        const navigationClose = document.getElementById('navigationClose');
        if (navigationClose) {
          navigationClose.addEventListener('click', function() {
            // Zatrzymaj aktualizację trasy
            if (routeUpdateInterval) {
              clearInterval(routeUpdateInterval);
              routeUpdateInterval = null;
            }
            
            // Ukryj panel
            const navigationPanel = document.getElementById('navigationPanel');
            if (navigationPanel) {
              navigationPanel.style.display = 'none';
            }
            
            // Usuń trasę z mapy
            if (map.getLayer('route')) {
              map.removeLayer('route');
            }
            
            if (map.getSource('route')) {
              map.removeSource('route');
            }
            
            // Zresetuj zmienne nawigacji
            currentRoute = null;
            currentStep = 0;
            
            // Powiedz użytkownikowi, że nawigacja została zakończona
            speakInstruction("Nawigacja zakończona");
          });
        }
        
        // Obsługa wyszukiwania
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        if (searchInput && searchResults) {
          let searchTimeout;
          searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            const query = e.target.value;
            
            if (query.length < 3) {
              searchResults.innerHTML = '';
              return;
            }

            searchTimeout = setTimeout(() => {
              tt.services.fuzzySearch({
                key: apiKey,
                query: query,
                language: 'pl-PL',
                limit: 5
              })
              .then(response => {
                searchResults.innerHTML = '';
                response.results.forEach(result => {
                  const div = document.createElement('div');
                  div.className = 'search-result-item';
                  div.textContent = result.address.freeformAddress;
                  div.addEventListener('click', () => {
                    displayErrorMessage("Znaleziono: " + result.address.freeformAddress + ". Uruchamiam nawigację...", 3000);
                    selectDestination(result.position);
                    const searchPanel = document.getElementById('searchPanel');
                    if (searchPanel) {
                      searchPanel.style.display = 'none';
                    }
                  });
                  searchResults.appendChild(div);
                });
              })
              .catch(error => {
                console.error('Błąd wyszukiwania:', error);
              });
            }, 300);
          });
        }
        
        // Obsługa warstw
        const speedcamsToggle = document.getElementById('speedcams-toggle');
        if (speedcamsToggle) {
          speedcamsToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
              loadSpeedCameras();
              const mapFeaturesLegend = document.getElementById('mapFeaturesLegend');
              if (mapFeaturesLegend) {
                mapFeaturesLegend.style.display = 'block';
              }
            } else {
              if (speedcamsLayer) {
                map.removeLayer('speedcams');
                map.removeSource('speedcams');
                speedcamsLayer = null;
              }
              updateLegendVisibility();
            }
          });
        }
        
        const roadworksToggle = document.getElementById('roadworks-toggle');
        if (roadworksToggle) {
          roadworksToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
              loadRoadworks();
              const mapFeaturesLegend = document.getElementById('mapFeaturesLegend');
              if (mapFeaturesLegend) {
                mapFeaturesLegend.style.display = 'block';
              }
            } else {
              if (roadworksLayer) {
                map.removeLayer('roadworks');
                map.removeSource('roadworks');
                roadworksLayer = null;
              }
              updateLegendVisibility();
            }
          });
        }
        
        const poiToggle = document.getElementById('poi-toggle');
        if (poiToggle) {
          poiToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
              loadPointsOfInterest();
            } else {
              if (poiLayer) {
                map.removeLayer('pois');
                map.removeSource('pois');
                poiLayer = null;
              }
            }
          });
        }
        
        const reportsToggle = document.getElementById('reports-toggle');
        if (reportsToggle) {
          reportsToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
              if (lastPosition) {
                loadReportsFromOverpass(lastPosition[1], lastPosition[0]);
              } else {
                displayErrorMessage('Najpierw włącz lokalizację GPS');
                e.target.checked = false;
              }
            } else {
              if (reportsLayer) {
                map.removeLayer('reports');
                map.removeSource('reports');
                reportsLayer = null;
              }
            }
          });
        }
        
        // Obsługa rotacji
        const rotationToggle = document.getElementById('rotation-toggle');
        if (rotationToggle) {
          rotationToggle.addEventListener('change', () => {
            mapRotationEnabled = rotationToggle.checked;
            
            // Jeśli wyłączono rotację, zresetuj orientację mapy
            if (!mapRotationEnabled && isMapCentered) {
              map.easeTo({
                bearing: 0,
                pitch: 0,
                duration: 500
              });
            } else if (mapRotationEnabled && isMapCentered && userHeading !== null) {
              // Włączono rotację i znamy kierunek - obróć mapę
              map.easeTo({
                bearing: userHeading,
                duration: 500
              });
            }
          });
        }
        
        // Obsługa budynków 3D
        const buildingsToggle = document.getElementById('buildings-toggle');
        if (buildingsToggle) {
          buildingsToggle.addEventListener("change", () => {
            if (buildingsToggle.checked) {
              if (!buildings3DEnabled) {
                map.set3DBuildings(true);
                buildings3DEnabled = true;
                
                // Ustaw odpowiedni pitch dla lepszego widoku 3D
                map.easeTo({
                  pitch: 45,
              duration: 1000
            });
              }
            } else if (buildings3DEnabled) {
              map.set3DBuildings(false);
              buildings3DEnabled = false;
              
              // Przywróć płaski widok
              map.easeTo({
                pitch: 0,
                duration: 1000
              });
            }
          });
        }
        
        // Obsługa ruchu drogowego
        const trafficToggle = document.getElementById("flow-toggle");
        if (trafficToggle) {
          trafficToggle.addEventListener("change", () => {
            if (trafficToggle.checked) {
              map.showTrafficFlow();
            } else {
              map.hideTrafficFlow();
            }
          });
        }
        
        // Obsługa dodawania ulubionych
        const addFavorite = document.getElementById('addFavorite');
        if (addFavorite) {
          addFavorite.addEventListener('click', () => {
            if (!userLocationMarker) {
              displayErrorMessage('Najpierw włącz lokalizację GPS');
              return;
            }

            const position = userLocationMarker.getLngLat();
            const name = prompt('Nazwa ulubionego miejsca:');
            
            if (!name) return;
            
            const favorite = {
              id: Date.now().toString(),
              name,
              position: {
                lat: position.lat,
                lng: position.lng
              }
            };
            
            favoriteLocations.push(favorite);
            localStorage.setItem('favoriteLocations', JSON.stringify(favoriteLocations));
            
            renderFavorites();
            updateFavoritesOnMap();
          });
        }
        
        console.log("Ponownie przypisano nasłuchiwacze zdarzeń");
      }

      // Funkcja do centrowania mapy na użytkowniku
      function centerMapOnUser(smooth = false) {
        if (!userLocationMarker || !lastPosition) return;
        
        const bearing = mapRotationEnabled ? userHeading || 0 : 0;
        
        if (smooth) {
          map.easeTo({
            center: lastPosition,
            bearing: bearing,
            duration: 500
          });
        } else {
          map.flyTo({
            center: lastPosition,
            zoom: 18,
            bearing: bearing,
            duration: 1000
          });
        }
        
        isMapCentered = true;
        userMovedMap = false;
      }

      // Aktualizacja wskaźnika prędkości
      function updateSpeedIndicator(speed, latitude, longitude) {
        // Przelicz prędkość z m/s na km/h
        if (speed !== null && speed !== undefined) {
          currentSpeed = speed * 3.6; // konwersja z m/s na km/h
          const speedKmh = Math.round(currentSpeed);
          
          // Aktualizuj wskaźnik prędkości
          if (speedIndicator) {
            speedIndicator.textContent = speedKmh + " km/h";
            
            // Zmień kolor w zależności od przekroczenia prędkości
            if (speedKmh > currentSpeedLimit) {
              speedIndicator.style.backgroundColor = "#ff0000";
            } else {
              speedIndicator.style.backgroundColor = "#0066ff";
            }
          }
          
          lastSpeedUpdate = Date.now();
        } else if (Date.now() - lastSpeedUpdate > 5000) {
          // Jeśli nie ma aktualizacji prędkości przez 5 sekund, pokaż 0
          currentSpeed = 0;
          if (speedIndicator) {
            speedIndicator.textContent = "0 km/h";
            speedIndicator.style.backgroundColor = "#0066ff";
          }
        }
      }

      // Funkcja aktualizująca rzeczywiste ograniczenie prędkości
      function updateRealSpeedLimit(latitude, longitude) {
        // W rzeczywistej aplikacji użylibyśmy API do pobierania ograniczeń prędkości
        // Tu symulujemy to na podstawie losowych wartości z predefiniowanymi ograniczeniami
        
        // Pobierz aktualny timestamp
        const now = Date.now();
        
        // Aktualizuj ograniczenie prędkości tylko co 10 sekund
        if (now - window.lastSpeedLimitUpdate < 10000) {
          return;
        }
        
        window.lastSpeedLimitUpdate = now;
        
        // Symulowane ograniczenia prędkości
        const speedLimits = [30, 40, 50, 70, 90, 120];
        
        // Losowo wybierz ograniczenie, ale z większą szansą na 50 km/h
        const rand = Math.random();
        let newLimit;
        
        if (rand < 0.6) {
          // 60% szans na 50 km/h
          newLimit = 50;
        } else if (rand < 0.7) {
          // 10% szans na 30 km/h
          newLimit = 30;
        } else if (rand < 0.85) {
          // 15% szans na 70 km/h
          newLimit = 70;
        } else if (rand < 0.95) {
          // 10% szans na 90 km/h
          newLimit = 90;
        } else {
          // 5% szans na 120 km/h
          newLimit = 120;
        }
        
        // Aktualizuj tylko jeśli się zmieniło
        if (newLimit !== currentSpeedLimit) {
          currentSpeedLimit = newLimit;
          
          // Aktualizuj wyświetlane ograniczenie
          if (speedLimit) {
            speedLimit.textContent = currentSpeedLimit;
          }
        }
      }

      // Obsługa geolokalizacji
      function startUserLocationTracking() {
        if (!navigator.geolocation) {
          displayErrorMessage("Twoja przeglądarka nie obsługuje geolokalizacji.");
          return;
        }

        console.log("Uruchamiam śledzenie lokalizacji");

        // Obsługa zdarzenia zoom - ważna dla stabilności markerów
        map.on('zoom', handleZoom);
        map.on('move', handleMapMove);
        map.on('moveend', handleMapMoveEnd);

        // Opcje geolokalizacji z maksymalną dokładnością
        const options = {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 30000  // Zwiększamy timeout do 30 sekund
        };

        // Pokaż informację o uruchamianiu lokalizacji
        displayErrorMessage("Uruchamianie lokalizacji...");
        
        // Najpierw spróbujmy uzyskać jednorazową pozycję, aby szybciej ustawić mapę
        navigator.geolocation.getCurrentPosition(
          (position) => {
            console.log("Otrzymano początkową pozycję", position);
            // Aktualizuj mapę na podstawie początkowej pozycji
            updateUserLocation(position);
            
            // Pokaż komunikat o sukcesie
            displayErrorMessage("Lokalizacja znaleziona!", 2000);
            
            // Rozpocznij ciągłe śledzenie
            startContinuousTracking(options);
          },
          (error) => {
            console.error("Błąd podczas uzyskiwania początkowej pozycji:", error);
            displayErrorMessage("Błąd podczas uzyskiwania pozycji: " + (messages[error.code] || messages.default));
            
            // Spróbuj jeszcze raz z mniejszą dokładnością
            navigator.geolocation.getCurrentPosition(
              (position) => {
                console.log("Otrzymano pozycję z drugiej próby");
                updateUserLocation(position);
                startContinuousTracking(options);
              },
              (secondError) => {
                console.error("Drugi błąd lokalizacji:", secondError);
                displayErrorMessage("Nie można określić Twojej lokalizacji. Sprawdź uprawnienia.");
              },
              { enableHighAccuracy: false, timeout: 15000, maximumAge: 0 }
            );
          },
          { ...options, timeout: 10000 } // Krótszy timeout dla pierwszej próby
        );
      }
      
      // Funkcja do ciągłego śledzenia lokalizacji
      function startContinuousTracking(options) {
        // Rozpocznij śledzenie lokalizacji
        try {
          if (userWatchId) {
            navigator.geolocation.clearWatch(userWatchId);
          }
          
          // Dodanie dodatkowych opcji dla urządzeń mobilnych
          const mobileOptions = {
            ...options,
            // Na urządzeniach mobilnych częściej aktualizujemy pozycję
            maximumAge: 0
          };
          
          userWatchId = navigator.geolocation.watchPosition(
            updateUserLocation,
            handleLocationError,
            mobileOptions
          );
          
          // Domyślnie włączamy obrót mapy - bardzo ważne na telefonie
          mapRotationEnabled = true;
          rotationToggle.checked = true;
          
          console.log("Rozpoczęto ciągłe śledzenie lokalizacji, ID:", userWatchId);
        } catch (e) {
          console.error("Błąd podczas uruchamiania geolokalizacji:", e);
          displayErrorMessage("Błąd podczas uruchamiania lokalizacji: " + e.message);
        }
      }

      // Aktualizacja widoczności przycisku centrowania
      function updateCenterButtonVisibility() {
        if (isMapCentered && !userMovedMap) {
          centerButton.classList.remove('visible');
        } else {
          centerButton.classList.add('visible');
        }
      }
      
      // Obsługa zdarzeń mapy
      map.on('movestart', function(e) {
        if (e.originalEvent) {
          console.log("Użytkownik rozpoczął przesuwanie mapy");
          userMovedMap = true;
          isMapCentered = false;
        }
      });

      // Funkcja wyboru miejsca docelowego i uruchomienia nawigacji
      function selectDestination(destination) {
        if (!userLocationMarker) {
          displayErrorMessage("Najpierw włącz lokalizację GPS");
          return;
        }
        
        // Wyświetl komunikat o uruchamianiu nawigacji
        displayErrorMessage("Uruchamianie nawigacji...");
        
        // Pobierz aktualne współrzędne użytkownika
        const userLocation = userLocationMarker.getLngLat();
        
        // Usuń poprzednią trasę, jeśli istnieje
        if (currentRoute && map.getLayer('route')) {
          map.removeLayer('route');
        }
        
        if (map.getSource('route')) {
          map.removeSource('route');
        }
        
        // Ukryj popup jeśli są otwarte
        const popups = document.getElementsByClassName('mapboxgl-popup');
        while(popups[0]) {
          popups[0].remove();
        }
        
        // Dodaj marker docelowy
        let destinationMarker = new tt.Marker()
          .setLngLat([destination.lng, destination.lat])
          .addTo(map);
        
        // Wycentruj mapę tak aby pokazać obie lokalizacje
        const bounds = new tt.LngLatBounds();
        bounds.extend([userLocation.lng, userLocation.lat]);
        bounds.extend([destination.lng, destination.lat]);
        
        map.fitBounds(bounds, {
          padding: 100,
          duration: 1000
        });
        
        // Wywołanie API routingu TomTom
        const routingApi = 'https://api.tomtom.com/routing/1/calculateRoute/' + 
              userLocation.lat + ',' + userLocation.lng + ':' + 
              destination.lat + ',' + destination.lng + 
              '/json?key=' + apiKey + 
              '&instructionsType=text' +
              '&language=pl-PL' +
              '&traffic=true' +
              '&travelMode=car' +
              '&vehicleHeading=' + (userHeading || 0);
              
        // Pobierz trasę
        fetch(routingApi)
          .then(response => {
            if (!response.ok) {
              throw new Error('Nie można obliczyć trasy');
            }
            return response.json();
          })
          .then(data => {
            // Obsłuż odpowiedź
            if (data && data.routes && data.routes.length > 0) {
              // Zapisz trasę
              currentRoute = data.routes[0];
              
              // Dodaj trasę do mapy
              addRouteToMap(currentRoute);
              
              // Pokaż panel nawigacji
              showNavigationPanel(currentRoute);
              
              // Podaj pierwszą instrukcję głosową
              if (currentRoute.guidance && currentRoute.guidance.instructions && currentRoute.guidance.instructions.length > 0) {
                currentStep = 0;
                const firstInstruction = currentRoute.guidance.instructions[0];
                speakInstruction("Rozpoczęto nawigację. " + firstInstruction.message);
              }
              
              // Ustaw timer aktualizacji trasy
              if (routeUpdateInterval) {
                clearInterval(routeUpdateInterval);
              }
              
              routeUpdateInterval = setInterval(() => {
                updateRouteProgress();
              }, 5000);
              
              // Ukryj komunikat o uruchamianiu
              if (messageBox && !messageBox.getAttribute('hidden')) {
                messageBox.setAttribute('hidden', true);
              }
            } else {
              throw new Error('Brak dostępnych tras');
            }
          })
          .catch(error => {
            console.error('Błąd podczas obliczania trasy:', error);
            displayErrorMessage('Nie można obliczyć trasy: ' + error.message);
            
            // Usuń marker docelowy w przypadku błędu
            destinationMarker.remove();
          });
      }

      // Elementy UI
      const settingsBtn = document.querySelector(".settings-btn");
      const settingsPanel = document.getElementById("settingsPanel");
      const trafficToggle = document.getElementById("flow-toggle");
      const incidentsCheckbox = document.getElementById("incidents-toggle");
      const rotationToggle = document.getElementById("rotation-toggle");
      const centerButton = document.getElementById("centerButton");
      const messageBox = document.getElementById("messageBox");
      const messageBoxContent = document.getElementById("messageBoxContent");
      const messageBoxClose = document.getElementById("messageBoxClose");
      const buildingsToggle = document.getElementById("buildings-toggle");
      const searchBtn = document.getElementById('searchBtn');
      const searchPanel = document.getElementById('searchPanel');
      const searchInput = document.getElementById('searchInput');
      const searchResults = document.getElementById('searchResults');
      const navigationPanel = document.getElementById('navigationPanel');
      const navigationContent = document.getElementById('navigationContent');
      const navigationClose = document.getElementById('navigationClose');
      const favoritesBtn = document.getElementById('favoritesBtn');
      const favoritesPanel = document.getElementById('favoritesPanel');
      const favoritesList = document.getElementById('favoritesList');
      const addFavorite = document.getElementById('addFavorite');
      const layersBtn = document.getElementById('layersBtn');
      const layersPanel = document.getElementById('layersPanel');
      const speedIndicator = document.getElementById('speedIndicator');
      const speedLimit = document.getElementById('speedLimit');
      const speedContainer = document.getElementById('speedContainer');

      // Komunikaty błędów
      const messages = {
        permissionDenied: "Dostęp do lokalizacji został zablokowany. Zmień ustawienia przeglądarki, aby umożliwić geolokalizację.",
        notAvailable: "Nie można określić Twojej lokalizacji. Upewnij się, że usługi lokalizacji są włączone.",
        timeout: "Przekroczono czas oczekiwania na lokalizację. Spróbuj ponownie.",
        default: "Wystąpił błąd podczas określania lokalizacji. Spróbuj odświeżyć stronę."
      };

      // Zmienne stanu
      let trafficIncidentsLayer = null;
      let userLocationMarker = null;
      let userAccuracyCircle = null;
      let userWatchId = null;
      let userHeading = 0;
      let lastPosition = null;
      let lastPositionTimestamp = 0;
      let headingTimeout = null;
      let mapRotationEnabled = true;
      let autoCenteringEnabled = true;
      let isMapCentered = true;
      let lastMapMoveTime = 0;
      let userMovedMap = false;
      let buildings3DEnabled = false;
      
      // Zmienne dla płynnego ruchu
      let animationFrameId = null;
      let targetPosition = null;
      let currentAnimatedPosition = null;
      let lastHeadingUpdateTime = 0;
      let headingChangeRate = 0;
      let lastUpdateTime = 0;

      // Zmienne dla nawigacji
      let currentRoute = null;
      let currentStep = 0;
      let routeUpdateInterval = null;

      // Zmienne dla nawigacji głosowej
      let speechSynthesis = window.speechSynthesis;
      let lastVoiceInstruction = "";
      let lastVoiceTime = 0;
      let voiceEnabled = true;
      let nextManeuverDistance = 0;
      let upcomingManeuver = "";
      
      // Zmienne dla warstw mapy
      let speedcamsLayer = null;
      let roadworksLayer = null;
      let poiLayer = null;
      let favoritesLayer = null;
      let reportsLayer = null;
      
      // Zmienne dla audio
      let originalVolumeOfBackgroundAudio = [];
      let backgroundAudioElements = [];
      let isAudioLowered = false;
      
      // Zmienne dla prędkości
      let currentSpeed = 0;
      let currentSpeedLimit = 50;  // Domyślne ograniczenie prędkości
      let lastSpeedUpdate = 0;
      
      // Ulubione miejsca
      let favoriteLocations = JSON.parse(localStorage.getItem('favoriteLocations') || '[]');

      // Obsługa ruchu drogowego
      trafficToggle.addEventListener("change", () => {
        if (trafficToggle.checked) {
          map.showTrafficFlow();
        } else {
          map.hideTrafficFlow();
        }
      });

      // Obsługa budynków 3D
      buildingsToggle.addEventListener("change", () => {
        if (buildingsToggle.checked) {
          if (!buildings3DEnabled) {
            map.set3DBuildings(true);
            buildings3DEnabled = true;
            
            // Ustaw odpowiedni pitch dla lepszego widoku 3D
            map.easeTo({
              pitch: 45,
              duration: 1000
            });
          }
        } else if (buildings3DEnabled) {
          map.set3DBuildings(false);
          buildings3DEnabled = false;
          
          // Przywróć płaski widok
          map.easeTo({
            pitch: 0,
            duration: 1000
          });
        }
      });

      // Obsługa panelu ustawień
      settingsBtn.addEventListener("click", () => {
        settingsPanel.style.display =
          settingsPanel.style.display === "block" ? "none" : "block";
      });

      // Obsługa przełącznika rotacji
      rotationToggle.addEventListener("change", () => {
        mapRotationEnabled = rotationToggle.checked;
        
        // Jeśli wyłączono rotację, zresetuj orientację mapy
        if (!mapRotationEnabled && isMapCentered) {
          map.easeTo({
            bearing: 0,
            pitch: 0,
            duration: 500
          });
        } else if (mapRotationEnabled && isMapCentered && userHeading !== null) {
          // Włączono rotację i znamy kierunek - obróć mapę
          map.easeTo({
            bearing: userHeading,
            duration: 500
          });
        }
      });

      // Obsługa incydentów drogowych
      incidentsCheckbox.addEventListener("change", () => {
        if (incidentsCheckbox.checked) {
          if (!trafficIncidentsLayer) {
            // Tworzenie warstwy incydentów drogowych
            trafficIncidentsLayer = new tt.VectorTileLayer({
              key: apiKey,
              style: "tomtom://vector/incident",
              refresh: 30000, // Odświeżanie co 30 sekund
              minZoom: 5,
              maxZoom: 19,
              language: 'pl-PL'
            });

            // Dodaj warstwę do mapy
            map.addLayer(trafficIncidentsLayer);

            // Dodaj obsługę kliknięcia w incydent
            map.on('click', 'incidents', (e) => {
              if (e.features.length > 0) {
                const incident = e.features[0].properties;
                const coordinates = e.features[0].geometry.coordinates.slice();
                const description = incident.description || 'Brak opisu';
                const type = incident.type || 'Nieznany typ';
                const severity = incident.severity || 'Nieznana ważność';

                // Utwórz popup z informacjami o incydencie
                new tt.Popup()
                  .setLngLat(coordinates)
                  .setHTML(`
                    <div style="padding: 10px;">
                      <h3 style="margin: 0 0 5px 0;">${type}</h3>
                      <p style="margin: 0 0 5px 0;"><strong>Opis:</strong> ${description}</p>
                      <p style="margin: 0;"><strong>Ważność:</strong> ${severity}</p>
                    </div>
                  `)
                  .addTo(map);
              }
            });

            // Zmień kursor przy najechaniu na incydent
            map.on('mouseenter', 'incidents', () => {
              map.getCanvas().style.cursor = 'pointer';
            });

            map.on('mouseleave', 'incidents', () => {
              map.getCanvas().style.cursor = '';
            });

            // Dodaj legendę incydentów
            const legend = document.createElement('div');
            legend.id = 'incidents-legend';
            legend.style.display = 'none';
            legend.style.position = 'absolute';
            legend.style.bottom = '30px';
            legend.style.left = '10px';
            legend.style.backgroundColor = 'white';
            legend.style.padding = '10px';
            legend.style.borderRadius = '4px';
            legend.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
            legend.style.zIndex = '1';
            legend.innerHTML = `
              <h4 style="margin: 0 0 10px 0;">Legenda incydentów</h4>
              <div style="display: grid; grid-template-columns: auto 1fr; gap: 5px; align-items: center;">
                <span style="display: inline-block; width: 10px; height: 10px; background: #ff0000; border-radius: 50%;"></span>
                <span>Wypadek</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ffa500; border-radius: 50%;"></span>
                <span>Zatłoczenie</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ffff00; border-radius: 50%;"></span>
                <span>Roboty drogowe</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ff00ff; border-radius: 50%;"></span>
                <span>Uszkodzony pojazd</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #00ffff; border-radius: 50%;"></span>
                <span>Zamknięty pas</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #000000; border-radius: 50%;"></span>
                <span>Zamknięta droga</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #ff4500; border-radius: 50%;"></span>
                <span>Zagrożenie na drodze</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #800080; border-radius: 50%;"></span>
                <span>Wydarzenie planowane</span>
                <span style="display: inline-block; width: 10px; height: 10px; background: #4169e1; border-radius: 50%;"></span>
                <span>Zła pogoda</span>
              </div>
            `;
            document.body.appendChild(legend);

            // Pokaż/ukryj legendę przy zmianie stanu checkboxa
            incidentsCheckbox.addEventListener('change', () => {
              legend.style.display = incidentsCheckbox.checked ? 'block' : 'none';
            });
          }
        } else if (trafficIncidentsLayer) {
          map.removeLayer(trafficIncidentsLayer);
          trafficIncidentsLayer = null;
          
          // Ukryj legendę
          const legend = document.getElementById('incidents-legend');
          if (legend) {
            legend.style.display = 'none';
          }
        }
      });

      // Obsługa wyszukiwania
      searchBtn.addEventListener('click', () => {
        searchPanel.style.display = searchPanel.style.display === 'block' ? 'none' : 'block';
        if (searchPanel.style.display === 'block') {
          searchInput.focus();
        }
      });

      // Autocomplete dla wyszukiwania
      let searchTimeout;
      searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value;
        
        if (query.length < 3) {
          searchResults.innerHTML = '';
          return;
        }

        searchTimeout = setTimeout(() => {
          tt.services.fuzzySearch({
            key: apiKey,
            query: query,
            language: 'pl-PL',
            limit: 5
          })
          .then(response => {
            searchResults.innerHTML = '';
            response.results.forEach(result => {
              const div = document.createElement('div');
              div.className = 'search-result-item';
              div.textContent = result.address.freeformAddress;
              div.addEventListener('click', () => {
                selectDestination(result.position);
                searchPanel.style.display = 'none';
              });
              searchResults.appendChild(div);
            });
          })
          .catch(error => {
            console.error('Błąd wyszukiwania:', error);
          });
        }, 300);
      });

      // Obsługa warstw
      layersBtn.addEventListener('click', () => {
        layersPanel.style.display = layersPanel.style.display === 'block' ? 'none' : 'block';
      });

      // Obsługa fotoradarów i kontroli prędkości
      document.getElementById('speedcams-toggle').addEventListener('change', (e) => {
        if (e.target.checked) {
          loadSpeedCameras();
          document.getElementById('mapFeaturesLegend').style.display = 'block';
        } else {
          if (speedcamsLayer) {
            map.removeLayer('speedcams');
            map.removeSource('speedcams');
            speedcamsLayer = null;
          }
          updateLegendVisibility();
        }
      });

      // Obsługa prac drogowych
      document.getElementById('roadworks-toggle').addEventListener('change', (e) => {
        if (e.target.checked) {
          loadRoadworks();
          document.getElementById('mapFeaturesLegend').style.display = 'block';
        } else {
          if (roadworksLayer) {
            map.removeLayer('roadworks');
            map.removeSource('roadworks');
            roadworksLayer = null;
          }
          updateLegendVisibility();
        }
      });

      // Obsługa POI
      document.getElementById('poi-toggle').addEventListener('change', (e) => {
        if (e.target.checked) {
          loadPointsOfInterest();
        } else {
          if (poiLayer) {
            map.removeLayer('pois');
            map.removeSource('pois');
            poiLayer = null;
          }
        }
      });

      // Obsługa zgłoszeń użytkowników
      document.getElementById('reports-toggle').addEventListener('change', (e) => {
        if (e.target.checked) {
          if (lastPosition) {
            loadReportsFromOverpass(lastPosition[1], lastPosition[0]);
          } else {
          displayErrorMessage('Najpierw włącz lokalizację GPS');
            e.target.checked = false;
          }
        } else {
          if (reportsLayer) {
            map.removeLayer('reports');
            map.removeSource('reports');
            reportsLayer = null;
          }
        }
      });

      // Ładowanie zgłoszeń z Overpass API
      function loadReportsFromOverpass(lat, lng) {
        // Pokaż informację o ładowaniu
        displayErrorMessage('Ładowanie zgłoszeń z Overpass API...');
        
        // Promień wyszukiwania w metrach
        const radius = 10000; // 10km
        
        // Budowanie zapytania Overpass
        const query = `
          [out:json][timeout:25];
          (
            // Fotoradary
            node["highway"="speed_camera"](around:${radius},${lat},${lng});
            // Kamery drogowe
            node["highway"="traffic_signals"]["camera"](around:${radius},${lat},${lng});
            // Prace drogowe
            way["highway"]["construction"](around:${radius},${lat},${lng});
            // Miejsca częstej kontroli prędkości
            node["highway"]["traffic_calming"](around:${radius},${lat},${lng});
            // Miejsca wypadków
            node["hazard"="accident"](around:${radius},${lat},${lng});
          );
          out body;
          >;
          out skel qt;
        `;
        
        // Teraz faktycznie używamy API Overpass zamiast symulowanych danych
        const overpassUrl = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;
        
        fetch(overpassUrl)
          .then(response => {
            if (!response.ok) {
              throw new Error('Błąd pobierania danych z API Overpass');
            }
            return response.json();
          })
          .then(data => {
            processOverpassResults(data);
          })
          .catch(error => {
            console.error('Błąd zapytania Overpass:', error);
            displayErrorMessage('Nie udało się pobrać zgłoszeń. Używam danych lokalnych.');
            
            // Fallback na dane offline jeśli API nie odpowiada
            const simulatedResults = {
              elements: [
                { 
                  id: 1, 
                  type: "node", 
                  lat: lat + 0.002, 
                  lon: lng + 0.003, 
                  tags: { 
                    highway: "speed_camera", 
                    name: "Fotoradar stacjonarny", 
                    description: "Kontrola prędkości na prostym odcinku" 
                  } 
                },
                { 
                  id: 2, 
                  type: "node", 
                  lat: lat - 0.001, 
                  lon: lng + 0.002, 
                  tags: { 
                    highway: "traffic_signals", 
                    camera: "yes", 
                    name: "Kamera na skrzyżowaniu", 
                    description: "Monitoring przejazdu na czerwonym świetle" 
                  } 
                },
                { 
                  id: 3, 
                  type: "node", 
                  lat: lat + 0.003, 
                  lon: lng - 0.002, 
                  tags: { 
                    highway: "traffic_calming", 
                    name: "Częste kontrole prędkości", 
                    description: "Miejsce regularnych kontroli policyjnych" 
                  } 
                },
                { 
                  id: 4, 
                  type: "node", 
                  lat: lat - 0.002, 
                  lon: lng - 0.001, 
                  tags: { 
                    hazard: "accident", 
                    name: "Miejsce wypadku", 
                    description: "Niebezpieczne skrzyżowanie, częste kolizje" 
                  } 
                }
              ]
            };
            processOverpassResults(simulatedResults);
          });
      }
      
      // Przetwarzanie wyników z Overpass API
      function processOverpassResults(data) {
        if (!data || !data.elements || data.elements.length === 0) {
          displayErrorMessage('Brak zgłoszeń w okolicy');
          return;
        }
        
        // Ukryj komunikat o ładowaniu
        if (messageBox && !messageBox.getAttribute('hidden')) {
          messageBox.setAttribute('hidden', true);
        }
        
        // Przygotuj features dla GeoJSON
        const features = data.elements.map(element => {
          // Sprawdź czy element ma współrzędne
          if (!element.lat || !element.lon) return null;
          
          // Określ typ zgłoszenia i ikonę
          let type = 'unknown';
          let icon = 'marker-15';
          let color = '#ff0000';
          let description = 'Brak opisu';
          
          if (element.tags) {
            if (element.tags.highway === 'speed_camera') {
              type = 'speed_camera';
              icon = 'camera-15';
              color = '#ff0000';
              description = element.tags.description || 'Fotoradar';
            } else if (element.tags.camera === 'yes') {
              type = 'traffic_camera';
              icon = 'camera-15';
              color = '#ff9900';
              description = element.tags.description || 'Kamera drogowa';
            } else if (element.tags.construction) {
              type = 'roadworks';
              icon = 'roadblock-15';
              color = '#ffcc00';
              description = element.tags.description || 'Prace drogowe';
            } else if (element.tags.traffic_calming) {
              type = 'speed_control';
              icon = 'police-15';
              color = '#ffa500';
              description = element.tags.description || 'Kontrola prędkości';
            } else if (element.tags.hazard === 'accident') {
              type = 'accident';
              icon = 'danger-15';
              color = '#cc0000';
              description = element.tags.description || 'Miejsce wypadku';
            }
          }
          
          // Utwórz feature GeoJSON
          return {
              type: 'Feature',
            properties: {
              id: element.id,
              type: type,
              name: element.tags?.name || 'Zgłoszenie',
              description: description,
              color: color
            },
              geometry: {
              type: 'Point',
              coordinates: [element.lon, element.lat]
            }
          };
        }).filter(feature => feature !== null);
        
        // Usuń istniejącą warstwę jeśli istnieje
        if (map.getLayer('reports')) {
          map.removeLayer('reports');
        }
        
        if (map.getSource('reports')) {
          map.removeSource('reports');
        }
        
        // Dodaj źródło danych
        map.addSource('reports', {
                type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features: features
          }
              });

        // Dodaj warstwę
              map.addLayer({
          id: 'reports',
          type: 'symbol',
          source: 'reports',
                layout: {
            'icon-image': [
              'match',
              ['get', 'type'],
              'speed_camera', 'camera-15',
              'traffic_camera', 'camera-15',
              'roadworks', 'roadblock-15',
              'speed_control', 'police-15',
              'accident', 'danger-15',
              'marker-15'
            ],
            'icon-size': 1.2,
            'icon-allow-overlap': true,
            'text-field': ['get', 'name'],
            'text-font': ['Arial Unicode MS Bold'],
            'text-offset': [0, 1],
            'text-anchor': 'top'
                },
                paint: {
            'text-color': ['get', 'color'],
            'text-halo-color': '#ffffff',
            'text-halo-width': 1
          }
        });
        
        // Dodaj obsługę kliknięcia
        map.on('click', 'reports', (e) => {
          const properties = e.features[0].properties;
          const coordinates = e.features[0].geometry.coordinates.slice();
          
          // Utwórz popup
          new tt.Popup()
            .setLngLat(coordinates)
            .setHTML(`
              <div style="padding: 10px;">
                <h3 style="margin: 0 0 5px 0;">${properties.name}</h3>
                <p style="margin: 0;">${properties.description}</p>
              </div>
            `)
            .addTo(map);
        });
        
        // Zmień kursor przy najeździe
        map.on('mouseenter', 'reports', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        
        map.on('mouseleave', 'reports', () => {
          map.getCanvas().style.cursor = '';
        });
        
        reportsLayer = true;
        
        // Aktualizuj legendę
        document.getElementById('mapFeaturesLegend').style.display = 'block';
      }

      // Funkcja aktualizująca widoczność legendy
      function updateLegendVisibility() {
        const shouldShowLegend = document.getElementById('speedcams-toggle').checked || 
                                document.getElementById('roadworks-toggle').checked ||
                                document.getElementById('reports-toggle').checked;
        document.getElementById('mapFeaturesLegend').style.display = shouldShowLegend ? 'block' : 'none';
      }

      // Obsługa ulubionych miejsc
      favoritesBtn.addEventListener('click', () => {
        favoritesPanel.style.display = favoritesPanel.style.display === 'block' ? 'none' : 'block';
        if (favoritesPanel.style.display === 'block') {
          renderFavorites();
        }
      });

      // Dodanie ulubionego miejsca
      addFavorite.addEventListener('click', () => {
        if (!userLocationMarker) {
          displayErrorMessage('Najpierw włącz lokalizację GPS');
          return;
        }

        const position = userLocationMarker.getLngLat();
        const name = prompt('Nazwa ulubionego miejsca:');
        
        if (!name) return;
        
        const favorite = {
          id: Date.now().toString(),
          name,
          position: {
            lat: position.lat,
            lng: position.lng
          }
        };
        
        favoriteLocations.push(favorite);
        localStorage.setItem('favoriteLocations', JSON.stringify(favoriteLocations));
        
        renderFavorites();
        updateFavoritesOnMap();
      });

      // Renderowanie listy ulubionych miejsc
      function renderFavorites() {
        favoritesList.innerHTML = '';
        
        if (favoriteLocations.length === 0) {
          favoritesList.innerHTML = '<div style="padding: 10px;">Brak ulubionych miejsc</div>';
          return;
        }
        
        favoriteLocations.forEach(favorite => {
          const item = document.createElement('div');
          item.style.padding = '10px';
          item.style.marginBottom = '5px';
          item.style.borderRadius = '5px';
          item.style.backgroundColor = '#f5f5f5';
          item.style.cursor = 'pointer';
          item.style.position = 'relative';
          item.textContent = favorite.name;
          
          // Przycisk usuwania
          const deleteBtn = document.createElement('button');
          deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
          deleteBtn.style.position = 'absolute';
          deleteBtn.style.right = '5px';
          deleteBtn.style.top = '50%';
          deleteBtn.style.transform = 'translateY(-50%)';
          deleteBtn.style.color = '#ff0000';
          deleteBtn.style.background = 'none';
          deleteBtn.style.border = 'none';
          deleteBtn.style.cursor = 'pointer';
          deleteBtn.style.fontSize = '16px';
          
          deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removeFavorite(favorite.id);
            renderFullscreenFavorites(container);
          });
          
          item.appendChild(deleteBtn);
          
          // Wybór ulubionego miejsca
          item.addEventListener('click', () => {
            selectDestination(favorite.position);
            document.getElementById('fullscreen-favorites-panel').style.display = 'none';
          });
          
          container.appendChild(item);
        });
      }

      // Usuwanie ulubionego miejsca
      function removeFavorite(id) {
        favoriteLocations = favoriteLocations.filter(fav => fav.id !== id);
        localStorage.setItem('favoriteLocations', JSON.stringify(favoriteLocations));
        renderFavorites();
        updateFavoritesOnMap();
      }

      // Aktualizacja ulubionych miejsc na mapie
      function updateFavoritesOnMap() {
        // Usuń istniejącą warstwę
        if (map.getLayer('favorites')) {
          map.removeLayer('favorites');
        }
        
        if (map.getSource('favorites')) {
          map.removeSource('favorites');
        }
        
        // Stwórz źródło danych GeoJSON
        const features = favoriteLocations.map(favorite => ({
          type: 'Feature',
          properties: {
            name: favorite.name,
            id: favorite.id
          },
          geometry: {
            type: 'Point',
            coordinates: [favorite.position.lng, favorite.position.lat]
          }
        }));
        
        // Dodaj źródło danych
        map.addSource('favorites', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features
          }
        });
        
        // Dodaj warstwę
        map.addLayer({
          id: 'favorites',
          type: 'symbol',
          source: 'favorites',
          layout: {
            'icon-image': 'marker-15',
            'icon-size': 1.5,
            'text-field': ['get', 'name'],
            'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
            'text-offset': [0, 1.5],
            'text-anchor': 'top'
          },
          paint: {
            'text-color': '#0000ff',
            'text-halo-color': '#ffffff',
            'text-halo-width': 1
          }
        });
        
        // Dodaj obsługę kliknięcia
        map.on('click', 'favorites', (e) => {
          const properties = e.features[0].properties;
          const coordinates = e.features[0].geometry.coordinates.slice();
          
          // Utwórz popup
          new tt.Popup()
            .setLngLat(coordinates)
            .setHTML(`
              <div style="padding: 10px;">
                <h3 style="margin: 0 0 10px 0;">${properties.name}</h3>
                <button id="navigate-favorite" style="padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Nawiguj</button>
              </div>
            `)
            .addTo(map);
            
          // Obsługa przycisku w popup
                  setTimeout(() => {
            document.getElementById('navigate-favorite').addEventListener('click', () => {
              const favorite = favoriteLocations.find(f => f.id === properties.id);
              if (favorite) {
                selectDestination(favorite.position);
              }
            });
          }, 100);
        });
        
        // Zmień kursor przy najeździe na ulubione miejsce
        map.on('mouseenter', 'favorites', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        
        map.on('mouseleave', 'favorites', () => {
          map.getCanvas().style.cursor = '';
        });
      }

      // Ładowanie fotoradarów i kontroli prędkości
      function loadSpeedCameras() {
        // Symulacja danych - w rzeczywistej aplikacji użylibyśmy API
        const speedCameras = [
          // Przykładowe dane - w rzeczywistej aplikacji pobralibyśmy te informacje z API
          { type: "speed_camera", lat: 52.2297, lng: 21.0122, description: "Fotoradar stacjonarny" },
          { type: "speed_control", lat: 52.2350, lng: 21.0091, description: "Częsta kontrola prędkości" }
        ];
        
        // Przygotowanie źródła danych GeoJSON
        const features = speedCameras.map(camera => ({
          type: 'Feature',
          properties: {
            type: camera.type,
            description: camera.description
          },
          geometry: {
            type: 'Point',
            coordinates: [camera.lng, camera.lat]
          }
        }));
        
        // Dodaj źródło danych
        map.addSource('speedcams', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features
          }
        });
        
        // Dodaj warstwę
        map.addLayer({
          id: 'speedcams',
          type: 'symbol',
          source: 'speedcams',
          layout: {
            'icon-image': 'marker-15',
            'icon-size': 1.2,
            'icon-allow-overlap': true
          },
          paint: {
            'icon-color': [
              'match',
              ['get', 'type'],
              'speed_camera', '#ff0000',
              'speed_control', '#ffa500',
              '#ff0000'
            ]
          }
        });
        
        // Dodaj obsługę kliknięcia
        map.on('click', 'speedcams', (e) => {
          const properties = e.features[0].properties;
          const coordinates = e.features[0].geometry.coordinates.slice();
          
          // Utwórz popup
          new tt.Popup()
            .setLngLat(coordinates)
            .setHTML(`
              <div style="padding: 10px;">
                <h3 style="margin: 0 0 5px 0;">${properties.type === 'speed_camera' ? 'Fotoradar' : 'Kontrola prędkości'}</h3>
                <p style="margin: 0;">${properties.description}</p>
              </div>
            `)
            .addTo(map);
        });
        
        // Zmień kursor przy najeździe
        map.on('mouseenter', 'speedcams', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        
        map.on('mouseleave', 'speedcams', () => {
          map.getCanvas().style.cursor = '';
        });
        
        speedcamsLayer = true;
      }

      // Ładowanie prac drogowych
      function loadRoadworks() {
        // W rzeczywistej aplikacji użylibyśmy API Overpass
        // Symulacja danych
        const roadworks = [
          // Przykładowe dane
          { lat: 52.2340, lng: 21.0180, description: "Przebudowa drogi, zwężenie do jednego pasa", endDate: "2023-12-31" },
          { lat: 52.2280, lng: 21.0050, description: "Remont chodnika", endDate: "2023-11-15" }
        ];
        
        // Przygotowanie źródła danych GeoJSON
        const features = roadworks.map(work => ({
          type: 'Feature',
          properties: {
            description: work.description,
            endDate: work.endDate
          },
          geometry: {
            type: 'Point',
            coordinates: [work.lng, work.lat]
          }
        }));
        
        // Dodaj źródło danych
        map.addSource('roadworks', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features
          }
        });
        
        // Dodaj warstwę
        map.addLayer({
          id: 'roadworks',
          type: 'symbol',
          source: 'roadworks',
          layout: {
            'icon-image': 'marker-15',
            'icon-size': 1.2,
            'icon-allow-overlap': true
          },
          paint: {
            'icon-color': '#ffff00'
          }
        });
        
        // Dodaj obsługę kliknięcia
        map.on('click', 'roadworks', (e) => {
          const properties = e.features[0].properties;
          const coordinates = e.features[0].geometry.coordinates.slice();
          
          // Utwórz popup
          new tt.Popup()
            .setLngLat(coordinates)
            .setHTML(`
              <div style="padding: 10px;">
                <h3 style="margin: 0 0 5px 0;">Prace drogowe</h3>
                <p style="margin: 0 0 5px 0;">${properties.description}</p>
                <p style="margin: 0;"><strong>Planowany koniec:</strong> ${properties.endDate}</p>
              </div>
            `)
            .addTo(map);
        });
        
        // Zmień kursor przy najeździe
        map.on('mouseenter', 'roadworks', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        
        map.on('mouseleave', 'roadworks', () => {
          map.getCanvas().style.cursor = '';
        });
        
        roadworksLayer = true;
      }

      // Ładowanie punktów zainteresowania (POI)
      function loadPointsOfInterest() {
        // W rzeczywistej aplikacji użylibyśmy Overpass API
        // Przykładowy kod zapytania Overpass:
        // const query = `
        //   [out:json];
        //   (
        //     node["amenity"](around:1000,${lat},${lng});
        //     node["shop"](around:1000,${lat},${lng});
        //   );
        //   out;
        // `;
        
        // Symulacja danych
        const pois = [
          { lat: 52.2320, lng: 21.0100, name: "Restauracja Pod Jabłonią", type: "restaurant" },
          { lat: 52.2300, lng: 21.0150, name: "Stacja paliw BP", type: "fuel" },
          { lat: 52.2270, lng: 21.0080, name: "Sklep spożywczy", type: "shop" }
        ];
        
        // Przygotowanie źródła danych GeoJSON
        const features = pois.map(poi => ({
          type: 'Feature',
          properties: {
            name: poi.name,
            type: poi.type
          },
          geometry: {
            type: 'Point',
            coordinates: [poi.lng, poi.lat]
          }
        }));
        
        // Dodaj źródło danych
        map.addSource('pois', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features
          }
        });
        
        // Dodaj warstwę
        map.addLayer({
          id: 'pois',
          type: 'symbol',
          source: 'pois',
          layout: {
            'icon-image': 'marker-15',
            'icon-size': 1,
            'text-field': ['get', 'name'],
            'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
            'text-offset': [0, 1.5],
            'text-anchor': 'top'
          },
          paint: {
            'text-color': '#333333',
            'text-halo-color': '#ffffff',
            'text-halo-width': 1
          }
        });
        
        // Dodaj obsługę kliknięcia
        map.on('click', 'pois', (e) => {
          const properties = e.features[0].properties;
          const coordinates = e.features[0].geometry.coordinates.slice();
          
          // Utwórz popup
          new tt.Popup()
            .setLngLat(coordinates)
            .setHTML(`
              <div style="padding: 10px;">
                <h3 style="margin: 0 0 5px 0;">${properties.name}</h3>
                <p style="margin: 0 0 5px 0;">Typ: ${properties.type}</p>
                <button id="navigate-poi" style="padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Nawiguj</button>
              </div>
            `)
            .addTo(map);
            
          // Obsługa przycisku w popup
          setTimeout(() => {
            document.getElementById('navigate-poi').addEventListener('click', () => {
              selectDestination({lat: coordinates[1], lng: coordinates[0]});
            });
          }, 100);
        });
        
        // Zmień kursor przy najeździe
        map.on('mouseenter', 'pois', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        
        map.on('mouseleave', 'pois', () => {
          map.getCanvas().style.cursor = '';
        });
        
        poiLayer = true;
      }

      // Wyciszanie dźwięków w tle podczas nawigacji głosowej
      function lowerBackgroundAudio() {
        // Jeśli już wyciszone, nie rób nic
        if (isAudioLowered) return;
        
        console.log("Wyciszanie dźwięków w tle...");
        
        // Zbierz wszystkie elementy audio i video na stronie
        const mediaElements = [
          ...document.querySelectorAll('audio:not([data-navigation-voice])'),
          ...document.querySelectorAll('video')
        ];
        
        if (mediaElements.length === 0) {
          console.log("Nie znaleziono elementów audio/video do wyciszenia");
          return;
        }
        
        // Zapisz obecną głośność i elementy
        backgroundAudioElements = mediaElements;
        originalVolumeOfBackgroundAudio = mediaElements.map(el => el.volume);
        
        // Wycisz każdy element
        mediaElements.forEach(el => {
          // Zapisz aktualną głośność i zmniejsz do 20%
          try {
            if (el.volume > 0.2) {
              const originalVolume = el.volume;
              el.volume = 0.2; // Zmniejsz głośność do 20%
              console.log(`Zmniejszono głośność z ${originalVolume} do ${el.volume}`);
            }
          } catch (error) {
            console.error("Błąd podczas zmiany głośności:", error);
          }
        });
        
        isAudioLowered = true;
      }

      // Przywracanie głośności
      function restoreBackgroundAudio() {
        // Jeśli nie są wyciszone, nie rób nic
        if (!isAudioLowered) return;
        
        console.log("Przywracanie oryginalnej głośności...");
        
        // Przywróć głośność każdego elementu
        backgroundAudioElements.forEach((el, index) => {
          if (index < originalVolumeOfBackgroundAudio.length) {
            try {
              const targetVolume = originalVolumeOfBackgroundAudio[index];
              el.volume = targetVolume;
              console.log(`Przywrócono głośność do ${targetVolume}`);
            } catch (error) {
              console.error("Błąd podczas przywracania głośności:", error);
            }
          }
        });
        
        isAudioLowered = false;
      }

      // Funkcja do odtwarzania instrukcji głosowych
      function speakInstruction(text) {
        if (!voiceEnabled || !speechSynthesis) return;
        
        // Nie powtarzaj tej samej instrukcji zbyt często
        const now = Date.now();
        if (text === lastVoiceInstruction && now - lastVoiceTime < 10000) return;
        
        // Wycisz dźwięki w tle
        lowerBackgroundAudio();
        
        // Zatrzymaj wszystkie aktualnie odtwarzane głosy
        speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'pl-PL';
        utterance.volume = 1;
        utterance.rate = 1;
        utterance.pitch = 1;
        
        // Znajdź polski głos, jeśli jest dostępny
        const voices = speechSynthesis.getVoices();
        const polishVoice = voices.find(voice => voice.lang.includes('pl'));
        if (polishVoice) {
          utterance.voice = polishVoice;
        }
        
        // Przywróć głośność po zakończeniu wypowiedzi
        utterance.onend = function() {
          console.log("Wypowiedź zakończona, przywracanie głośności");
          setTimeout(restoreBackgroundAudio, 500);
        };
        
        // Na wypadek błędu w odtwarzaniu
        utterance.onerror = function(event) {
          console.error("Błąd podczas odtwarzania głosu:", event);
          restoreBackgroundAudio();
        };
        
        speechSynthesis.speak(utterance);
        
        lastVoiceInstruction = text;
        lastVoiceTime = now;
      }

      // Aktualizacja instrukcji głosowych na podstawie aktualnej pozycji
      function updateVoiceGuidance(userLocation) {
        if (!currentRoute || !currentRoute.guidance || !currentRoute.guidance.instructions) return;
        
        if (currentStep >= currentRoute.guidance.instructions.length) return;
        
        const currentInstruction = currentRoute.guidance.instructions[currentStep];
        
        if (!currentInstruction || !currentInstruction.point) return;
        
        // Oblicz odległość do kolejnego manewru
        const distanceToManeuver = calculateDistance(
          userLocation[1], userLocation[0],
          currentInstruction.point.latitude, currentInstruction.point.longitude
        );
        
        // Aktualizuj wartości dla wyświetlania i komunikatów
        nextManeuverDistance = distanceToManeuver;
        upcomingManeuver = currentInstruction.message;
        
        // Odtwórz instrukcje głosowe na podstawie odległości
        if (distanceToManeuver <= 35 && Math.abs(distanceToManeuver - nextManeuverDistance) > 10) {
          // Tuż przed manewrem (35m lub mniej)
          speakInstruction(formatVoiceInstruction(currentInstruction, distanceToManeuver));
        } else if (distanceToManeuver <= 150 && Math.abs(distanceToManeuver - nextManeuverDistance) > 20) {
          // Zbliżamy się do manewru (150-35m)
          speakInstruction(formatVoiceInstruction(currentInstruction, distanceToManeuver));
        } else if (distanceToManeuver <= 500 && Math.abs(distanceToManeuver - nextManeuverDistance) > 50) {
          // Manewr jest w zasięgu (500-150m)
          speakInstruction(formatVoiceInstruction(currentInstruction, distanceToManeuver));
        }
        
        // Aktualizacja panelu nawigacji
        updateNavigationPanel(distanceToManeuver);
      }

      // Aktualizacja panelu nawigacji
      function updateNavigationPanel(distanceToManeuver) {
        const distanceElement = document.getElementById('next-maneuver-distance');
        if (distanceElement) {
          distanceElement.textContent = `${Math.round(distanceToManeuver)}`;
        }
      }

      // Funkcja do formatowania instrukcji głosowej
      function formatVoiceInstruction(step, distance) {
        if (!step) return "";
        
        let message = step.message || "";
        if (typeof message !== 'string') {
          return "";
        }
        
        message = message.toLowerCase();
        const distanceInMeters = Math.round(distance);
        
        if (distanceInMeters <= 35) {
          // Jeśli jesteśmy blisko manewru (35 metrów lub mniej)
          if (message.includes("skręć w lewo")) {
            return "Skręć w lewo";
          } else if (message.includes("skręć w prawo")) {
            return "Skręć w prawo";
          } else if (message.includes("zawróć")) {
            return "Zawróć";
          } else if (message.includes("prosto")) {
            return "Jedź prosto";
          } else if (message.includes("rondo")) {
            if (message.includes("pierwszy")) {
              return "Na rondzie pierwszy zjazd";
            } else if (message.includes("drugi")) {
              return "Na rondzie drugi zjazd";
            } else if (message.includes("trzeci")) {
              return "Na rondzie trzeci zjazd";
            } else {
              return message;
            }
          } else {
            return message;
          }
        } else {
          // Jeśli jesteśmy dalej od manewru
          let instruction = `Za ${distanceInMeters} metrów `;
          
          if (message.includes("skręć w lewo")) {
            instruction += "skręć w lewo";
          } else if (message.includes("skręć w prawo")) {
            instruction += "skręć w prawo";
          } else if (message.includes("zawróć")) {
            instruction += "zawróć";
          } else if (message.includes("prosto")) {
            instruction += "jedź prosto";
          } else if (message.includes("rondo")) {
            if (message.includes("pierwszy")) {
              instruction += "na rondzie pierwszy zjazd";
            } else if (message.includes("drugi")) {
              instruction += "na rondzie drugi zjazd";
            } else if (message.includes("trzeci")) {
              instruction += "na rondzie trzeci zjazd";
            } else {
              instruction += message;
            }
          } else {
            instruction += message;
          }
          
          return instruction;
        }
      }

      // Aktualizacja lokalizacji użytkownika
      function updateUserLocation(position) {
        const { latitude, longitude, accuracy, heading, speed } = position.coords;
        
        // Zapisz dokładność do późniejszego użycia
        window.lastAccuracy = accuracy;
        
        // Dla debugowania
        console.log("GPS update - heading:", heading, "accuracy:", accuracy, "coords:", latitude, longitude, "speed:", speed);
        
        // Aktualizacja prędkości
        updateSpeedIndicator(speed, latitude, longitude);
        
        // Filtrujemy odczyty z niską dokładnością
        // Na telefonach często początkowe odczyty mają bardzo niską dokładność
        if (accuracy > 500) {
          console.warn("Niska dokładność GPS:", accuracy, "m - czekam na lepszy sygnał");
          
          // Jeśli jeszcze nie mamy markera, to wyświetlamy pozycję z niską dokładnością
          // ale komunikujemy użytkownikowi, że dokładność jest niska
          if (!userLocationMarker) {
            displayErrorMessage("Niska dokładność GPS (" + Math.round(accuracy) + "m). Poczekaj na lepszy sygnał.");
            
            // Tworzymy marker mimo wszystko, aby użytkownik widział przybliżoną lokalizację
            createUserMarker(latitude, longitude);
            
            // Dodajemy klasę niskiej dokładności dla efektu pulsowania
            if (userLocationMarker && userLocationMarker.getElement()) {
              userLocationMarker.getElement().classList.add('low-accuracy');
            }
            
            // Większy okrąg dokładności
            updateAccuracyCircle([longitude, latitude], accuracy);
            
            // Zapisz pozycję (ale jej nie używaj do nawigacji)
            lastPosition = [longitude, latitude];
            lastPositionTimestamp = Date.now();
          } else if (userLocationMarker && userLocationMarker.getElement()) {
            // Jeśli już mamy marker, to tylko zaktualizujmy klasę
            userLocationMarker.getElement().classList.add('low-accuracy');
          }
          return;
        } else if (userLocationMarker && userLocationMarker.getElement()) {
          // Jeśli dokładność jest wystarczająca, usuń klasę low-accuracy
          userLocationMarker.getElement().classList.remove('low-accuracy');
        }

        const userLocation = [longitude, latitude];
        const currentTime = Date.now();

        // Utwórz lub aktualizuj marker lokalizacji
        if (!userLocationMarker) {
          createUserMarker(latitude, longitude);
        } else {
          // Ustaw lokalizację dla markera
          userLocationMarker.setLngLat(userLocation);
          
          // Upewnij się, że marker jest widoczny (szczególnie w trybie fullscreen)
          try {
            const el = userLocationMarker.getElement();
            if (el) {
              el.style.visibility = 'visible';
              el.style.display = 'block';
              el.style.zIndex = '9999';
              
              // Sprawdź ograniczenie prędkości
              const userSpeedLimit = document.getElementById('userSpeedLimit');
              if (userSpeedLimit) {
                userSpeedLimit.textContent = currentSpeedLimit;
                userSpeedLimit.style.visibility = 'visible';
                userSpeedLimit.style.display = 'flex';
              }
            }
          } catch (e) {
            console.error("Błąd aktualizacji widoczności markera:", e);
          }
        }

        // Aktualizacja kierunku - rotate marker
        if (heading !== null && heading !== undefined) {
          // Obracamy strzałkę zgodnie z kierunkiem
          userHeading = heading;
          if (userLocationMarker && userLocationMarker.getElement()) {
            userLocationMarker.getElement().style.transform = `rotate(${heading}deg)`;
          }
        } else if (lastPosition && (currentTime - lastPositionTimestamp) > 200) {
          // Oblicz kierunek na podstawie przemieszczenia jeśli brak odczytu z kompasu
          if (calculateDistance(lastPosition[1], lastPosition[0], latitude, longitude) > 2) {
            const calculatedHeading = calculateHeading(
              lastPosition[1], lastPosition[0], 
              latitude, longitude
            );
            userHeading = calculatedHeading;
            
            // Obracamy strzałkę zgodnie z kierunkiem
            if (userLocationMarker && userLocationMarker.getElement()) {
              userLocationMarker.getElement().style.transform = `rotate(${calculatedHeading}deg)`;
            }
          }
        }

        // Zapisz aktualną pozycję
        lastPosition = [longitude, latitude];
        lastPositionTimestamp = currentTime;

        // Aktualizuj okrąg dokładności
        updateAccuracyCircle(userLocation, accuracy);

        // Aktualizuj obrót mapy aby strzałka pokazywała w górę - płynniejsze na telefonach
        if (isMapCentered && mapRotationEnabled && userHeading !== null) {
          // Używamy większej wartości duration dla płynniejszego obrotu
          const duration = userMovedMap ? 1000 : 500;
          map.easeTo({
            center: userLocation,
            bearing: userHeading,
            duration: duration,
            easing: (t) => t * (2 - t) // Funkcja easing dla płynniejszej rotacji
          });
          
          // Reset flagi ruchu użytkownika po wykonaniu animacji
          if (userMovedMap) {
            setTimeout(() => {
              userMovedMap = false;
            }, duration + 100);
          }
        }
        
        // Aktualizacja nawigacji głosowej, jeśli trasa jest aktywna
        if (currentRoute && currentRoute.guidance && currentRoute.guidance.instructions) {
          updateVoiceGuidance(userLocation);
          
          // Aktualizujemy również postęp trasy
          updateRouteProgress();
        }
        
        // Aktualizuj faktyczne ograniczenie prędkości na podstawie pozycji
        updateRealSpeedLimit(latitude, longitude);
      }
      
      // Funkcja tworząca marker użytkownika
      function createUserMarker(latitude, longitude) {
        // Tworzenie strzałki jako element DOM z SVG
          const el = document.createElement('div');
        el.className = 'user-direction-marker';
        el.style.zIndex = '9999';
        el.style.visibility = 'visible';
        el.style.display = 'block';
        
        // Zamiast używać obrazka, używamy SVG wbudowanego w kod z szerszą strzałką i zaokrąglonymi rogami
        el.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="100%" height="100%">
            <path d="M12 2C11.5 2 11 2.2 10.6 2.6L3 18C2.6 18.8 2.8 19.6 3.2 20.2C3.6 20.8 4.4 21 5 21H19C19.6 21 20.4 20.8 20.8 20.2C21.2 19.6 21.4 18.8 21 18L13.4 2.6C13 2.2 12.5 2 12 2Z" 
                  fill="#0066ff" stroke="#ffffff" stroke-width="1.5" stroke-linejoin="round"/>
          </svg>
          <div class="user-speed-limit" id="userSpeedLimit">${currentSpeedLimit || 50}</div>
        `;
        
        // Utwórz marker TomTom
        userLocationMarker = new tt.Marker({
            element: el,
          anchor: 'center',
          rotationAlignment: 'map'  // Zmiana z 'viewport' na 'map'
          })
          .setLngLat([longitude, latitude])
            .addTo(map);
          
        // Po pierwszym pobraniu lokalizacji, wycentruj mapę i obróć ją zgodnie z kierunkiem ruchu
        map.flyTo({
          center: [longitude, latitude],
          zoom: 18,
          duration: 1000,
          bearing: userHeading || 0
        });
        
        console.log("Utworzono marker użytkownika");
        isMapCentered = true;
        userMovedMap = false;
        
        // Ukryj komunikat o uruchamianiu lokalizacji
        messageBox.setAttribute('hidden', true);
        
        // Załaduj ulubione miejsca i rzeczywiste ograniczenia prędkości
        setTimeout(() => {
          if (favoriteLocations.length > 0) {
            updateFavoritesOnMap();
          }
          
          // Pobierz rzeczywiste ograniczenia prędkości
          updateRealSpeedLimit(latitude, longitude);
        }, 1000);
        
        // Dodaj interwał dla aktualizacji markera w trybie fullscreen
        if (!window.userMarkerUpdateInterval) {
          window.userMarkerUpdateInterval = setInterval(() => {
            if (userLocationMarker && document.fullscreenElement) {
              try {
                const markerEl = userLocationMarker.getElement();
                if (markerEl) {
                  markerEl.style.visibility = 'visible';
                  markerEl.style.display = 'block';
                  markerEl.style.zIndex = '9999';
                  
                  // Sprawdź ograniczenie prędkości
                  const userSpeedLimit = document.getElementById('userSpeedLimit');
                  if (userSpeedLimit) {
                    userSpeedLimit.textContent = currentSpeedLimit;
                    userSpeedLimit.style.visibility = 'visible';
                    userSpeedLimit.style.display = 'flex';
                  }
                  
                  // Upewnij się, że strzałka jest prawidłowo obrócona
                  if (userHeading !== null) {
                    markerEl.style.transform = `rotate(${userHeading}deg)`;
                  }
                }
              } catch (error) {
                console.error("Błąd aktualizacji markera:", error);
              }
            }
          }, 500);
        }
      }

      // Mapa jest w pełni załadowana
      map.on('load', function() {
        console.log("Mapa załadowana");
        
        // Dodanie niestandardowego markera do mapy
        map.loadImage('https://api.tomtom.com/maps-sdk-for-web/cdn/static/pictures/poi.png', function(error, image) {
          if (error) throw error;
          map.addImage('marker-custom', image);
        });
        
        // Włącz śledzenie lokalizacji
        startUserLocationTracking();
        
        // Po załadowaniu mapy, pobierz ulubione miejsca z localStorage
        if (favoriteLocations.length > 0) {
          // Odrocz, aby mapa się w pełni załadowała
          setTimeout(updateFavoritesOnMap, 1000);
        }
      });

      // Obsługa geolokalizacji
      function startUserLocationTracking() {
        if (!navigator.geolocation) {
          displayErrorMessage("Twoja przeglądarka nie obsługuje geolokalizacji.");
          return;
        }

        console.log("Uruchamiam śledzenie lokalizacji");

        // Obsługa zdarzenia zoom - ważna dla stabilności markerów
        map.on('zoom', handleZoom);
        map.on('move', handleMapMove);
        map.on('moveend', handleMapMoveEnd);

        // Opcje geolokalizacji z maksymalną dokładnością
        const options = {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 30000  // Zwiększamy timeout do 30 sekund
        };

        // Pokaż informację o uruchamianiu lokalizacji
        displayErrorMessage("Uruchamianie lokalizacji...");
        
        // Najpierw spróbujmy uzyskać jednorazową pozycję, aby szybciej ustawić mapę
        navigator.geolocation.getCurrentPosition(
          (position) => {
            console.log("Otrzymano początkową pozycję", position);
            // Aktualizuj mapę na podstawie początkowej pozycji
            updateUserLocation(position);
            
            // Pokaż komunikat o sukcesie
            displayErrorMessage("Lokalizacja znaleziona!", 2000);
            
            // Rozpocznij ciągłe śledzenie
            startContinuousTracking(options);
          },
          (error) => {
            console.error("Błąd podczas uzyskiwania początkowej pozycji:", error);
            displayErrorMessage("Błąd podczas uzyskiwania pozycji: " + (messages[error.code] || messages.default));
            
            // Spróbuj jeszcze raz z mniejszą dokładnością
            navigator.geolocation.getCurrentPosition(
              (position) => {
                console.log("Otrzymano pozycję z drugiej próby");
                updateUserLocation(position);
            startContinuousTracking(options);
              },
              (secondError) => {
                console.error("Drugi błąd lokalizacji:", secondError);
                displayErrorMessage("Nie można określić Twojej lokalizacji. Sprawdź uprawnienia.");
              },
              { enableHighAccuracy: false, timeout: 15000, maximumAge: 0 }
            );
          },
          { ...options, timeout: 10000 } // Krótszy timeout dla pierwszej próby
        );
      }
      
      // Funkcja do ciągłego śledzenia lokalizacji
      function startContinuousTracking(options) {
        // Rozpocznij śledzenie lokalizacji
        try {
          if (userWatchId) {
            navigator.geolocation.clearWatch(userWatchId);
          }
          
          // Dodanie dodatkowych opcji dla urządzeń mobilnych
          const mobileOptions = {
            ...options,
            // Na urządzeniach mobilnych częściej aktualizujemy pozycję
            maximumAge: 0
          };
          
          userWatchId = navigator.geolocation.watchPosition(
            updateUserLocation,
            handleLocationError,
            mobileOptions
          );
          
          // Domyślnie włączamy obrót mapy - bardzo ważne na telefonie
          mapRotationEnabled = true;
          rotationToggle.checked = true;
          
          console.log("Rozpoczęto ciągłe śledzenie lokalizacji, ID:", userWatchId);
        } catch (e) {
          console.error("Błąd podczas uruchamiania geolokalizacji:", e);
          displayErrorMessage("Błąd podczas uruchamiania lokalizacji: " + e.message);
        }
      }

      // Aktualizacja widoczności przycisku centrowania
      function updateCenterButtonVisibility() {
        if (isMapCentered && !userMovedMap) {
          centerButton.classList.remove('visible');
        } else {
          centerButton.classList.add('visible');
        }
      }

      // Obsługa przycisku centrowania
      centerButton.addEventListener('click', function() {
        if (!userLocationMarker) {
          displayErrorMessage("Uruchamiam śledzenie lokalizacji...");
          startUserLocationTracking();
          return;
        }
        
        const userLocation = userLocationMarker.getLngLat();
        const bearing = mapRotationEnabled ? userHeading || 0 : 0;
        
        map.flyTo({
          center: userLocation,
          zoom: 18,
          bearing: bearing,
          duration: 1000,
          easing: (t) => t * (2 - t) // Funkcja easing dla płynniejszej animacji
        });
        
        isMapCentered = true;
        userMovedMap = false;
        
        // Włącz autocentrowanie po kliknięciu przycisku
        autoCenteringEnabled = true;
        displayErrorMessage("Autocentrowanie włączone", 2000);
      });

      // Wyświetlanie komunikatu o błędzie
      function displayErrorMessage(message, durationMs = 5000) {
        if (!messageBox || !messageBoxContent) {
          console.error("Elementy UI nie zostały jeszcze zainicjalizowane");
          console.log("Komunikat:", message);
          // Spróbuj pobrać elementy jeszcze raz
          const msgBox = document.getElementById("messageBox");
          const msgContent = document.getElementById("messageBoxContent");
          
          if (msgBox && msgContent) {
            msgContent.textContent = message;
            msgBox.removeAttribute('hidden');
            return;
          }
          
          // Jeśli nadal nie ma elementów, utwórz tymczasowy komunikat
          let tempMsg = document.getElementById("tempMessage");
          if (!tempMsg) {
            tempMsg = document.createElement("div");
            tempMsg.id = "tempMessage";
            tempMsg.style.position = "absolute";
            tempMsg.style.top = "10px";
            tempMsg.style.left = "50%";
            tempMsg.style.transform = "translateX(-50%)";
            tempMsg.style.background = "white";
            tempMsg.style.padding = "10px";
            tempMsg.style.borderRadius = "5px";
            tempMsg.style.zIndex = "9999";
            document.body.appendChild(tempMsg);
          }
          tempMsg.textContent = message;
          return;
        }
        
        // Anuluj poprzedni timer ukrywania wiadomości, jeśli istnieje
        if (window.messageHideTimeout) {
          clearTimeout(window.messageHideTimeout);
          window.messageHideTimeout = null;
        }
        
        // Standardowe wyświetlanie
        messageBoxContent.textContent = message;
        messageBox.removeAttribute('hidden');
        
        // Dodaj klasę dla lepszej widoczności
        messageBox.style.opacity = "1";
        
        // Automatyczne ukrycie po określonym czasie
        if (durationMs > 0) {
          window.messageHideTimeout = setTimeout(() => {
          if (messageBox && !messageBox.getAttribute('hidden')) {
              // Płynne ukrycie
              messageBox.style.opacity = "0";
              setTimeout(() => {
            messageBox.setAttribute('hidden', true);
                messageBox.style.opacity = "1"; // Przywróć opacity dla następnego użycia
              }, 300);
          }
        }, durationMs);
        }
        
        // Dodanie obsługi kliknięcia przycisku zamknięcia
        if (messageBoxClose) {
          messageBoxClose.onclick = function() {
            messageBox.setAttribute('hidden', true);
            if (window.messageHideTimeout) {
              clearTimeout(window.messageHideTimeout);
              window.messageHideTimeout = null;
            }
          };
        }
      }

      // Obsługa ruchu mapy
      function handleMapMove(e) {
        if (e.originalEvent) {
          lastMapMoveTime = Date.now();
          userMovedMap = true;
          isMapCentered = false;
        }
      }

      // Dodaj trasę do mapy
      function addRouteToMap(route) {
        // Usuń poprzednią trasę jeśli istnieje
        if (map.getLayer('route')) {
          map.removeLayer('route');
        }
        
        if (map.getSource('route')) {
          map.removeSource('route');
        }
        
        // Dodaj nowe źródło i warstwę
        const routeGeoJson = {
          type: 'Feature',
          properties: {},
          geometry: {
            type: 'LineString',
            coordinates: route.legs[0].points.map(point => [point.longitude, point.latitude])
          }
        };
        
        map.addSource('route', {
          type: 'geojson',
          data: routeGeoJson
        });
        
        map.addLayer({
          id: 'route',
          type: 'line',
          source: 'route',
          layout: {
            'line-join': 'round',
            'line-cap': 'round'
          },
          paint: {
            'line-color': '#4CAF50',
            'line-width': 6,
            'line-opacity': 0.8
          }
        });
      }
      
      // Pokaż panel nawigacji
      function showNavigationPanel(route) {
        // Przygotuj treść panelu
        let content = '';
        
        if (route.guidance && route.guidance.instructions) {
          const nextInstruction = route.guidance.instructions[0];
          
          // Dodaj informacje o dystansie i czasie
          const totalDistance = Math.round(route.summary.lengthInMeters / 10) / 100; // w km
          const eta = new Date(Date.now() + route.summary.travelTimeInSeconds * 1000);
          const etaString = eta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          
          content += `
            <div style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee;">
              <div style="font-size: 14px; color: #666;">Dystans: ${totalDistance} km</div>
              <div style="font-size: 14px; color: #666;">Przyjazd: ${etaString}</div>
            </div>
          `;
          
          // Dodaj kolejny manewr
          if (nextInstruction) {
            // Określ odpowiednią ikonę dla manewru
            let iconClass = 'arrow-right';
            if (nextInstruction.message.toLowerCase().includes('skręć w lewo')) {
              iconClass = 'arrow-left';
            } else if (nextInstruction.message.toLowerCase().includes('skręć w prawo')) {
              iconClass = 'arrow-right';
            } else if (nextInstruction.message.toLowerCase().includes('prosto')) {
              iconClass = 'arrow-up';
            } else if (nextInstruction.message.toLowerCase().includes('zawróć')) {
              iconClass = 'arrow-down';
            } else if (nextInstruction.message.toLowerCase().includes('rondo')) {
              iconClass = 'undo';
            }
            
            content += `
              <div class="navigation-step">
                <div class="navigation-icon">
                  <i class="fas fa-${iconClass}"></i>
                </div>
                <div class="navigation-info">
                  ${nextInstruction.message}
                  <div class="navigation-distance">
                    <span id="next-maneuver-distance">---</span> m
                  </div>
                </div>
              </div>
            `;
            
            // Dodaj kolejny manewr jeśli istnieje
            if (route.guidance.instructions.length > 1) {
              const followingInstruction = route.guidance.instructions[1];
              
              // Określ ikonę dla następnego manewru
              let nextIconClass = 'arrow-right';
              if (followingInstruction.message.toLowerCase().includes('skręć w lewo')) {
                nextIconClass = 'arrow-left';
              } else if (followingInstruction.message.toLowerCase().includes('skręć w prawo')) {
                nextIconClass = 'arrow-right';
              } else if (followingInstruction.message.toLowerCase().includes('prosto')) {
                nextIconClass = 'arrow-up';
              } else if (followingInstruction.message.toLowerCase().includes('zawróć')) {
                nextIconClass = 'arrow-down';
              } else if (followingInstruction.message.toLowerCase().includes('rondo')) {
                nextIconClass = 'undo';
              }
              
              content += `
                <div class="navigation-step" style="opacity: 0.7;">
                  <div class="navigation-icon" style="background: #999;">
                    <i class="fas fa-${nextIconClass}"></i>
                  </div>
                  <div class="navigation-info">
                    ${followingInstruction.message}
                  </div>
                </div>
              `;
            }
          }
        }
        
        // Aktualizuj treść panelu
        navigationContent.innerHTML = content;
        
        // Pokaż panel
        navigationPanel.style.display = 'block';
        
        // Dodaj obsługę zamknięcia
        navigationClose.addEventListener('click', () => {
          // Zatrzymaj aktualizację trasy
          if (routeUpdateInterval) {
            clearInterval(routeUpdateInterval);
            routeUpdateInterval = null;
          }
          
          // Ukryj panel
          navigationPanel.style.display = 'none';
          
          // Usuń trasę z mapy
          if (map.getLayer('route')) {
            map.removeLayer('route');
          }
          
          if (map.getSource('route')) {
            map.removeSource('route');
          }
          
          // Zresetuj zmienne nawigacji
          currentRoute = null;
          currentStep = 0;
          
          // Powiedz użytkownikowi, że nawigacja została zakończona
          speakInstruction("Nawigacja zakończona");
        });
      }
      
      // Aktualizacja postępu trasy
      function updateRouteProgress() {
        if (!currentRoute || !userLocationMarker) {
          return;
        }
        
        const userLocation = userLocationMarker.getLngLat();
        
        // Jeśli mamy instrukcje nawigacji, sprawdź czy minęliśmy jakiś punkt
        if (currentRoute.guidance && currentRoute.guidance.instructions && currentRoute.guidance.instructions.length > currentStep) {
          const nextInstruction = currentRoute.guidance.instructions[currentStep];
          
          if (nextInstruction && nextInstruction.point) {
            // Oblicz odległość do kolejnego manewru
            const distanceToManeuver = calculateDistance(
              userLocation.lat, userLocation.lng,
              nextInstruction.point.latitude, nextInstruction.point.longitude
            );
            
            // Aktualizuj wyświetlaną odległość
            const distanceElement = document.getElementById('next-maneuver-distance');
            if (distanceElement) {
              distanceElement.textContent = Math.round(distanceToManeuver);
            }
            
            // Sprawdź czy minęliśmy już ten punkt manewru
            if (distanceToManeuver < 15) {
              // Manewr wykonany, przejdź do następnego
              currentStep++;
              
              // Jeśli nie ma więcej instrukcji, to znaczy że dojechaliśmy do celu
              if (currentStep >= currentRoute.guidance.instructions.length) {
                speakInstruction("Dotarłeś do celu");
                
                // Zatrzymaj aktualizację trasy
                if (routeUpdateInterval) {
                  clearInterval(routeUpdateInterval);
                  routeUpdateInterval = null;
                }
                
                // Ukryj panel po 5 sekundach
                setTimeout(() => {
                  navigationPanel.style.display = 'none';
                  
                  // Usuń trasę z mapy
                  if (map.getLayer('route')) {
                    map.removeLayer('route');
                  }
                  
                  if (map.getSource('route')) {
                    map.removeSource('route');
                  }
                  
                  // Zresetuj zmienne nawigacji
                  currentRoute = null;
                  currentStep = 0;
                }, 5000);
                
                return;
              }
              
              // Aktualizuj panel nawigacji z nową instrukcją
              showNavigationPanel(currentRoute);
              
              // Podaj nową instrukcję głosową
              const newInstruction = currentRoute.guidance.instructions[currentStep];
              speakInstruction(newInstruction.message);
            }
          }
        }
      }

      // Funkcja do wykonywania wyszukiwania
      function performSearch(query) {
        if (!query || query.length < 3) {
          displayErrorMessage("Wprowadź co najmniej 3 znaki");
          return;
        }
        
        displayErrorMessage("Wyszukiwanie...", 2000);
        
        tt.services.fuzzySearch({
          key: apiKey,
          query: query,
          language: 'pl-PL',
          limit: 5
        })
        .then(response => {
          if (response.results && response.results.length > 0) {
            // Wyświetl pierwsze znalezione miejsce
            const result = response.results[0];
            displayErrorMessage("Znaleziono: " + result.address.freeformAddress + ". Uruchamiam nawigację...", 3000);
            
            // Wyczyść pole wyszukiwania i rozpocznij nawigację
            const permanentSearchInput = document.getElementById('permanentSearchInput');
            if (permanentSearchInput) {
              permanentSearchInput.value = result.address.freeformAddress;
            }
            
            // Nawigacja do znalezionego miejsca
            selectDestination(result.position);
          } else {
            displayErrorMessage("Nie znaleziono wyników dla: " + query);
          }
        })
        .catch(error => {
          console.error('Błąd wyszukiwania:', error);
          displayErrorMessage("Błąd wyszukiwania: " + error.message);
        });
      }

      function handleZoom() {
        // Aktualizujemy rozmiar okręgu dokładności
        if (userAccuracyCircle && userAccuracyCircle.getElement() && window.lastAccuracy) {
          const zoom = map.getZoom();
          const pixelSize = window.lastAccuracy / 0.075 / Math.pow(2, zoom);
          userAccuracyCircle.getElement().style.width = `${pixelSize}px`;
          userAccuracyCircle.getElement().style.height = `${pixelSize}px`;
        }
        
        // Po zakończeniu zoom, odśwież pozycję markera
        if (userLocationMarker && lastPosition) {
          userLocationMarker.setLngLat(lastPosition);
        }
      }

      // Obsługa zakończenia przesuwania mapy
      function handleMapMoveEnd(e) {
        if (e.originalEvent) {
          console.log("Użytkownik zakończył przesuwanie mapy");
          lastMapMoveTime = Date.now();
        }
      }

      // Inicjalizacja mapy i UI
      window.addEventListener('load', function() {
        // Ustaw początkowy stan elementów
        const permanentSearch = document.getElementById('permanentSearch');
        const permanentSpeed = document.getElementById('permanentSpeed');
        
        if (permanentSearch) {
          permanentSearch.style.display = 'none'; // Początkowo ukryte
        }
        
        if (permanentSpeed) {
          permanentSpeed.style.display = 'none'; // Początkowo ukryte
        }
        
        // Sprawdź czy jesteśmy już w trybie fullscreen
        const isFullscreen = document.fullscreenElement || 
                             document.mozFullScreenElement || 
                             document.webkitFullscreenElement || 
                             document.msFullscreenElement;
                       
        if (isFullscreen) {
          if (permanentSearch) {
            permanentSearch.style.display = 'flex';
          }
          if (permanentSpeed) {
            permanentSpeed.style.display = 'flex';
          }
          
          // Ukryj standardowe elementy
          const searchBtn = document.getElementById('searchBtn');
          if (searchBtn) {
            searchBtn.style.display = 'none';
          }
        }
      });

      // Obsługa błędów geolokalizacji
      function handleLocationError(error) {
        console.error("Błąd geolokalizacji:", error);
        
        let errorMessage = "";
        switch(error.code) {
          case error.PERMISSION_DENIED:
            errorMessage = messages.permissionDenied;
            break;
          case error.POSITION_UNAVAILABLE:
            errorMessage = messages.notAvailable;
            break;
          case error.TIMEOUT:
            errorMessage = messages.timeout;
            break;
          default:
            errorMessage = messages.default;
        }
        
        displayErrorMessage(errorMessage);
        
        // Wyświetl domyślną mapę skoncentrowaną na Warszawie
        if (!userLocationMarker) {
          map.flyTo({
            center: [21.0122, 52.2297], // Warszawa
            zoom: 13,
            duration: 1000
          });
        }
      }
    </script>
  </body>
</html>
